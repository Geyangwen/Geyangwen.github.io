<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="标签: Android, 小文同学">
    <meta name="description" content="你的征途是星辰大海，怎么能被眼前的挫折打败。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>标签: Android | 小文同学</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="小文同学" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="./images/loading.gif" data-original="https://blog-accelerated.oss-cn-hangzhou.aliyuncs.com/source/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小文同学</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">

      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a target="_blank" rel="noopener" href="https://www.kugou.com/">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>酷狗音乐</span>
        </a>
      </li>
      
      <li>
        <a target="_blank" rel="noopener" href="https://search.bilibili.com/">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>哔哩哔哩</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="./images/loading.gif" data-original="https://blog-accelerated.oss-cn-hangzhou.aliyuncs.com/source/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">小文同学</div>
        <div class="logo-desc">
            
            你的征途是星辰大海，怎么能被眼前的挫折打败。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-address-book"></i>
			
			友情链接
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a target="_blank" rel="noopener" href="https://www.kugou.com/ " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>酷狗音乐</span>
                  </a>
                </li>
              
                <li>

                  <a target="_blank" rel="noopener" href="https://search.bilibili.com/ " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>哔哩哔哩</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Geyangwen/Geyangwen.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Geyangwen/Geyangwen.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://blog-accelerated.oss-cn-hangzhou.aliyuncs.com/source/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Android驱动的系统笔记1</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Android%E9%A9%B1%E5%8A%A8/">
                                <span class="chip bg-color">Android驱动</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Android/" class="post-category">
                                Android
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-08-09
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    112.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    449 分
                </div>
                

                
                    <span id="busuanzi_container_site_pv" style='display:none'></span>
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv" ></span>
            
            
            
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p>注意：本网站所有内容为自己学习期间记录的笔记，基本都是原作者那边摘抄过来的，不作商业用途也不插播广告。（如有侵权，请联系我删除，15909440083）</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/33785640/channel/seriesdetail?sid=2726018">北京迅为电子</a></p>
<p><a target="_blank" rel="noopener" href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-22452452613.11.2fec74a6elWNeA&amp;id=669939423234">同款开发板购买链接</a></p>
<p>【第16期的 最新驱动资料（文档+例程）】<br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1Qf5d5_e2u_VklJWJK9wzNQ">https://pan.baidu.com/s/1Qf5d5_e2u_VklJWJK9wzNQ</a>      提取码：n4q6</p>
</blockquote>
<h1 id="第一篇-驱动基础"><a href="#第一篇-驱动基础" class="headerlink" title="第一篇 驱动基础"></a>第一篇 驱动基础</h1><h2 id="第1-章-前言"><a href="#第1-章-前言" class="headerlink" title="第1 章 前言"></a>第1 章 前言</h2><h3 id="1-2-基础准备"><a href="#1-2-基础准备" class="headerlink" title="1.2 基础准备"></a>1.2 基础准备</h3><p>首先，不要脱离硬件。就好比用仿真软件学习51 单片机是永远掌握不了单片机的精髓的。所以有一块硬件开发板是学习驱动的前提。</p>
<p>第二，有了开发板之后，要掌握开发板的基本操作。如开发板的启动，烧写镜像等操作。</p>
<p>第三，能够成功编译开发板的系统源码。在驱动的学习过程中，是避免不了的要对内核的某些功能进行使能、修改设备树添加对应的设备，这些操作都需要进行源码编译。</p>
<p>第四，掌握C 语言。驱动程序是由C 语言编写的，而且内核源码中绝大多数的代码也都是由C 语言编写的，在学习驱动的过程中，或多或少的要对源码进行阅读。所以C 语言基础是学习驱动的必要条件之一。</p>
<p>第五，掌握Linux 环境搭建以及shell 命令的使用。</p>
<p>第六，驱动最后必然要落实到相应的硬件上，所以肯定要对底层电路有所了解，以驱动LED 灯为例，必然要了解其控制电路，找到相应的控制引脚，要能读懂简单的硬件原理图。</p>
<h2 id="第2-章你好！内核源码"><a href="#第2-章你好！内核源码" class="headerlink" title="第2 章你好！内核源码"></a>第2 章你好！内核源码</h2><p>本章我们来认识Linux 内核源码</p>
<p>2.1 初识内核源码<br>Linux 内核源码的官方网站为<a target="_blank" rel="noopener" href="https://www.kernel.org/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84Linux">https://www.kernel.org/，可以在该网站下载最新的Linux</a> 内核源码。进入该网站之后如下图（图2-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091454906.png" alt="图2-1"></p>
<p>从上图（图1）可以看到多个版本的内核分支，分别为主线版本（mainline）、稳定版本（stable）和长期支持版本（longterm）。以上各个支线和主线是由linus torvalds（Linux 之父）所领导。半导体厂商和一些内核爱好者会在官网下载相应版本的内核源码，对该源码进行打补丁等操作。以此让官网的内核源码可以在半导体厂家设计的主控（CPU）上跑起来，所以在开发和学习的过程中，我们并不会直接去Linux 内核官网下去下载源码，而是使用半导体厂家提供的源码包。</p>
<p>但是不论是Linux 官网的内核源码还是半导体厂家提供的内核源码不影响我们来看它的庐山真面目！讯为下载了Linux 官方网站的4.19.262 分支源码，下载好的源码存放在“iTOP-RK3568开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\01_Linux内核官方源码”如下图（图2-2）所示：（我自己下了一个最新的！）</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091456709.png" alt="image-20240809145649679"></p>
<p>将Linux 内核官方源码拷贝到虚拟机ubuntu 上如下图（图2-3）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091458678.png" alt="image-20240809145817648"></p>
<p>使用以下命令对内核官方源码进行解压，解压完成如下图（图2-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">tar</span> <span class="token parameter variable">-vxf</span> linux-4.19.262.tar.xz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091458655.png" alt="image-20240809145855618"></p>
<p>解压完成后我们会看到非常多的文件夹，这些文件夹放的就是Linux 内核源码，在下一小节中作者来介绍Linux 内核源码的结构和每个目录的作用。</p>
<h3 id="2-2-内核源码结构"><a href="#2-2-内核源码结构" class="headerlink" title="2.2 内核源码结构"></a>2.2 内核源码结构</h3><p>目录的内容如下表（表2-6）所示：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>存放不同平台体系相关代码</td>
</tr>
<tr>
<td>block</td>
<td>存放块设备相关代码</td>
</tr>
<tr>
<td>crypto</td>
<td>存放加密、压缩、CRC 校验等算法相关代码</td>
</tr>
<tr>
<td>Documentation</td>
<td>存放相关说明文档，很多实用文档，包括驱动编写等</td>
</tr>
<tr>
<td>drivers</td>
<td>存放Linux 内核设备驱动程序源码。该目录包含众多驱动，目录按照设备类别进行分类，如char、block 、input、i2c、spi、pci、usb 等。</td>
</tr>
<tr>
<td>firmware</td>
<td>存放处理器相关的一些特殊固件</td>
</tr>
<tr>
<td>fs</td>
<td>存放虚拟文件系统代码</td>
</tr>
<tr>
<td>include</td>
<td>存放内核所需、与平台无关的头文件</td>
</tr>
<tr>
<td>init</td>
<td>Linux 系统启动初始化相关的代码</td>
</tr>
<tr>
<td>ipc</td>
<td>存放进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>Linux 内核的核心代码，包含了进程调度子系统，以及和进程调度相关的模块。</td>
</tr>
<tr>
<td>lib</td>
<td>库文件代码， 实现需要在内核中使用的库函数，例如CRC、FIFO、list、MD5等。</td>
</tr>
<tr>
<td>mm</td>
<td>实现存放内存管理代码</td>
</tr>
<tr>
<td>net</td>
<td>存放网络相关代码</td>
</tr>
<tr>
<td>samples</td>
<td>存放提供的一些内核编程范例</td>
</tr>
<tr>
<td>scripts</td>
<td>存放一些脚本文件</td>
</tr>
<tr>
<td>security</td>
<td>存放系统安全性相关代码</td>
</tr>
<tr>
<td>sound</td>
<td>存放声音、声卡相关驱动</td>
</tr>
<tr>
<td>tools</td>
<td>一些常用工具，如性能剖析、自测试等</td>
</tr>
<tr>
<td>usr</td>
<td>用于生成initramfs 的代码。</td>
</tr>
<tr>
<td>virt</td>
<td>提供虚拟机技术（KVM 等）的支持</td>
</tr>
</tbody></table>
<p>2.3 编译内核源码</p>
<p>本小节使用的内核源码是半导体厂家提供的内核源码，是我们学习和开发要使用的内核源码。在进行驱动学习之前需要将此内核源码编译成功。<br>内核源码存放路径为“iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\02_Linux_SDK 源码”，将对应目录下的内核源码拷贝到虚拟机ubuntu 目录下，如下图（图2-7）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091509055.png" alt="image-20240809150920027"></p>
<p>注：编译环境使用的是迅为搭建好的编译环境，迅为的环境经过测试在不进行修改的前提下，可以直接将内核源码编译通过。（我自己放到自己的目录下没有编译成功！）</p>
<p>使用以下命令对内核源码的进行解压，解压完成如下图（图2-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-vxf</span> linux_sdk.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用“<code>cd linux_sdk</code>”命令进入内核源码目录，如下图（图2-9）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091512606.png" alt="image-20240809151231581"></p>
<p>使用命令“<code>./build.sh kernel</code>”进行内核源码的编译，编译过程如下图（图2-10）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091512445.png" alt="image-20240809151250417"></p>
<p>编译时间和电脑虚拟机配置相关，编译完成如下图（图2-11)所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091521547.png" alt="image-20240809152115505"></p>
<p>不知道为啥，反正我的没编译成功。</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091521369.png" alt="image-20240809152112335" style="zoom:50%;">

<p>通过对内核源码官网的探索，内核源码的目录结构讲解以及内核源码的编译。我相信大家对Linux 内核源码应该有了一个初步的认识了。下一章我们来学习第一个驱动helloworld。</p>
<h2 id="第3-章-helloworld-驱动实验"><a href="#第3-章-helloworld-驱动实验" class="headerlink" title="第3 章 helloworld 驱动实验"></a>第3 章 helloworld 驱动实验</h2><p>在学习C 语言或者其他语言的时候，我们通常是打印一句“helloworld”来开启编程世界的大门。学习驱动程序编程亦可以如此，使用helloworld 作为我们的第一个驱动程序。接下来开始编写第一个驱动程序—helloworld。</p>
<h3 id="3-1-驱动编写"><a href="#3-1-驱动编写" class="headerlink" title="3.1 驱动编写"></a>3.1 驱动编写</h3><p>本小节来编写一个最简单的驱动——helloworld 驱动。helloworld.c 如下（图3-1）所示代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">helloworld_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//驱动入口函数</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_init\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//注意：内核打印用printk 而不是printf</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">helloworld_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//驱动出口函数</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_exit\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>helloworld_init<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//注册入口函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>helloworld_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//注册出口函数</span>

<span class="token comment">/* 
 * 设置模块的许可协议。
 * 设置模块的作者信息。
 * 设置模块的描述信息。
 */</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"Dual BSD/GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//或者用这个 MODULE_LICENSE("GPL v2");</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"xiaowen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"A simple Hello world module"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>看似非常简单的helloworld 驱动代码，却五脏俱全。一个简单的helloworld 驱动包含驱动的基本框架。我们继续往下看。</p>
<h2 id="3-2-驱动的基本框架"><a href="#3-2-驱动的基本框架" class="headerlink" title="3.2 驱动的基本框架"></a>3.2 驱动的基本框架</h2><p>Linux 驱动的基本框架主要由模块加载函数，模块卸载函数，模块许可证声明，模块参数，模块导出符号，模块作者信息等几部分组成，其中模块参数，模块导出符号，模块作者信息是可选的部分，也就是可要可不要。剩余部分是必须有的。我们来看一下这几个部分的作用：</p>
<ul>
<li>1 模块加载函数<br>当使用加载驱动模块时，内核会执行模块加载函数，完成模块加载函数中的初始化工作。</li>
<li>2 模块卸载函数<br>当卸载某模块时，内核会执行模块卸载函数，完成模块卸载函数中的退出工作。</li>
<li>3 模块许可证声明<br>许可证声明描述了内核模块的许可权限，如果不声明模块许可，模块在加载的时候，会收到“内核被污染（kernel tainted）”的警告。可接受的内核模块声明许可包括“GPL”“GPL v2”。</li>
<li>4 模块参数（可选择）<br>模块参数是模块被加载的时候可以传递给它的值。</li>
<li>5 模块导出符号（可选择）<br>内核模块可以导出的符号，如果导出，其他模块可以使用本模块中的变量或函数。</li>
<li>6 模块作者信息等说明（可选择）<br>上一小节我们说，helloworld 驱动麻雀虽小五脏俱全，我们来分析helloworld 驱动。通过helloworld 代码再来看驱动框架。</li>
</ul>
<p>（1）模块加载函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">helloworld_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//驱动入口函数</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_init\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>helloworld_init<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注册入口函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（2）模块卸载函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">helloworld_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//驱动出口函数</span>
	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_exit\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>helloworld_exit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注册出口函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>（3）模块许可证声明</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//同意GPL 开源协议</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>（4）模块作者信息</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//作者信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>（5）头文件</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span> <span class="token comment">//模块加载函数和卸载函数需要的头文件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通过上面的分析，helloworld 驱动是不是包含了驱动框架的所有必要的部分呢。因此helloworld 驱动我们可以看作是驱动代码的模板。任何一个驱动代码都用它作为基础来编写实现。同学们要将他记忆下来！</p>
<h2 id="第4-章内核模块实验"><a href="#第4-章内核模块实验" class="headerlink" title="第4 章内核模块实验"></a>第4 章内核模块实验</h2><p>在上一章节我们编写了最简单的helloworld 驱动程序。有了驱动程序以后，要如何编译并使用驱动呢。编译驱动有俩种方法，分别是将驱动编译成内核和将驱动编译成内核模块。我们先来学习如何将驱动编译成内核模块、(我没用买板子，我还是用的系统的gcc，如果大家有板子一定要用这个交叉编译器啊)</p>
<h3 id="4-1-设置交叉编译器"><a href="#4-1-设置交叉编译器" class="headerlink" title="4.1 设置交叉编译器"></a>4.1 设置交叉编译器</h3><p>1 下载网盘资料下的交叉编译器，网盘路径为：“iTOP-3568 开发板\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\03_交叉编译器”，将下载的交叉编译器拷贝到Ubuntu的/usr/local 目录下，如下图（图4-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091534024.png" alt="image-20240809153437994"></p>
<p>2 输入以下命令，解压交叉编译编译器压缩包，解压完毕会生成“gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu”文件夹，这是实验需要的交叉编译工具，如下图（图4-2）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-vxf</span> gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091535405.png" alt="image-20240809153503380"></p>
<p>3 在终端输入“<code>sudo vi /etc/profile</code>”命令，在文件最后输入以下命令修改环境变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/usr/local/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091537951.png" alt="image-20240809153736924"></p>
<p>4 保存退出，在终端输入“reboot”命令重新启动Ubuntu 系统，使交叉编译环境生效。Ubuntu 系统重新启动之后，登录到系统后，打开终端，输入命令“<code>aarch64-linux-gnu-gcc -v</code>”，如果终端有如下图（图4-4）所示的打印信息，说明交叉编译环境搭建成功。如果没有出现如下图（图4-4）的打印信息，需要检查上一步骤是否设置正确。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091538279.png" alt="image-20240809153808211"></p>
<h3 id="4-2-编写Makefile"><a href="#4-2-编写Makefile" class="headerlink" title="4.2 编写Makefile"></a>4.2 编写Makefile</h3><p>编译驱动程序还需要使用Makefile 文件。我们为helloworld.c 编写一个简单的Makefile，Makefile 文件和源文件<code>helloworld.c</code> 位于同一级目录，代码如下（图4-5）所示：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">export</span> ARCH<span class="token operator">=</span>arm64								<span class="token comment">#设置ARCH 变量为arm64</span>
<span class="token keyword">export</span> CROSS_COMPILE<span class="token operator">=</span>aarch64-linux-gnu-			<span class="token comment">#交叉编译器前缀</span>
obj-m <span class="token operator">:=</span> helloworld.o						<span class="token comment"># helloworld.c 对应.o 文件的名称。名称要保持一致。</span>
KDIR <span class="token operator">:=</span>/home/topeet/Linux/linux_sdk/kernel    <span class="token comment">#这里是你的内核目录                                                                                                                            </span>
PWD <span class="token operator">?=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>
<span class="token target symbol">all</span><span class="token punctuation">:</span>
	make -C <span class="token variable">$</span><span class="token punctuation">(</span>KDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> modules    <span class="token comment">#make操作</span>
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	make -C <span class="token variable">$</span><span class="token punctuation">(</span>KDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> clean    <span class="token comment">#make clean操作</span>
第1 行设置ARCH 变量为arm64
第2 行设置交叉编译器前缀为aarch64-linux-gnu-
第3 行obj-m <span class="token operator">+=</span> &lt;文件&gt;：将指定的文件（需要是以.o 结尾）设为编译时以模块形式编译
第4 行是设备树内核的源码路径，请大家根据实际内核路径进行修改。
第5 行是获取当前目录的变量
第7 行是编译make 操作，会进入内核源码的路径，然后把当前路径下的代码编译成模块。
第9 行是清除编译文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>没有正开发板的就用下面的编译吧，我用的比较习惯，记得要改最后的<code>obj-m:=hello.o</code></p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Makefile</span>
<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">warning</span> KERNELRELEASE<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>KERNELRELEASE<span class="token punctuation">)</span><span class="token punctuation">)</span>		<span class="token comment"># 使用$(warning)函数输出变量KERNELRELEASE的值</span>

<span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>KERNELRELEASE<span class="token punctuation">)</span>,<span class="token punctuation">)</span>	<span class="token comment"># 判断条件，如果KERNELRELEASE为空，则执行以下代码块</span>

<span class="token comment"># 定义变量KERNELDIR，如果未定义，则默认值为/lib/modules/当前内核版本/build</span>
<span class="token comment"># 使用$(shell)函数获取当前内核版本</span>
KERNELDIR <span class="token operator">?=</span> /lib/modules/<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> uname -r<span class="token punctuation">)</span>/build
<span class="token comment"># 使用$(shell)函数获取当前目录路径</span>
PWD <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>

<span class="token comment"># 定义目标modules，通过$(MAKE)命令在$(KERNELDIR)目录下编译当前目录下的模块</span>
<span class="token target symbol">modules</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>KERNELDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> modules
<span class="token comment"># 清理编译过程中生成的临时文件和目标文件</span>
	rm -rfv *.o *~ core .depend .*.cmd *.mod.c *.mod .tmp_versions Module* modules*

<span class="token comment"># 定义目标modules_install，通过$(MAKE)命令在$(KERNELDIR)目录下安装当前目录下的模块</span>
<span class="token target symbol">modules_install</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>KERNELDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> modules_install

<span class="token comment"># 定义目标clean，用于清理编译过程中生成的临时文件和目标文件</span>
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	rm -rfv *.o *~ core .depend .*.cmd *.ko *.mod.c *.mod .tmp_versions Module* modules*

<span class="token comment"># 定义伪目标.PHONY，用于标识以下目标为伪目标，即使文件系统中存在同名文件，也不会被认为是该目标的产物</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> modules modules_install clean

<span class="token comment"># 条件语句之外的代码块，用于定义obj-m变量，指向当前目录下的hello.o模块文件</span>
<span class="token keyword">else</span>
	obj-m<span class="token operator">:=</span>hello.o

<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编写完成如下图（图4-6）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091553580.png" alt="image-20240809155321556"></p>
<h3 id="4-3-编译模块"><a href="#4-3-编译模块" class="headerlink" title="4.3 编译模块"></a>4.3 编译模块</h3><p>有了Makefile 以后，输入“<code>make</code>”命令就可以编译helloworld 驱动模块，如下图（图4-7）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091553452.png" alt="image-20240809155341418"></p>
<p>编译完生成helloworld.ko 目标文件就是我们需要的内核模块。内核模块是以ko 为后缀名，如下图（图4-8）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091553819.png" alt="image-20240809155355795"></p>
<p>输入“<code>make clean</code>”命令清除编译文件，如下图（图4-9）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091554726.png" alt="image-20240809155432698"></p>
<h3 id="4-4-模块加载与卸载"><a href="#4-4-模块加载与卸载" class="headerlink" title="4.4 模块加载与卸载"></a>4.4 模块加载与卸载</h3><p>有了内核模块以后，我们要如何使用呢？编译驱动有俩种方式，那Linux 驱动的运行方式也肯定有俩种。一种就是将驱动编译进内核，这样Linux 系统启动后会自动运行程序。第二种就是将驱动编译成模块，在Linux 系统启动以后使“<code>insmod</code>”命令加载驱动模块。在上个小节中编译了驱动模块<code>helloworld.ko</code> ， 在RK3568 开发板上通过“ <code>insmod helloworld.ko</code>”命令可以加载驱动，在加载驱动模块的时候会执行驱动入口的函数，也就是helloworld 程序中的<code>helloworld_init</code> 函数， 所以可以看到打印出来的字符串信息“<code>helloworld_init</code>”。如下图（图4-10）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091555199.png" alt="image-20240809155548171"></p>
<p>如果要卸载helloworld 内核模块，可以通过“<code>rmmod helloworld</code>”命令来卸载驱动模块，同理在卸载驱动模块的时候会执行驱动出口的函数，所以可以看到驱动出口函数打印出来的字符串信息“<code>helloworld_exit</code>”，如下图（图4-11）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091556233.png" alt="image-20240809155617210"></p>
<p>加载驱动模块也可以使用<code>modprobe</code> 命令，它比<code>insmod</code> 命令更强大，<code>modprobe</code> 命令在加载驱动模块的时候，会同时加载该模块依赖的其他模块。比如<code>helloworld.ko</code> 依赖<code>before.ko</code>，使用<code>insmod</code> 加载的时候，就必须先加载<code>before.ko</code>，然后在加载<code>helloworld.ko</code> 才可以加载成功从。但是使用<code>modprobe</code> 加载的时候，他会自动分析模块的依赖关系，然后将所有的依赖的模块都加载到内核当中。比较“聪明”。</p>
<p>同样，在卸载驱动模块的时候，如果模块存在依赖关系，如果使用<code>insmod</code> 命令，需要手动卸载依赖的内核模块，但是使用<code>modprobe</code> 命令可以自动卸载驱动模块所依赖的其他模块。所以，如果驱动模块是以“m<code>odprobe helloworld.ko</code>”命令加载的，卸载的时候使用“<code>modprobe -r helloworld.ko</code>”命令卸载。</p>
<p>但是使用<code>modprobe</code> 卸载存在一个问题，如果所依赖的模块被其他模块所使用，比如刚才例子中的<code>before.ko</code> 还被其他的模块使用，这时候就不能使用<code>modprobe</code> 卸载。所以还是推荐使用<code>rmmod</code> 命令来卸载。</p>
<h3 id="4-5-查看模块信息"><a href="#4-5-查看模块信息" class="headerlink" title="4.5 查看模块信息"></a>4.5 查看模块信息</h3><p>在驱动模块加载之后，使用“<code>modinfo helloworld.ko</code>”命令可以获得模块的信息，包括模块作者，模块说明，模块支持的参数等等。<br><code>lsmod</code> 命令可以列出已经载入Linux 内核模块，在helloworld 驱动加载之后，查看内核中加载的模块，如下（图4-12）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091558358.png" alt="image-20240809155844334"></p>
<h2 id="第5-章-驱动模块传参实验"><a href="#第5-章-驱动模块传参实验" class="headerlink" title="第5 章 驱动模块传参实验"></a>第5 章 驱动模块传参实验</h2><p>经过前两章实验的实战操作，我们已经完成最简单的helloworld 驱动实验和模块驱动实验，加载模块可以使用“insmod”函数，使用“insmod”函数进行模块加载时也能进行参数的传递。运用得当可以极大提升内核测试速度。本节就来学习一下如何进行驱动模块的传参。</p>
<h3 id="5-1-驱动模块传参简介"><a href="#5-1-驱动模块传参简介" class="headerlink" title="5.1 驱动模块传参简介"></a>5.1 驱动模块传参简介</h3><p>驱动模块传参是一种可以随时向内核模块传递、修改参数的方法。例如可以传递串口驱动的波特率、数据位数、校验位、停止位等参数，进行功能的设置，以此节省编译模块的时间，大大提高调试速度。</p>
<p>Linux 内核提供了<code>module_param(name, type, perm)</code>、<code>module_param_array(name, type, nump, perm)</code>宏和<code>module_param_string(name, string, len, perm)</code>宏，分别进行基本类型、数组和字符串参数的传递。它们定义在“<code>内核源码/include/linux/moduleparam.h</code>”文件中(在<code>module.h</code> 文件中已经对<code>export.h</code> 进行引用，所以不需要单独引用<code>moduleparam.h</code> 文件),详细定义如下（图5-1）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">module_param</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">,</span> perm<span class="token punctuation">)</span> <span class="token function">module_param_named</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> name<span class="token punctuation">,</span> type<span class="token punctuation">,</span> perm<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">module_param_array</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">,</span> nump<span class="token punctuation">,</span> perm<span class="token punctuation">)</span> <span class="token function">module_param_array_named</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> name<span class="token punctuation">,</span> type<span class="token punctuation">,</span> nump<span class="token punctuation">,</span> perm<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">module_param_string</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> string<span class="token punctuation">,</span> len<span class="token punctuation">,</span> perm<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">kparam_string</span> __param_string_</span><span class="token punctuation">##</span><span class="token expression">name </span><span class="token punctuation">\</span>
    	<span class="token expression"><span class="token operator">=</span> <span class="token punctuation">{</span> len<span class="token punctuation">,</span> string <span class="token punctuation">}</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">__module_param_call</span><span class="token punctuation">(</span>MODULE_PARAM_PREFIX<span class="token punctuation">,</span> name<span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token operator">&amp;</span>param_ops_string<span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">.</span>str <span class="token operator">=</span> <span class="token operator">&amp;</span>__param_string_</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> perm<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">__MODULE_PARM_TYPE</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> </span><span class="token string">"string"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上宏定义中的<code>module_param ()</code>函数可以用来进行基本类型参数的传递，传入的三个参数定义如下：</p>
<ul>
<li>name：模块参数的名称</li>
<li>type： 模块参数的数据类型</li>
<li>perm： 模块参数的访问权限</li>
</ul>
<p>参数type 可以取以下任意一种情况：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token operator">:</span> 布尔型
inbool <span class="token operator">:</span> 布尔反值
charp<span class="token operator">:</span> 字符指针（相当于<span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span>不超过<span class="token number">1024</span> 字节的字符串）
<span class="token keyword">short</span><span class="token operator">:</span> 短整型
ushort <span class="token operator">:</span> 无符号短整型
<span class="token keyword">int</span> <span class="token operator">:</span> 整型
uint <span class="token operator">:</span> 无符号整型
<span class="token keyword">long</span> <span class="token operator">:</span> 长整型
ulong<span class="token operator">:</span> 无符号长整型。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>参数perm 表示该参数在sysfs 文件系统中所对应的文件节点的属性，其权限定义在“<code>内核源码/include/linux/stat.h</code>”文件中。可以用宏定义和数字法两种方式来表示。详细宏定义如下（图5-2）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">S_IRUSR</span> <span class="token expression"><span class="token number">00400</span> </span><span class="token comment">/*文件所有者可读*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">S_IWUSR</span> <span class="token expression"><span class="token number">00200</span> </span><span class="token comment">/*文件所有者可写*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">S_IXUSR</span> <span class="token expression"><span class="token number">00100</span> </span><span class="token comment">/*文件所有者可执行*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">S_IRGRP</span> <span class="token expression"><span class="token number">00040</span> </span><span class="token comment">/*与文件所有者同组的用户可读*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">S_IWGRP</span> <span class="token expression"><span class="token number">00020</span> </span><span class="token comment">/*与文件所有者同组的用户可写*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">S_IXGRP</span> <span class="token expression"><span class="token number">00010</span> </span><span class="token comment">/*与文件所有者同组的用户可执行*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">S_IROTH</span> <span class="token expression"><span class="token number">00004</span> </span><span class="token comment">/*与文件所有者不同组的用户可读*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">S_IWOTH</span> <span class="token expression"><span class="token number">00002</span> </span><span class="token comment">/*与文件所有者不同组的用户可写*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">S_IXOTH</span> <span class="token expression"><span class="token number">00001</span> </span><span class="token comment">/*与文件所有者不同组的用户可可执行*/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果要传递数组类型参数可以使用<code>module_param_array ()</code>函数，相较于<code>module_param ()</code>函数多了<code>n_para</code> 参数，用来表示传递参数个数;<code>n_para</code> 参数值会根据输入的参数个数而改变,<code>n_para</code>的最终值为传递的数组元素个数。</p>
<p>最后是<code>module_param_string(name, string, len, perm)</code>函数，用来传递字符串类型的变量，四个参数的定义如下所示：</p>
<ul>
<li>name：外部传入的参数名，即加载模块时的传入值</li>
<li>string:内部的变量名，即程序内定义的参数名</li>
<li>len:以string 命名的buffer 大小(可以小于buffer 的大小，但是没有意义)</li>
<li>perm:模块参数的访问权限</li>
</ul>
<p>至此，关于驱动模块传参所使用的函数就讲解完成了，在下一小节中将编写驱动模块传参函数代码。</p>
<h3 id="5-2-实验程序的编写"><a href="#5-2-实验程序的编写" class="headerlink" title="5.2 实验程序的编写"></a>5.2 实验程序的编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\02。</p>
<p>本章实验将编写Linux 下的驱动传参实例代码，通过“insmod”命令进行参数的传递，并将相应的参数打印到串口终端上。</p>
<p>编写完成的<code>parameter.c</code> 代码如下（图5-3）所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> number<span class="token punctuation">;</span>              <span class="token comment">//定义int 类型变量number</span>
<span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>              <span class="token comment">//定义char 类型变量name</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> para<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">//定义int 类型的数组</span>
<span class="token keyword">static</span> <span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">//定义char 类型字符串str1</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> n_para<span class="token punctuation">;</span>              <span class="token comment">//定义int 类型的用来记录module_param_array 函数传递数组元素个数的变量n_para</span>
<span class="token function">module_param</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> S_IRUGO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传递int 类型的参数number，S_IRUGO 表示权限为可读</span>
<span class="token function">module_param</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> charp<span class="token punctuation">,</span> S_IRUGO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传递char 类型变量name</span>
<span class="token function">module_param_array</span><span class="token punctuation">(</span>para <span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>n_para <span class="token punctuation">,</span> S_IRUGO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传递int 类型的数组变量para</span>
<span class="token function">module_param_string</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> str1 <span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">,</span> S_IRUGO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传递字符串类型的变量str1</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">parameter_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"%d\n"</span><span class="token punctuation">,</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"%s\n"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n_para<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"para[%d] : %d \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> para<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"%s\n"</span><span class="token punctuation">,</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">parameter_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"parameter_exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>parameter_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册入口函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>parameter_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册出口函数</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同意GPL 开源协议</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//作者信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上代码将传递int 类型参数number、char 类型参数name、int 类型的数组para 和char类型字符串str1，并在驱动入口函数中，对各个参数进行打印。在下一小节会进行驱动加载测试。</p>
<h3 id="5-3-运行测试"><a href="#5-3-运行测试" class="headerlink" title="5.3 运行测试"></a>5.3 运行测试</h3><h4 id="5-3-1-编译驱动程序"><a href="#5-3-1-编译驱动程序" class="headerlink" title="5.3.1 编译驱动程序"></a>5.3.1 编译驱动程序</h4><p>在上一小节中的parameter.c 代码同一目录下创建Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">warning</span> KERNELRELEASE<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>KERNELRELEASE<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>KERNELRELEASE<span class="token punctuation">)</span>,<span class="token punctuation">)</span>

KERNELDIR <span class="token operator">?=</span> /lib/modules/<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> uname -r<span class="token punctuation">)</span>/build
PWD <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>

<span class="token target symbol">modules</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>KERNELDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> modules
	rm -rfv *.o *~ core .depend .*.cmd *.mod.c *.mod .tmp_versions Module* modules*

<span class="token target symbol">modules_install</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>KERNELDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> modules_install

<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	rm -rfv *.o *~ core .depend .*.cmd *.ko *.mod.c *.mod .tmp_versions Module* modules*

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> modules modules_install clean

<span class="token keyword">else</span>
	obj-m<span class="token operator">:=</span>parameter.o

<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于Makefile 的内容注释已在上图添加，保存退出之后，来到存放parameter.c 和Makefile 文件目录下，然后使用命令“<code>make</code>”进行驱动的编译，编译完生成parameter.ko 目标文件，至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h4 id="5-3-2-运行测试"><a href="#5-3-2-运行测试" class="headerlink" title="5.3.2 运行测试"></a>5.3.2 运行测试</h4><p>在上一章节中已经学习了使用insmod 命令加载模块，而驱动模块传参的命令格式为</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod 对应的模块参数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>parameter.ko 驱动加载可以传递3 个参数，分别为int 类型的参数number，char 类型的参数name 和int 数组类型的参数para。使用以下命令进行驱动的加载，加载完成之后的打印信息如下图（图5-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod parameter.ko <span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token number">100</span> <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"topeet"</span> <span class="token assign-left variable">para</span><span class="token operator">=</span><span class="token number">0,1</span>,2,3,4,5,6,7 <span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">"itop"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091617312.png" alt="image-20240809161725269"></p>
<p>可以看到传递的参数都分别打印了出来。最后可以输入以下命令进行驱动的卸载，如下图（图5-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod parameter.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091618079.png" alt="image-20240809161814051"></p>
<h2 id="第6-章内核模块符号导出实验"><a href="#第6-章内核模块符号导出实验" class="headerlink" title="第6 章内核模块符号导出实验"></a>第6 章内核模块符号导出实验</h2><p>在上一小节中，给大家讲解了驱动模块传参实验，使用insmod 命令加载驱动时可以进行参数的传递，但是每一个内核模块之间是相互独立的，那模块间的符号传递要怎样进行呢，让我们带着疑问来进行本章节的学习吧！</p>
<h3 id="6-1-内核模块符号导出简介"><a href="#6-1-内核模块符号导出简介" class="headerlink" title="6.1 内核模块符号导出简介"></a>6.1 内核模块符号导出简介</h3><p>驱动程序编译生成的ko 文件是相互独立的，即模块之间变量或者函数在正常情况下无法进行互相访问。而一些复杂的驱动模块需要分层进行设计，这时候就需要用到内核模块符号导出。</p>
<p><strong>内核符号导出指的是在内核模块中导出相应的函数和变量，在加载模块时被记录在公共内核符号表中，以供其他模块调用</strong>。符号导出所使用的宏为<code>EXPORT_SYMBOL(sym)</code>和<code>EXPORT_SYMBOL_GPL(sym)</code>。它们定义在“<code>内核源码/include/linux/export.h</code>”文件中（在<code>module.h</code> 文件中已经对<code>export.h</code> 进行引用，所以不需要单独引用<code>export.h</code> 文件）,详细定义如下（图6-1）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">EXPORT_SYMBOL</span><span class="token expression"><span class="token punctuation">(</span>sym<span class="token punctuation">)</span> <span class="token function">__EXPORT_SYMBOL</span><span class="token punctuation">(</span>sym<span class="token punctuation">,</span> </span><span class="token string">""</span><span class="token expression"><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">EXPORT_SYMBOL_GPL</span><span class="token expression"><span class="token punctuation">(</span>sym<span class="token punctuation">)</span> <span class="token function">__EXPORT_SYMBOL</span><span class="token punctuation">(</span>sym<span class="token punctuation">,</span> </span><span class="token string">"_gpl"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>EXPORT_SYMBOL(sym)</code>和<code>EXPORT_SYMBOL_GPL(sym)</code>两个宏使用方法相同，而<code>EXPORT_SYMBOL_GPL(sym)</code>导出的模块只能被GPL 许可的模块使用，所以绝大多数的情况都使用<code>EXPORT_SYMBOL(sym)</code>进行符号导出。<code>sym</code> 为函数的唯一参数，表示要导出的函数或变量名称。</p>
<p>至此，关于内核模块符号导出函数就讲解完成了，在下一小节中将会编写两个驱动代码来进行内核模块符号导出实验。</p>
<h3 id="6-2-实验程序的编写"><a href="#6-2-实验程序的编写" class="headerlink" title="6.2 实验程序的编写"></a>6.2 实验程序的编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\03。</p>
<p>本章实验将编写Linux 下的内核模块符号导出实例代码，总共有两个驱动程序，第一个驱动文件名为<code>mathmodule.c</code>，用来定义参数num 和函数add(a,b)，第二个驱动文件名为hello.c,会引用<code>mathmodule.c</code> 驱动程序中的参数num 和数学函数add(a,b)，并将相应的参数值和函数返回值打印到串口终端上。</p>
<p>编写完成的<code>mathmodule.c</code> 代码如下（图6-2）所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//定义参数num</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//导出参数num</span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token comment">//定义数学函数add()，用来实现加法</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//导出数学函数add()</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">math_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"math_moudle init\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">math_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"math_module exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>math_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册入口函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>math_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册出口函数</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同意GPL开源协议</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//作者信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上代码定义了一个int 类型的num 变量和add()数学函数，并使用EXPORT_SYMBOL 宏进行导出。<br>编写完成的hello.c 代码如下（图6-3）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token comment">//导入int类型变量num</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//导入函数add</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> sum<span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"num = %d\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印num值</span>
    sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用add函数进行3+4的运算                                                                                                                                                               </span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印add函数的运算值</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"Goodbye hello module\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册入口函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册出口函数</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同意GPL开源协议</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//作者信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序导入了int 类型的变量num 和add()函数，并在驱动入口函数中打印相应了num 的参数值并对add()函数进行了调用。</p>
<p>至此两个驱动代码就编写完成了，代码较为简单，实现了内核模块符号的导出和导出符号的使用，具体的驱动加载运行测试会在下个小节进行。</p>
<h3 id="6-3-运行测试"><a href="#6-3-运行测试" class="headerlink" title="6.3 运行测试"></a>6.3 运行测试</h3><h4 id="6-3-1-编译驱动程序"><a href="#6-3-1-编译驱动程序" class="headerlink" title="6.3.1 编译驱动程序"></a>6.3.1 编译驱动程序</h4><p>在mathmodule.c 和hello.c 的同一目录下创建Makefile 文件，Makefile 文件内容如下（图6-4）所示：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">export</span> ARCH<span class="token operator">=</span>arm64<span class="token comment">#设置平台架构</span>
<span class="token keyword">export</span> CROSS_COMPILE<span class="token operator">=</span>aarch64-linux-gnu-<span class="token comment">#交叉编译器前缀</span>
obj-m <span class="token operator">:=</span> mathmodule.o
obj-m <span class="token operator">+=</span> hello.o
KDIR <span class="token operator">:=</span>/home/topeet/Linux/linux_sdk/kernel    <span class="token comment">#这里是你的内核目录                                                                                                                            </span>
PWD <span class="token operator">?=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>
<span class="token target symbol">all</span><span class="token punctuation">:</span>
	make -C <span class="token variable">$</span><span class="token punctuation">(</span>KDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> modules    <span class="token comment">#make操作</span>
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	make -C <span class="token variable">$</span><span class="token punctuation">(</span>KDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> clean    <span class="token comment">#make clean操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于Makefile 的内容注释已在上图进行添加，这里要注意的是在hello.c 代码中使用了mathmodule.c 所导出的符号，所以mathmodule.c 要在hello.c 之前进行编译，即第3 行和第4行顺序不能交换。保存退出之后，来到相应的文件目录下</p>
<p>(没有开发板的用这个验证)</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Makefile</span>
<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">warning</span> KERNELRELEASE<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>KERNELRELEASE<span class="token punctuation">)</span><span class="token punctuation">)</span>	

<span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>KERNELRELEASE<span class="token punctuation">)</span>,<span class="token punctuation">)</span>	<span class="token comment"># 判断条件，如果KERNELRELEASE为空，则执行以下代码块</span>

KERNELDIR <span class="token operator">?=</span> /lib/modules/<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> uname -r<span class="token punctuation">)</span>/build
PWD <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>

<span class="token target symbol">modules</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>KERNELDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> modules
	rm -rfv *.o *~ core .depend .*.cmd *.mod.c *.mod .tmp_versions Module* modules*

<span class="token target symbol">modules_install</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>KERNELDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> modules_install

<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	rm -rfv *.o *~ core .depend .*.cmd *.ko *.mod.c *.mod .tmp_versions Module* modules*

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> modules modules_install clean

<span class="token keyword">else</span>
	obj-m<span class="token operator">:=</span>mathmodule.o
	obj-m<span class="token operator">+=</span>hello.o				<span class="token comment"># 这个一定是+= ，不能写成:=</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后使用命令“<code>make</code>”进行驱动的编译，：编译完后会生成hello.ko 和mathmodule.ko 目标文件，至此我们的驱动模块就编译成功了，下面进行驱动的加载运行测试。</p>
<h4 id="6-3-2-运行测试"><a href="#6-3-2-运行测试" class="headerlink" title="6.3.2 运行测试"></a>6.3.2 运行测试</h4><p>这里要注意的是，由于<code>hello.ko</code> 依赖于<code>mathmodule.ko</code>，所以<code>mathmodule.ko</code> 需要先加载，分别使用以下命令进行模块的加载（加载顺序不能变），如下（图6-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod mathmodule.ko
insmod hello.ko<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091632201.png" alt="image-20240809163215167"></p>
<p>可以看到<code>hello.ko</code> 驱动加载的时候，<code>mathmodule.ko</code> 模块中定义的<code>num</code> 参数值和调用<code>sum()</code>函数的后正确的返回值都被打印了出来。至此内核模块符号导出实验就完成了。</p>
<p>最后可以输入以下命令进行驱动的卸载，如下图（图6-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod hello.ko
rmmod mathmodule.ko<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408091633841.png" alt="image-20240809163326808"></p>
<p>注意：由于<code>hello.ko</code> 文件使用了<code>mathmodule.ko</code> 导出的符号，所以要先卸载<code>hello.ko</code>，卸载完成之后再卸载<code>mathmodule.ko</code>。</p>
<h1 id="第二篇-字符设备基础"><a href="#第二篇-字符设备基础" class="headerlink" title="第二篇 字符设备基础"></a>第二篇 字符设备基础</h1><h2 id="第7-章-menuconfig-图形化配置实验"><a href="#第7-章-menuconfig-图形化配置实验" class="headerlink" title="第7 章 menuconfig 图形化配置实验"></a>第7 章 menuconfig 图形化配置实验</h2><p>Linux 内核可以通过输入“make menuconfig”来打开图形化配置界面，menuconfig 是一套图形化的配置工具，本章节来学习使用menuconfig 配置内核。</p>
<h3 id="7-1-图形化界面的操作"><a href="#7-1-图形化界面的操作" class="headerlink" title="7.1 图形化界面的操作"></a>7.1 图形化界面的操作</h3><p>menuconfig 图形化的配置工具需要ncurses 库支持。ncurses 库提供了一系列的API 函数供调用者生成基于文本的图形界面，因此在使用menuconfig 图形化配置界面之前需要先在Ubuntu 中安装ncurses 库，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> build-essential
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libncurses5-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>图形化配置界面主要有以下四种，在这四种方式中，最推荐的是make menuconfig，它不依赖于QT 或GTK+，且非常直观。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> config 		<span class="token comment">#（基于文本的最为传统的配置界面，不推荐使用）</span>
<span class="token function">make</span> menuconfig 	<span class="token comment">#（基于文本菜单的配置界面）</span>
<span class="token function">make</span> xconfig 		<span class="token comment">#（要求QT 被安装）</span>
<span class="token function">make</span> gconfig 		<span class="token comment">#（要求GTK+ 被安装）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如何打开menuconfig 图形化配置界面呢？<br>以RK3568 为例，在内核源码目录下输入以下命令，打开图形化配置界面。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm64
<span class="token function">make</span> rockchip_linux_defconfig
<span class="token function">make</span> menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120922670.png" alt="image-20240812092209563"></p>
<p>打开后界面如下所（图7-2）示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120922180.png" alt="image-20240812092234128"></p>
<p>打开menuconfig 图形化配置界面以后，可以使用以下方式进行操作，如下表（表7-3）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120923254.png" alt="image-20240812092350198"></p>
<h3 id="7-2-Kconfig-语法简介"><a href="#7-2-Kconfig-语法简介" class="headerlink" title="7.2 Kconfig 语法简介"></a>7.2 Kconfig 语法简介</h3><p>上一小节我们打开的图形化配置界面是如何生成的呢？图形化配置界面中的每一个界面都会对应一个Kconfig 文件。所以图形化配置界面的每一级菜单是由Kconfig 文件来决定的。<br>图形化配置界面有很多菜单。所以就会有很多Kconfig 文件，这也就是为什么我们会在内核源码的每个子目录下，都会看到Kconfig 文件的原因，那掌握Kconfig 文件相关的知识是不是就非常重要呢。<br>所以这一小节我们来看下如何编写Kconfig 文件来生成图形化配置界面，也就是Kconfig 文件的语法是什么。</p>
<ol>
<li>Mainmenu</li>
</ol>
<p>mainmenu 顾名思义就是主菜单，也就是我们输入完“make menuconfig”以后默认打开的界面，mainmenu 用来设置主菜单的标题，如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mainmenu <span class="token string">"Linux/<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>KERNELVERSION<span class="token variable">)</span></span> Kernel Configuration"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此行代码是设置菜单的名字为“Linux/$(ARCH) $(KERNELVERSION) Kernel Configuration”。如下图（图7-4）所示，ARCH 变量是通过“export ARCH=arm64”设置的，内核版本KERNELVERSION为4.19.232。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120925303.png" alt="image-20240812092504252"></p>
<p>2.source</p>
<p>source 用于读取另一个Kconfig 文件，比如“source “init/Kconfig””就是读取init 目录下的Kconfig 文件。</p>
<p>3.menu/endmenu</p>
<p>menu/endmenu 条目用于生成菜单，如下（图7-5）所示，生成了Watchdog Timer Support的菜单。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menu <span class="token string">"Watchdog Timer Support"</span>

config HW_WATCHDOG
bool

config WDT
bool <span class="token string">"Enable driver model for watchdog timer drivers"</span>
depends on DM
<span class="token builtin class-name">help</span>
	Enable driver model <span class="token keyword">for</span> watchdog timer. At the moment the API.
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
endmenu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>menu 之后的字符串是菜单名，“menu”是菜单开始的标志，“endmenu”是菜单结束的标志，这俩个是成对出现的。“menu”和“endmenu”之间有很多config 条目。在kernel 目录下输入make menuconfig，如下图（图7-6）所示，可以看到上述代码描述的”Watchdog Timer Support”菜单。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120927303.png" alt="image-20240812092707251"></p>
<p>进入“ Watchdog Timer Support —&gt; ”可以看到很多config 定义的条目，如下（图7-7）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120927731.png" alt="image-20240812092717679"></p>
<p>4.if/endif<br>if/endif 语句是一个条件判断，定义了一个if 结构，Kconfig 中代码如下（图7-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menu <span class="token string">"Hardware Drivers Config"</span>
    menuconfig BSP_USING_CAN
        bool <span class="token string">"Enable CAN"</span>
        default n
        <span class="token keyword">select</span> RT_USING_CAN
            <span class="token keyword">if</span> BSP_USING_CAN
            config BSP_USING_CAN1
            bool <span class="token string">"Enable CAN1"</span>
            default n
            endif
endmenu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当没有选中”Enable CAN” 选项时，下面通过if 判断的Enable CAN1 选项并不会显示出来。当上一级菜单选中”Enable CAN” 时，Enable CAN1 选项才会显示。</p>
<p>5.choice/endchooice</p>
<p>choice 条目将多个类似的配置选项组合到一起，供用户选择，用户选择是从“choice”开始，从“endchoice”结束，“choice”和“endchoice”之间有很多的config 条目，这些config 条目是提供用户选择的，如下（图7-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">choice
    bool <span class="token string">"Parade TrueTouch Gen5 MultiTouch Protocol"</span>
    depends on TOUCHSCREEN_CYPRESS_CYTTSP5
    default TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B
    <span class="token builtin class-name">help</span>
        This option controls <span class="token function">which</span> MultiTouch protocol will be used to
        report the <span class="token function">touch</span> events.
config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_A
    bool <span class="token string">"Protocol A"</span>
    <span class="token builtin class-name">help</span>
        Select to <span class="token builtin class-name">enable</span> MultiTouch <span class="token function">touch</span> reporting using protocol A
        on Parade TrueTouch<span class="token punctuation">(</span>tm<span class="token punctuation">)</span> Standard Product Generation4 touchscreen
        controller.
        
config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B
    bool <span class="token string">"Protocol B"</span>
    <span class="token builtin class-name">help</span>
        Select to <span class="token builtin class-name">enable</span> MultiTouch <span class="token function">touch</span> reporting using protocol B
        on Parade TrueTouch<span class="token punctuation">(</span>tm<span class="token punctuation">)</span> Standard Product Generation4 touchscreen
        controller.
endchoice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们在内核目录下输入make menuconfig 可以看到，如下（图7-10）所示，“Parade TrueTouch Gen5 MultiTouch Protocol”是choice 选项名称，“Protocol B”是Kconfig 里面默认选择的。“–&gt;”代表此菜单能进入，需要键盘操作进入。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120929713.png" alt="image-20240812092955653"></p>
<p>进入“Parade TrueTouch Gen5 MultiTouch Protocol”后，可以看到多选项提供给用户进行选择，如下（图7-11）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120930152.png" alt="image-20240812093006104"></p>
<p>6.comment<br>comment 语句出现在界面的第一行，用于定义一些提示信息。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">comment <span class="token string">"Compiler: <span class="token variable"><span class="token variable">$(</span>CC_VERSION_TEXT<span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>以上代码的配置界面如下（图7-12）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120930309.png" alt="image-20240812093031255"></p>
<p>7.config<br>使用关键字config 来定义一个新的选项，如下（图7-13）所示</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">config helloworld
bool “hello world support”
default y
<span class="token builtin class-name">help</span>
hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如上所示，使用config 关键字定义了一个“helloworld”选项，每个选项都必须指定类型，类型包括bool，tristate,string,hex,int。最常见的是bool,tristate,string 这三个。</p>
<ul>
<li>bool 类型取值只有“y”和“n”</li>
<li>tristate 类型的变量取值有3 种：“y”,“n”,“m”</li>
<li>string 类型取值为字符串</li>
<li>hex 类型取值为十六进制的数据</li>
<li>int 类型取值为十进制的数据</li>
<li>help 表示帮助信息，当我们在图形化界面按下h 按键，弹出来的就是help 的内容。</li>
</ul>
<p>8.depends on<br>Kconfig 中depends on 关键字用来指定依赖关系，当依赖的选项被选中时，当前的配置选项的信息才会在菜单中显示出来，才能操作该选项的内容。举例来说，如下所示，选项A 依赖选项B，只有当选项B 被选中时，选项A 才可以被选中。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">config A
depends on B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>9.select<br>Kconfig 中select 关键字用来表示反向依赖关系，当指定当前选项被选中时，此时select 后面的选项也会被自动选中。举个例子来说，如下所示，在选项A 被选中的情况下，选项B 自动被选中。</p>
<pre class="line-numbers language-none"><code class="language-none">config A
select on B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>10.menuconfig<br>menuconfig 可以认为是config 中的升级版。menuconfig 也是一个正常的配置项，通过自己的配置值来决定另外一组配置项是否作为子菜单的形式显示出来并供用户配置。代码如下（图7-14）所示。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menuconfig NETDEVICES
default y <span class="token keyword">if</span> UML
depends on NET
bool <span class="token string">"Network device support"</span>
---help---
    <span class="token keyword">if</span> NETDEVICES
    config MII
    tristate
    config NET_CORE
    default y
bool <span class="token string">"Network core driver support"</span>
---help---
    You can say N here <span class="token keyword">if</span> you <span class="token keyword">do</span> not intend to use any of the
    networking core drivers <span class="token punctuation">(</span>i.e. VLAN, bridging, bonding, etc.<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上代码中通过menuconfig 配置了一个bool 类型的配置项，在图形化配置界面中显示（图7-15）如下：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120934798.png" alt="image-20240812093405740"></p>
<p>当我们选中”Network device support”配置项时，其子菜单被显示出来，如下图（图7-16）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120934012.png" alt="image-20240812093415956"></p>
<h3 id="7-3-config-配置文件介绍"><a href="#7-3-config-配置文件介绍" class="headerlink" title="7.3 .config 配置文件介绍"></a>7.3 .config 配置文件介绍</h3><p>我们在图形化配置界面配置好了以后，会得到一个.config 配置文件。在编译内核的时候会根据这个.config 文件来编译内核。这样是不是就实现了通过图像化界面的配置来配置内核呀。用通俗的话来说，Kconfig 就是饭店的菜单，.config 就是客人点完的菜。然后厨师会根据客人点的菜，也就是.config 来做菜，对应的操作就是编译内核。<br>那.config 是如何产生的呢？对应上面的例子就是要有服务员给我们点菜呀。<br>当我们使用make menuconfig 的时候，会通过mconf 程序去解析Kconfig 文件，然后生成对应的配置文件.config。所以这个mconf 就是服务员。<br>mconf 程序源码在内核源码scripts/kconfig 目录下，如下图所示，这里不对Kconfig 文件的解析流程进行分析，感兴趣的同学可以自行分析下mconf 的源码。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120935411.png" alt="image-20240812093511361"></p>
<p>有了.config 配置文件以后，内核就可以根据这个配置文件来编译内核，比如控制某些驱动编译进内核，或者控制某些驱动不编译内核。那他是怎么实现的呢？<br>.config 会通过syncconfig 目标将.config 作为输入然后输出需要文件，这里我们重点更关注auto.conf 和autoconf.h。如下图（图7-19）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120935344.png" alt="image-20240812093530292"></p>
<p>在auto.conf 文件中，存放的是配置信息。如下图（图7-20）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120935891.png" alt="image-20240812093543848"></p>
<p>在内核源码的顶层Makefile 中会包含auto.conf 文件，以此引用其中的变量来控制Makefile的动作，如哪些驱动编译，哪些驱动不编译。如：</p>
<p>auto.conf 文件中</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">include include/config/auto.conf
CONFIG <span class="token assign-left variable">_A</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>顶层Makefile 中包含auto.conf 文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ifeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>dot-config<span class="token variable">)</span></span>,1<span class="token punctuation">)</span>
include include/config/auto.conf
Endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>内核源码下drivers/A/Makefile 引用这个变量</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">obj-<span class="token variable"><span class="token variable">$(</span>CONFIG _A<span class="token variable">)</span></span> <span class="token operator">+=</span>A.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注：<code>obj-y</code> 就是编译进内核，<code>obj-m</code> 就是编译成<code>ko</code> 文件。<br>在autoconf.h 中，是C 语言代码。用来配合编译时的条件选择。如下图（图7-21）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120936877.png" alt="image-20240812093655830"></p>
<h3 id="7-4-defconfig-配置文件"><a href="#7-4-defconfig-配置文件" class="headerlink" title="7.4 defconfig 配置文件"></a>7.4 defconfig 配置文件</h3><p>defconfig 文件和.config 文件都是linux 内核的配置文件，defconfig 文件在内核源码的arch/$(ARCH)/configs 目录下，是Linux 系统默认的配置文件。比如说瑞芯微平台Linux 源码默认的配置文件为：<code>kernel/arch/arm64/configs/rockchip_linux_defconfig</code>。</p>
<p>.config 文件位于Linux 内核源码的顶层目录下，编译Linux 内核时会使用.config 文件里面的配置来编译内核镜像。<br>如果.config 文件存在，make menuconfig 界面的默认配置也就是当前.config 文件的配置，如果修改了图形化配置界面的设置并保存，那么.config 文件会被更新。</p>
<p>如果.config 文件不存在，使用命令“make XXX_defconfig”命令会根据arch/$(ARCH)/configs目录下的XXX_defconfig 自动生成.config。make menuconfig 界面的默认配置则为defconfig 文件中的默认配置，比如说瑞芯微平台Linux 内核源码目录下输入“make rockchip_linux_defconfig”会自动生成.config 文件。那么此时rockchip_linux_defconfig 的配置项和.config 的配置项是相同的。</p>
<h3 id="7-5-自定义菜单实验"><a href="#7-5-自定义菜单实验" class="headerlink" title="7.5 自定义菜单实验"></a>7.5 自定义菜单实验</h3><p>有了上面的理论基础后，我们就可以自己在图形化配置界面中来自定义一个菜单，要定义一个菜单，根据我们前面的分析，是不是就要从Kconfig 文件入手呀。因为图形化配置界面是根据Kconfig 文件来生成的！<br>1 在kernel 目录下创建一个topeet 的文件夹，如下（图7-22）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120938731.png" alt="image-20240812093832690"></p>
<p>2 打开kernel 下的Kconfig 文件，在里面加入以下代码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> <span class="token string">"topeet/Kconfig"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>添加完成后如下（图7-23）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120938222.png" alt="image-20240812093852174"></p>
<p>3 然后进入到topeet 文件夹，在此文件夹下创建一个Kconfig 文件，创建完成如下（图7-24）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120939021.png" alt="image-20240812093904979"></p>
<p>4 打开创建好的Kconfig 文件，写入以下（图7-25）内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menu <span class="token string">"test menu"</span>
    config TEST_CONFIG
    bool <span class="token string">"test"</span>
    default y
    <span class="token builtin class-name">help</span>
        just <span class="token builtin class-name">test</span>
        comment <span class="token string">"just test"</span>
endmenu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的代码中，我们在主菜单中添加了一个名为test menu 的子菜单，然后在这个子菜单里面我们添加了一个名为TEST_CONFIG 的配置项，这个配置项变量类型为bool，默认配置为Y，帮助信息为just test，注释为just test。添加完成如下图（图7-26）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120939156.png" alt="image-20240812093947114"></p>
<p>5 添加完成以后，打开图形化配置界面，如下图（图7-27）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120940663.png" alt="image-20240812094012606"></p>
<p>6 子菜单中的配置项，默认为y，注释信息为just test。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120940647.png" alt="image-20240812094023596"></p>
<p>7 在此界面输入？，显示帮助信息为just test，如下（图7-29）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120940526.png" alt="image-20240812094035478"></p>
<p>8 保存退出后，打开内核源码目录下的.config 文件，如下图（图7-30）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120940321.png" alt="image-20240812094048281"></p>
<p>9 可以在这个.config 文件中找到添加的TEST_CONFIG （ 注意， 我们需要在make menuconfig 中保存才可以看到，否则是看不到我们添加的这个选项的），这样在编译内核的时候就可以根据这个配置信息来执行对应的操作了，就是我们下一章节要给大家讲的把驱动编译进内核，如下图所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120941507.png" alt="image-20240812094104457"></p>
<h2 id="第8-章驱动模块编译进内核实验"><a href="#第8-章驱动模块编译进内核实验" class="headerlink" title="第8 章驱动模块编译进内核实验"></a>第8 章驱动模块编译进内核实验</h2><p>通过上一章的学习，我们学会了使用menuconfig 图形化配置工具，以及了解了menuconfig相关的文件：Kconfig .config XXXdefconfig。本章节学习将helloworld 驱动编译进内核。</p>
<p>输入“<code>cd drivers/char</code>”进入到<code>drivers/char</code> 目录下，然后输入“<code>mkdir hello</code>”建立hello文件夹，并输入“<code>cd hello</code>”进入hello 文件夹，如下（图8-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120941549.png" alt="image-20240812094139507"></p>
<p>然后将第三章编写的hello.c 文件拷贝到hello 文件夹内。如下（图8-2）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120941958.png" alt="image-20240812094149918"></p>
<p>输入“touch Kconfig”命令创建Kconfig 文件，Kconfig 文件内容如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">config HELLO
tristate <span class="token string">"hello world"</span>
<span class="token builtin class-name">help</span>
hello hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后“touch Makefile”命令创建Makefile 文件,Makefile 文件内容如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">obj-<span class="token variable"><span class="token variable">$(</span>CONFIG_HELLO<span class="token variable">)</span></span><span class="token operator">+=</span>helloworld.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>接下来修改上一级目录的Kconfig 文件和Makefile 文件，也就是driver/char 目录。Makefile添加如下图(图8-3)所示内容。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">obj-y <span class="token operator">+=</span> hello/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120942008.png" alt="image-20240812094240968"></p>
<p>Kconfig 添加如下图（图8-4）所示内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> <span class="token string">"drivers/char/hello/Kconfig"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120943908.png" alt="image-20240812094306868"></p>
<p>最后打开menuconfig 图形化配置工具，在配置界面选择helloworld 驱动。把驱动编译进Linux 内核，用* 来表示，所以配置选项改为*。如果想要将驱动编译为模块，则用M 来表示，配置选项改为M。这里我们选择成*</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Device Drivers ─<span class="token operator">&gt;</span>
    Character devices ---<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> hello world 或者<span class="token operator">&lt;</span>M<span class="token operator">&gt;</span> hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120944907.png" alt="image-20240812094409843"></p>
<p>然后将光标移动到save，保存配置，如下图（图8-6）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120944011.png" alt="image-20240812094419951"></p>
<p>保存到.config 文件，如下（图8-7）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120944428.png" alt="image-20240812094430377"></p>
<p>退出配置界面，然后输入以下命令便可以编译源码了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> savedefconfig
<span class="token function">cp</span> defconfig arch/arm64/configs/rockchip_linux_defconfig
<span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>/
./build.sh kernel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408120944554.png" alt="image-20240812094451505"></p>
<p> 编译成功之后，进入到drivers/char/hello 目录下，可以看到会生成对应的.o 文件。就说明已经成功将驱动编译进内核。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408121030134.png" alt="image-20240812103050086"></p>
<p>将编译好的内核镜像烧写到开发板上后，在开发板系统启动的时候也可以成功看到加载helloworld 驱动，如下图（图8-10）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408121031663.png" alt="image-20240812103105611"></p>
<p>如果在图形化配置界面中选择的M，也就是编译成驱动模块，则生成helloworld.ko 文件如下图（图8-11）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408121031627.png" alt="image-20240812103118578"></p>
<h2 id="第9-章申请字符设备号实验"><a href="#第9-章申请字符设备号实验" class="headerlink" title="第9 章申请字符设备号实验"></a>第9 章申请字符设备号实验</h2><p>经过前面章节的学习，相信大家已经对驱动模块的基本框架、驱动模块传参等知识有了自己的认识，本章节开始就要进入字符设备的世界了。字符设备是指在I/O 传输过程中以字符为单位进行传输的设备，可以使用与普通文件相同的文件操作命令（打开、关闭、读、写等）对字符设备进行操作，是Linux 驱动中最基本的一类设备驱动，例如最常见的LED、按键、IIC、SPI，LCD 等都属于字符设备的范畴。要想对字符设备进行操作，需要通过设备号来对相应的设备进行查找，在本章节将对设备号相关知识进行讲解。</p>
<h3 id="9-1-申请驱动设备号"><a href="#9-1-申请驱动设备号" class="headerlink" title="9.1 申请驱动设备号"></a>9.1 申请驱动设备号</h3><h4 id="9-1-1-设备号申请"><a href="#9-1-1-设备号申请" class="headerlink" title="9.1.1 设备号申请"></a>9.1.1 设备号申请</h4><p>在Linux 系统中每一个设备都有相应的设备号，通过该设备号查找对应的设备，从而进行之后的文件操作。设备号有主设备号与次设备号之分，主设备号用来表示一个特定的驱动，次设备号用来管理下面的设备。</p>
<p>在Linux 驱动中可以使用以下两种方法进行设备号的申请：<br>1.通过<code>register_chrdev_region(dev_t from, unsigned count, const char *name)</code>函数进行静态申请设备号。</p>
<p>2.通过<code>alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char* name)</code>函数进行动态申请设备号。<br>两个函数在“内核源码/include/linux/fs.h”文件中引用(在编写驱动程序的时候要加入该文件的引用)，如下（图9-1）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token class-name">dev_t</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">register_chrdev_region</span><span class="token punctuation">(</span><span class="token class-name">dev_t</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>静态申请设备号：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token function">register_chrdev_region</span><span class="token punctuation">(</span><span class="token class-name">dev_t</span> from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> count<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span>
函数作用：
    静态申请设备号，对指定好的设备号进行申请。
参数含义：
    from<span class="token operator">:</span> 自定义的<span class="token class-name">dev_t</span> 类型设备号
    count<span class="token operator">:</span> 申请设备的数量
    name<span class="token operator">:</span> 申请的设备名称
函数返回值：申请成功返回<span class="token number">0</span>，申请失败返回负数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>动态申请设备号：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token class-name">dev_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> baseminor<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> count<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span>
函数作用：
    动态申请设备号，内核会自动分配一个未使用的设备号，相较于静态申请设备号，动态申请会避免注册设备号相同引发冲突的问题。
参数含义：
    dev <span class="token operator">*</span><span class="token operator">:</span> 会将申请完成的设备号保存在dev 变量中
    baseminor<span class="token operator">:</span> 次设备号可申请的最小值
    count<span class="token operator">:</span> 申请设备的数量
    name<span class="token operator">:</span> 申请的设备名称
函数返回值：申请成功返回<span class="token number">0</span>，申请失败返回负数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于申请设备号所用到的函数就讲解完成了，会在之后的测试小节对两个函数进行实际运用。</p>
<h4 id="9-1-2-设备号类型"><a href="#9-1-2-设备号类型" class="headerlink" title="9.1.2 设备号类型"></a>9.1.2 设备号类型</h4><p>申请的设备号类型为dev_t ，在“内核源码/include/linux/types.h” 文件中定义如下（图9-2）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> u32 __kernel_dev_t<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">typedef</span> __kernel_dev_t <span class="token class-name">dev_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>dev_t 为u32 类型，而u32 定义在文件“内核源码<code>/include/uapi/asm-generic/int-ll64.h</code>”文件中，定义如下（图9-3）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __u32<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>__u32</code> 为<code>unsigned int</code> 类型，所以dev_t 是一个无符号的32 位整形类型。其中高12 位表示主设备号，低20 位表示次设备号。在“内核源码/include/linux/kdev_t.h”中提供了设备号相关的宏定义，如下（图9-4）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MINORBITS</span> <span class="token expression"><span class="token number">20</span> </span><span class="token comment">/*次设备号位数*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MINORMASK</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1U</span> <span class="token operator">&lt;&lt;</span> MINORBITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> </span><span class="token comment">/*次设备号掩码*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAJOR</span><span class="token expression"><span class="token punctuation">(</span>dev<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> MINORBITS<span class="token punctuation">)</span><span class="token punctuation">)</span></span><span class="token comment">/*dev 右移20 位得到主设备号*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MINOR</span><span class="token expression"><span class="token punctuation">(</span>dev<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span> <span class="token operator">&amp;</span> MINORMASK<span class="token punctuation">)</span><span class="token punctuation">)</span> </span><span class="token comment">/*与次设备掩码与，得到次设备号*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MKDEV</span><span class="token expression"><span class="token punctuation">(</span>ma<span class="token punctuation">,</span>mi<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ma<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> MINORBITS<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>mi<span class="token punctuation">)</span><span class="token punctuation">)</span></span><span class="token comment">/*MKDEV 宏将主设备号（ma）左移20 位，然后与次设备号（mi）相与，得到设备号*/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在稍后的实验中不论是静态申请设备号还是动态申请设备号都会用到上述宏，例如在静态申请设备号时需要将指定的主设备号和从设备号通过MKDEV(ma,mi)宏进行设备号的转换，在动态申请设备号时可以用MAJOR(dev) 和MINOR(dev)宏将动态申请的设备号转化为主设备号和从设备号。<br>至此，关于设备号相关的知识就结束了，在下一小节中将对申请设备号实验代码进行编写。</p>
<h3 id="9-2-实验程序的编写"><a href="#9-2-实验程序的编写" class="headerlink" title="9.2 实验程序的编写"></a>9.2 实验程序的编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\04。<br>本章节实验将编写Linux 下申请字符设备号实例代码，如果在进行驱动模块加载时传入了major 主设备号，则通过静态的方式进行设备号的申请，如果不传入任何参数进行驱动模块加载，则通过动态的方式进行设备号申请。<br>编写完成的dev_t.c 代码如下（图9-5）所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token keyword">int</span> major<span class="token punctuation">;</span><span class="token comment">//定义静态加载方式时的主设备号参数major</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> minor<span class="token punctuation">;</span><span class="token comment">//定义静态加载方式时的次设备号参数minor</span>
<span class="token function">module_param</span><span class="token punctuation">(</span>major<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span>S_IRUGO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过驱动模块传参的方式传递主设备号参数major</span>
<span class="token function">module_param</span><span class="token punctuation">(</span>minor<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span>S_IRUGO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过驱动模块传参的方式传递次设备号参数minor</span>
<span class="token keyword">static</span> <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span><span class="token comment">//定义dev_t类型(32位大小)的变量dev_num</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">dev_t_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span><span class="token comment">//定义int类型的变量ret，用来判断函数返回值</span>
	<span class="token comment">/*以主设备号进行条件判断，即如果通过驱动传入了major参数则条件成立，进入以下分支*/</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>major<span class="token punctuation">)</span><span class="token punctuation">{</span>
    	dev_num <span class="token operator">=</span> <span class="token function">MKDEV</span><span class="token punctuation">(</span>major<span class="token punctuation">,</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过MKDEV函数将驱动传参的主设备号和次设备号转换成dev_t类型的设备号</span>
    	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d\n"</span><span class="token punctuation">,</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d\n"</span><span class="token punctuation">,</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	ret <span class="token operator">=</span> <span class="token function">register_chrdev_region</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过静态方式进行设备号注册</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"register_chrdev_region is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"register_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token comment">/*如果没有通过驱动传入major参数，则条件成立，进入以下分支*/</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过动态方式进行设备号注册</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>                                                                                                                                              
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        major<span class="token operator">=</span><span class="token function">MAJOR</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过MAJOR()函数进行主设备号获取</span>
        minor<span class="token operator">=</span><span class="token function">MINOR</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过MINOR()函数进行次设备号获取</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d\n"</span><span class="token punctuation">,</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d\n"</span><span class="token punctuation">,</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">dev_t_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注销字符驱动</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>dev_t_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册入口函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>dev_t_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册出口函数</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同意GPL开源协议</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//作者信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上代码通过对传入参数的判断，从而进行设备号申请方式的选择，会在下一小节进行相应的驱动加载测试。</p>
<h3 id="9-3-运行测试"><a href="#9-3-运行测试" class="headerlink" title="9.3 运行测试"></a>9.3 运行测试</h3><h4 id="9-3-1-编译驱动程序"><a href="#9-3-1-编译驱动程序" class="headerlink" title="9.3.1 编译驱动程序"></a>9.3.1 编译驱动程序</h4><p>在上一小节中的dev_t.c 代码同一目录下创建Makefile 文件，Makefile 文件内容如下（图9-6）所示：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">export</span> ARCH<span class="token operator">=</span>arm64	<span class="token comment">#设置平台架构</span>
<span class="token keyword">export</span> CROSS_COMPILE<span class="token operator">=</span>aarch64-linux-gnu-	<span class="token comment">#交叉编译器前缀</span>
obj-m <span class="token operator">+=</span> dev_t.o	 <span class="token comment">#此处要和你的驱动源文件同名</span>
KDIR <span class="token operator">:=</span>/home/topeet/Linux/linux_sdk/kernel <span class="token comment">#这里是你的内核目录</span>
PWD <span class="token operator">?=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span>
<span class="token target symbol">all</span><span class="token punctuation">:</span>
make -C <span class="token variable">$</span><span class="token punctuation">(</span>KDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> modules <span class="token comment">#make 操作</span>
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
make -C <span class="token variable">$</span><span class="token punctuation">(</span>KDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> clean <span class="token comment">#make clean 操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于Makefile 的内容注释已在上图添加，保存退出之后，来到存放dev_t.c 和Makefile 文件目录下，然后使用命令“make”进行驱动的编译，编译完生成dev_t.ko 目标文件至此我们的驱动模块就编译成功了，下面对驱动进行加载测试。</p>
<h4 id="9-3-2-运行测试"><a href="#9-3-2-运行测试" class="headerlink" title="9.3.2 运行测试"></a>9.3.2 运行测试</h4><p>开发板上电启动之后，使用以下命令加载dev_t.ko 驱动，加载完成之后的打印信息如下图图（9-10）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod dev_t.ko <span class="token assign-left variable">major</span><span class="token operator">=</span><span class="token number">200</span> <span class="token assign-left variable">minor</span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408121045598.png" alt="image-20240812104528538"></p>
<p>可以看到传入的主设备号和次设备号都被打印了出来，“register_chrdev_region is ok”也被成功打印了证明设备注册成功了，然后使用以下命令进行注册设备号的查看，如下图（图9-11）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/devices<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以看到主设备号200 的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，然后使用以下命令进行驱动的卸载，如下图（图9-12）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod dev_t.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408121046310.png" alt="image-20240812104624263"></p>
<p>下面进行动态申请设备号实验，使用以下命令进行驱动模块的加载，如下图（图9-13）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod dev_t.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408121046410.png" alt="image-20240812104644361"></p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">cat <span class="token operator">/</span>proc<span class="token operator">/</span>devices<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408121047681.png" alt="image-20240812104722637"></p>
<p>可以看到主设备号236 的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，最后可以输入以下命令对驱动进行卸载，卸载完成如下图（图9-15）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod dev_t.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408121047389.png" alt="image-20240812104740342"></p>
<h2 id="第10-章注册字符设备实验"><a href="#第10-章注册字符设备实验" class="headerlink" title="第10 章注册字符设备实验"></a>第10 章注册字符设备实验</h2><p>在上一小节中已经对设备号的相关知识进行了讲解，并成功申请到了设备号，那在Linux系统中，设备号是怎样与字符设备进行关联的呢？字符设备又是怎样注册的呢？带着疑问，让我们开始本章节的学习吧。</p>
<h3 id="10-1-注册字符设备"><a href="#10-1-注册字符设备" class="headerlink" title="10.1 注册字符设备"></a>10.1 注册字符设备</h3><p>注册字符设备可以分为两个步骤：</p>
<ol>
<li>字符设备初始化</li>
<li>字符设备的添加</li>
</ol>
<p>在本小节将对上述两个步骤所用到的函数和结构体进行讲解。</p>
<h4 id="10-1-1-字符设备初始化"><a href="#10-1-1-字符设备初始化" class="headerlink" title="10.1.1 字符设备初始化"></a>10.1.1 字符设备初始化</h4><p>字符设备初始化所用到的函数为<code>cdev_init(...)</code>,在对该函数讲解之前，首先对cdev 结构体进行介绍。<br>Linux 内核中将字符设备抽象成一个具体的数据结构(<code>struct cdev</code>), 我们可以理解为字符设备对象，<code>cdev</code> 记录了字符设备号、内核对象、文件操作<code>file_operations</code> 结构体（设备的打开、读写、关闭等操作接口）等信息，<code>struct cdev</code> 结构体定义在“<code>内核源码/include/linux/cdev.h</code>”文件中（在编写驱动程序的时候要加入该文件的引用），如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kobject</span> kobj<span class="token punctuation">;</span> <span class="token comment">//内嵌的内核对象.</span>
    <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span> <span class="token comment">//该字符设备所在的内核模块的对象指针.</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>ops<span class="token punctuation">;</span> <span class="token comment">//该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span> <span class="token comment">//用来将已经向内核注册的所有字符设备形成链表.</span>
    <span class="token class-name">dev_t</span> dev<span class="token punctuation">;</span> <span class="token comment">//字符设备的设备号，由主设备号和次设备号构成.</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">//隶属于同一主设备号的次设备号的个数.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关于该结构体参数的注释在上图已经添加，设备初始化所用到的函数为cdev_init(),该函数同样在“<code>内核源码/include/linux/cdev.h</code>”文件中所引用如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>该函数的详细内容在“内核源码/include/fs/char_dev.c”文件中定义，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>cdev<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>fops<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>cdev<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token operator">*</span>cdev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将整个结构体清零；</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化list 成员使其指向自身；</span>
    <span class="token function">kobject_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev<span class="token operator">-&gt;</span>kobj<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ktype_cdev_default<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化kobj 成员；</span>
    cdev<span class="token operator">-&gt;</span>ops <span class="token operator">=</span> fops<span class="token punctuation">;</span><span class="token comment">//初始化ops 成员，建立cdev 和file_operations 之间的连接</span>
<span class="token punctuation">}</span>
函数作用：
    初始化传入的cdev 类型的结构体，并与自定义的file_operations <span class="token operator">*</span> 类型的结构体进行链
接。
参数含义：
    cdev<span class="token operator">:</span> 要传入的cdev 类型结构体，为要初始化的字符设备。
    fops：要传入的file_operations <span class="token operator">*</span> 类型结构体，关于file_operations 结构体的相关的知识会在下一章节进行讲解。
函数返回值：无返回值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="10-1-2-字符设备的注册"><a href="#10-1-2-字符设备的注册" class="headerlink" title="10.1.2 字符设备的注册"></a>10.1.2 字符设备的注册</h3><p>字符设备的注册：<br>字符设备添加所用到的函数为<code>cdev_add()</code>，该函数在“<code>内核源码/include/linux/cdev.h</code>”文件中所引用，如下（图10-4）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">dev_t</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

函数原型：
	<span class="token keyword">int</span> <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token class-name">dev_t</span> dev<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> count<span class="token punctuation">)</span>
函数作用：
    该函数向内核注册一个<span class="token keyword">struct</span> <span class="token class-name">cdev</span> 结构体
参数含义：
    <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>第一个参数为要添加的<span class="token keyword">struct</span> <span class="token class-name">cdev</span> 类型的结构体
    <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>第二个参数为申请的字符设备号
    <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>第三个参数为和该设备关联的设备编号的数量。
    这两个参数直接赋值给<span class="token keyword">struct</span> <span class="token class-name">cdev</span> 的dev 成员和count 成员。
函数返回值：添加成功返回<span class="token number">0</span>，添加失败返回负数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>字符设备的注销：<br>字符设备删除所用到的函数为<code>cdev_del()</code>，该函数同样在“<code>内核源码/include/linux/cdev.h”</code>文件中所引用，如下（图10-5）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

函数原型：
    <span class="token keyword">void</span> <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
函数作用：
    该函数会向内核删除一个<span class="token keyword">struct</span> <span class="token class-name">cdev</span> 类型结构体
参数含义：
    该函数只有一个参数，为要删除的<span class="token keyword">struct</span> <span class="token class-name">cdev</span> 类型的结构体
函数返回值：无返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>至此，关于注册字符设备实验所用到的函数就讲解完成了，在下一小节中将编写注册字符设备代码。</p>
<h3 id="10-2-实验程序的编写"><a href="#10-2-实验程序的编写" class="headerlink" title="10.2 实验程序的编写"></a>10.2 实验程序的编写</h3><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\05</code>。<br>本实验采用动态申请设备号的方式进行设备号的申请，然后对设备进行注册，并将申请到的主设备号和次设备号以及设备注册情况打印到终端上。<br>编写完成的cdev.c 代码如下（图10-6）所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span><span class="token comment">//定义dev_t类型（32位大小）的变量dev_num,用来存放设备号</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span><span class="token comment">//定义cdev结构体类型的变量cdev_test</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span>owner<span class="token operator">=</span>THIS_MODULE<span class="token punctuation">,</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义file_operations结构体类型的变量cdev_test_ops</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">module_cdev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span><span class="token comment">//定义int类型变量ret，进行函数返回值判断</span>
    <span class="token keyword">int</span> major<span class="token punctuation">,</span>minor<span class="token punctuation">;</span><span class="token comment">//定义int类型的主设备号major和次设备号minor</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动获取设备号，设备名为chrdev_name</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_register_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MAJOR()函数获取主设备号</span>
    minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MINOR()函数获取次设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d\n"</span><span class="token punctuation">,</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d\n"</span><span class="token punctuation">,</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>          	
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">,</span><span class="token operator">&amp;</span>cdev_test_ops<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span>
	cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    ret <span class="token operator">=</span> <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">,</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_add()函数进行字符设备的添加</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"cdev_add is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"cdev_add is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">module_cdev_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_del()函数进行字符设备的删除</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放字符驱动设备号 </span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>module_cdev_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册入口函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>module_cdev_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册出口函数</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同意GPL开源协议</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//作者信息  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>相较于上一章节实验，本章节的代码去掉了静态申请设备号部分代码，并在申请设备号完成之后注册了相应的字符设备，并在驱动出口函数中添加了相应的字符设备删除代码（相关代码已加粗）。<br>需要注意的是，字符设备的注册要放在申请字符设备号之后，字符设备的删除要放在释放字符驱动设备号之前。</p>
<h3 id="10-3-运行测试"><a href="#10-3-运行测试" class="headerlink" title="10.3 运行测试"></a>10.3 运行测试</h3><h4 id="10-3-1-编译驱动程序"><a href="#10-3-1-编译驱动程序" class="headerlink" title="10.3.1 编译驱动程序"></a>10.3.1 编译驱动程序</h4><p>在上一小节中的cdev.c 代码同一目录下创建Makefile 文件，Makefile 文件内容如下（图10-7）所示：还是用之前的Makefile，改一下名字就好了。</p>
<p>然后使用命令“make”进行驱动的编译，编译完会生成cdev.ko 目标文件。至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<p>10.3.2 运行测试<br>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图10-11）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod cdev.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131102501.png" alt="image-20240813110200417"></p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/devices<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131103448.png" alt="image-20240813110315411"></p>
<p>可以看到主设备号236 的设备名为chrdev_name，和驱动程序中设置的设备名称相同，证明字符设备注册成功了，最后可以使用以下命令对驱动进行卸载，卸载完成如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod cdev.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131103471.png" alt="image-20240813110348431"></p>
<h2 id="第11-章创建设备节点实验"><a href="#第11-章创建设备节点实验" class="headerlink" title="第11 章创建设备节点实验"></a>第11 章创建设备节点实验</h2><p>在上两个章节的学习中，我们已经成功的申请了设备号并且注册了相应的字符设备。系统通过设备号对设备进行查找，而字符设备注册到内核之后，并不能直接进行设备文件操作命令（打开、关闭、读、写等），需要相应的设备文件作为桥梁以此来进行设备的访问，在本章节将对如何创建设备节点进行学习。</p>
<h3 id="11-1-创建设备节点"><a href="#11-1-创建设备节点" class="headerlink" title="11.1 创建设备节点"></a>11.1 创建设备节点</h3><p>在Linux 操作系统中一切皆文件，设备访问也是通过文件的方式来进行的，对于用来进行设备访问的文件称之为设备节点，设备节点被创建在/dev 目录下，将内核中注册的设备与用户层进行链接，这样应用程序才能对设备进行访问。</p>
<p>根据设备节点的创建方式不同，分为了手动创建设备节点和自动创建设备节点，下面对两种设备节点创建方式进行介绍。</p>
<h4 id="11-1-1-手动创建设备节点"><a href="#11-1-1-手动创建设备节点" class="headerlink" title="11.1.1 手动创建设备节点"></a>11.1.1 手动创建设备节点</h4><p>使用mknod 命令手动创建设备节点，mknod 命令格式为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mknod</span> NAME TYPE MAJOR MINOR

参数含义：
    NAME: 要创建的节点名称
    TYPE: b 表示块设备，c 表示字符设备，p 表示管道
    MAJOR：要链接设备的主设备号
    MINOR: 要链接设备的从设备号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例如使用以下命令创建一个名为device_test 的字符设备节点，链接设备的主设备号和从设备号分别为236 和0：</p>
<pre class="line-numbers language-none"><code class="language-none">mknod /dev/device_test c 236 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="11-1-2-自动创建设备节点"><a href="#11-1-2-自动创建设备节点" class="headerlink" title="11.1.2 自动创建设备节点"></a>11.1.2 自动创建设备节点</h4><p>设备文件的自动创建是利用<code>udev(mdev)</code>机制来实现，多数情况下采用自动创建设备节点的方式。<code>udev(mdev)</code>可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。在驱动中首先使用<code>class_create(…)</code>函数对class 进行创建，这个类存放于<code>/sys/class/</code> 目录下，之后使用<code>device_create(…)</code>函数创建相应的设备，在进行模块加载时，用户空间中的udev 会自动响应device_create()函数，寻找对应的类从而创建设备节点。</p>
<p>下面对于自动创建节点中所用到的函数进行解释说明：</p>
<p><strong><code>class_create(…)</code>函数</strong><br>该函数在“<code>内核源码/include/linux/device.h</code>”文件中所引用（由于上一小节中引用的<code>cdev.h</code>文件已包含<code>device.h</code>，所以不需要再重复引用），如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">class_create</span><span class="token expression"><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> name<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">lock_class_key</span> __key<span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token function">__class_create</span><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>__key<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>

函数作用：
    用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux 内核系统。
参数含义：
    owner：<span class="token keyword">struct</span> <span class="token class-name">module</span> 结构体类型的指针，指向函数即将创建的这个<span class="token keyword">struct</span> <span class="token class-name">class</span> 的模块。一般赋值为THIS_MODULE。
    name：<span class="token keyword">char</span> 类型的指针，代表即将创建的<span class="token keyword">struct</span> <span class="token class-name">class</span> 变量的名字。
返回值：<span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span> 类型的结构体。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>class_destroy(...)</code>函数</strong><br>该函数在“<code>内核源码/include/linux/device.h</code>”文件中所引用，如下（图11-2）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">class_destroy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>

函数作用：
    用于删除设备的逻辑类，即从Linux 内核系统中删除设备的逻辑类。
参数含义：
    owner：<span class="token keyword">struct</span> <span class="token class-name">module</span> 结构体类型的指针，指向函数即将创建的这个<span class="token keyword">struct</span> <span class="token class-name">class</span> 的模块。一般赋值为THIS_MODULE。
    name：<span class="token keyword">char</span> 类型的指针，代表即将创建的<span class="token keyword">struct</span> <span class="token class-name">class</span> 变量的名字。
返回值：无<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>**device_create(...)</code>函数**<br>该函数在“内核源码/include/linux/device.h”文件中所引用，如下（图11-3）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span><span class="token function">device_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>cls<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token class-name">dev_t</span> devt<span class="token punctuation">,</span> 
                             <span class="token keyword">void</span> <span class="token operator">*</span>drvdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

函数作用：
    用来在class 类中下创建一个设备属性文件，udev 会自动识别从而进行设备节点的创建。
参数含义：
    cls：指定所要创建的设备所从属的类。
    parent<span class="token operator">:</span>指定该设备的父设备，如果没有就指定为<span class="token constant">NULL</span>。
    devt<span class="token operator">:</span>指定创建设备的设备号。
    drvdata<span class="token operator">:</span>被添加到该设备回调的数据，没有则指定为<span class="token constant">NULL</span>。
    fmt：添加到系统的设备节点名称。
返回值：<span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span> 类型结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>device_destroy(...)</code>函数</strong><br>在“<code>内核源码/include/linux/device.h</code>”文件中所引用，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">device_destroy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>cls<span class="token punctuation">,</span> <span class="token class-name">dev_t</span> devt<span class="token punctuation">)</span><span class="token punctuation">;</span>

函数作用：
    用来删除class 类中的设备属性文件，udev 会自动识别从而进行设备节点的删除。
参数含义：
    cls：指定所要创建的设备所从属的类。
    devt<span class="token operator">:</span>指定创建设备的设备号。
返回值：无<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>至此，关于自动创建节点相关的函数就介绍完成了，会在下一小节中对于设备节点的自动创建进行相应实验程序的编写。</p>
<h3 id="11-2-实验程序的编写"><a href="#11-2-实验程序的编写" class="headerlink" title="11.2 实验程序的编写"></a>11.2 实验程序的编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\06。</p>
<p>本章实验将编写Linux 下的自动创建设备节点实验代码，首先采用自动申请设备号的方式进行设备号的申请，并对获取的主设备号与次设备号进行打印，之后对字符设备进行注册(file_operations 结构体只填充owner 字段即可，会在下个章节对file_operations 结构体进行讲解)，最后自动对设备节点进行创建。</p>
<p>编写完成的chrdev_node.c 代码如下（图11-5）所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span><span class="token comment">//定义dev_t类型变量dev_num来表示设备号</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span><span class="token comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_fops_test <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义file_operations结构体类型的变量cdev_test_ops</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class_test<span class="token punctuation">;</span><span class="token comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chrdev_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span><span class="token comment">//定义int类型的变量ret，用来对函数返回值进行判断</span>
    <span class="token keyword">int</span> major<span class="token punctuation">,</span>minor<span class="token punctuation">;</span><span class="token comment">//定义int类型的主设备号major和次设备号minor</span>
	ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动获取设备号，设备名chrdev_name</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret  <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MAJOR()函数获取主设备号</span>
    minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MINOR()函数获取次设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d\n"</span><span class="token punctuation">,</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d\n"</span><span class="token punctuation">,</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">,</span><span class="token operator">&amp;</span>cdev_fops_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span>
	cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	ret <span class="token operator">=</span> <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">,</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使用cdev_add()函数进行字符设备的添加</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"cdev_add is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"cdev_add is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                                
    class_test  <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span><span class="token string">"class_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用class_create进行类的创建，类名称为class_test</span>
    <span class="token function">device_create</span><span class="token punctuation">(</span>class_test<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>dev_num<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token string">"device_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用device_create进行设备的创建，设备名称为device_test</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chrdev_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除添加的字符设备cdev_test</span>
	<span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放字符设备所申请的设备号</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>class_test<span class="token punctuation">,</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>class_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的类</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>chrdev_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册入口函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chrdev_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册出口函数</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同意GPL开源协议</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//作者信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>相较于上一章节实验，本章节代码在入口函数中添加了自动创建设备节点相关代码，在驱动出口函数中添加了相应的删除设备节点相关代码(相关代码已加粗)。</p>
<p>需要注意的是，<strong>在进行设备节点添加时，类的创建要放在设备创建之前；在进行设备节点删除时，类的删除要放在设备删除之后。</strong></p>
<h3 id="11-3-运行测试"><a href="#11-3-运行测试" class="headerlink" title="11.3 运行测试"></a>11.3 运行测试</h3><h4 id="11-3-1-编译驱动程序"><a href="#11-3-1-编译驱动程序" class="headerlink" title="11.3.1 编译驱动程序"></a>11.3.1 编译驱动程序</h4><p>在上一小节中的chrdev_node.c 代码同一目录下创建Makefile 文件，Makefile 文件内容与前面保持一致，改一下名称就行。来到存放chrdev_node.c 和Makefile 文件目录下，然后使用命令“make”进行驱动的编译，编译完生成chrdev_node.ko 目标文件，至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h4 id="11-3-2-运行测试"><a href="#11-3-2-运行测试" class="headerlink" title="11.3.2 运行测试"></a>11.3.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图11-10）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod cdev.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131120084.png" alt="image-20240813112006037"></p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图11-11）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">cat <span class="token operator">/</span>proc<span class="token operator">/</span>devices<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131121550.png" alt="image-20240813112121509"></p>
<p>可以看到主设备号236 的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，然后使用以下命令对class 目录进行查看，如下图（图11-12）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /sys/class/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131121052.png" alt="image-20240813112149988"></p>
<p>可以看到在驱动程序中创建的class_test 类已经被成功创建了，然后使用以下命令对class_test 目录进行查看，如下图（图11-12）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ls <span class="token operator">/</span>sys<span class="token operator">/</span>class<span class="token operator">/</span>class_test<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131122174.png" alt="image-20240813112216130"></p>
<p>可以看到在驱动程序中创建的名为device_test 的设备属性文件夹也被创建了，然后使用命令“<code>ls /dev/device_test</code>”对<code>/dev</code> 目录进行查看，相应的设备节点也已经被自动创建了，如下所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131122036.png" alt="image-20240813112249992"></p>
<p>最后可以使用以下命令进行驱动的卸载，卸载完成如下图（图11-14）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod chrdev_node.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131123161.png" alt="image-20240813112308120"></p>
<h2 id="第12-章字符设备驱动框架实验"><a href="#第12-章字符设备驱动框架实验" class="headerlink" title="第12 章字符设备驱动框架实验"></a>第12 章字符设备驱动框架实验</h2><p>下面对前面三个章节进行总结，首先<strong>驱动向Linux 内核进行设备号申请</strong>，之后的字符设备注册时，会对申请的设备号进行使用。而Linux 内核会将字符设备抽象成一个具体的struct cdev结构体，该结构体记录了字符设备的字符设备号、内核对象等信息，**<code>cdev_init(...)</code>函数对结构体进行初始化之后<strong>，</strong><code>cdev_add(...)</code>函数将设备号和<code>cdev</code> 结构体进行链接<strong>，</strong>这时设备号才真正指向了内核中注册的设备**。设备注册成功之后，此时还不能对字符设备进行文件操作，所以需要设备节节点来充当内核和用户层通信的桥梁，至此，前面三个章节就总结完成了，以上步骤并没有涉及到操作设备文件，本章节将对字符设备框架进行最终的完善。</p>
<h3 id="12-1-文件操作集简介"><a href="#12-1-文件操作集简介" class="headerlink" title="12.1 文件操作集简介"></a>12.1 文件操作集简介</h3><p>在进行注册字符设备实验章节中，使用<code>cdev_init(...)</code>函数对<code>struct cdev</code> 结构体类型变量和<code>struct file_operations</code> 结构体类型变量相链接，<code>struct file_operations</code> 结构体就是把系统调用和驱动程序关联起来的关键数据结构。该结构体的每一个成员都对应着一个系统调用，读取<code>file_operation</code> 中相应的函数指针，接着把控制权转交给函数，从而完成了Linux 设备驱动程序的工作。<br>file_operations 结构体定义在“内核源码/include/linux/fs.h”文件中，下面对部分常用函数进行说明：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>owner 是第一个file_operations 成员，它并不是一个操作, 而一个指向拥有该结构的模块的指针，避免正在操作时被卸载，一般为初始化为THIS_MODULES (在&lt;linux/module.h&gt; 中定义的宏)</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>read 函数指针用来从设备中同步读取数据，读取成功返回读取的字节数。与应用程序中的read 函数对应。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>write 函数指针用来发送数据给设备. 写入成功返回写入的字节数。与应用程序中的write函数对应。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlocked_ioctl<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>unlocked_ioctl</code> 函数指针提供对于设备的控制功能，与应用程序中的ioctl 函数对应。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>open 函数指针用于打开设备,与应用程序中的open 函数对应。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>release 函数指针在file 结构体释放时被调用<br>至此对于file_operations 文件操作集的部分常用函数就介绍完了，填充了部分常用函数的<code>file_operations</code> 结构体如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_fops_test <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token comment">//将owner 字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> chrdev_open<span class="token punctuation">,</span><span class="token comment">//将open 字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> chrdev_read<span class="token punctuation">,</span><span class="token comment">//将open 字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> chrdev_write<span class="token punctuation">,</span><span class="token comment">//将open 字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> chrdev_release<span class="token punctuation">,</span><span class="token comment">//将open 字段指向chrdev_release(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义file_operations 结构体类型的变量cdev_test_ops</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>会在下个小节进行字符设备驱动框架实验代码的编写，在上一章节实验的基础上加入file_operations 结构体，并通过应用程序对字符设备驱动进行文件操作测试。</p>
<h3 id="12-2-实验程序的编写"><a href="#12-2-实验程序的编写" class="headerlink" title="12.2 实验程序的编写"></a>12.2 实验程序的编写</h3><h4 id="12-2-1-驱动程序编写"><a href="#12-2-1-驱动程序编写" class="headerlink" title="12.2.1 驱动程序编写"></a>12.2.1 驱动程序编写</h4><p>本实验驱动程序对应的网盘路径为： <code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\07\module</code>。</p>
<p>本章实验将编写字符设备驱动框架实验，会在上一章节实验基础上对file_operation 结构体相关内容进行补充。</p>
<p>首先采用自动申请设备号的方式进行设备号的申请，然后对获取的主设备号与次设备号进行打印，之后对字符设备进行注册，并填充相应的file_openration 结构体和相关函数，最后自动对设备节点进行创建，编写完成的chrdev_fops.c 代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">chrdev_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is chrdev_open \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">chrdev_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is chrdev_read \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">chrdev_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span><span class="token class-name">size_t</span> size<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is chrdev_write \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">chrdev_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span><span class="token comment">//定义dev_t类型变量dev_num来表示设备号</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span><span class="token comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_fops_test <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	<span class="token punctuation">.</span>open <span class="token operator">=</span> chrdev_open<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>read <span class="token operator">=</span> chrdev_read<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>write <span class="token operator">=</span> chrdev_write<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>release <span class="token operator">=</span> chrdev_release<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义file_operations结构体类型的变量cdev_test_ops</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class_test<span class="token punctuation">;</span><span class="token comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chrdev_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span><span class="token comment">//定义int类型的变量ret，用来对函数返回值进行判断</span>
    <span class="token keyword">int</span> major<span class="token punctuation">,</span>minor<span class="token punctuation">;</span><span class="token comment">//定义int类型的主设备号major和次设备号minor</span>
	ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动获取设备号，设备名chrdev_name</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret  <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MAJOR()函数获取主设备号</span>
    minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MINOR()函数获取次设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d\n"</span><span class="token punctuation">,</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d\n"</span><span class="token punctuation">,</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">,</span><span class="token operator">&amp;</span>cdev_fops_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span>
	cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	ret <span class="token operator">=</span> <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">,</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使用cdev_add()函数进行字符设备的添加</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"cdev_add is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"cdev_add is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                                
    class_test  <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span><span class="token string">"class_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用class_create进行类的创建，类名称为class_test</span>
    <span class="token function">device_create</span><span class="token punctuation">(</span>class_test<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>dev_num<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token string">"device_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用device_create进行设备的创建，设备名称为device_test</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chrdev_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
	<span class="token function">device_destroy</span><span class="token punctuation">(</span>class_test<span class="token punctuation">,</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>class_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的类</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除添加的字符设备cdev_test</span>
	<span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放字符设备所申请的设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>chrdev_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册入口函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chrdev_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册出口函数</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同意GPL开源协议</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//作者信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="12-2-2-编写测试APP"><a href="#12-2-2-编写测试APP" class="headerlink" title="12.2.2 编写测试APP"></a>12.2.2 编写测试APP</h4><p>本实验应用程序对应的网盘路径为： <code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\07\app</code>。</p>
<p>由于在驱动程序中，只是对一系列文件操作函数添加了标志打印（之后的章节会加入数据的读写），所以本小节的应用程序只是起简单的测试作用。编写完成的应用程序app.c 内容如下（图12-3）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//定义int类型的文件描述符</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//定义读取缓冲区buf</span>
    fd<span class="token operator">=</span><span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">,</span><span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*如果第二个参数为read，条件成立，调用read函数，对文件进行读取*/</span>                                                                                                                                  
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"read"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为write，条件成立，调用write函数，对文件进行写入*/</span>  
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"write"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"hello\n"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用close函数，对取消文件描述符到文件的映射</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述应用程序逻辑较为简单，第一个参数为要进行读写操作的设备节点，第二个参数为read 时，对设备节点进行读操作，第二个参数为write 时，对设备节点进行写操作。</p>
<h3 id="12-3-运行测试"><a href="#12-3-运行测试" class="headerlink" title="12.3 运行测试"></a>12.3 运行测试</h3><h4 id="12-3-1-编译驱动程序"><a href="#12-3-1-编译驱动程序" class="headerlink" title="12.3.1 编译驱动程序"></a>12.3.1 编译驱动程序</h4><p>在上一小节中的chrdev_fops.c 代码同一目录下创建Makefile 文件，Makefile 文件内容与前面的一致。对于Makefile 的内容注释已在上图添加，保存退出之后，来到存放chrdev_fops.c 和Makefile 文件目录下，然后使用命令“make”进行驱动的编译，编译完生成chrdev_fops.ko 目标文件，至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h4 id="12-3-2-编译应用程序"><a href="#12-3-2-编译应用程序" class="headerlink" title="12.3.2 编译应用程序"></a>12.3.2 编译应用程序</h4><p>来到应用程序app.c 文件的存放路径如下图（图12-8）所示：然后使用以下命令对app.c 进行交叉编译，编译完成如下图（图12-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> app app.c <span class="token parameter variable">-static</span>
gcc <span class="token parameter variable">-o</span> app app.c		<span class="token comment"># 或者gcc app.c -o app </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>生成的app 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="12-3-3-运行测试"><a href="#12-3-3-运行测试" class="headerlink" title="12.3.3 运行测试"></a>12.3.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图12-10）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod chrdev_fops.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131142712.png" alt="image-20240813114239662"></p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test 进行查看，如下图（图12-11）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/device_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131143332.png" alt="image-20240813114302283"></p>
<p>可以看到device_test 节点已经被自动创建了，然后使用以下命令对open()函数进行测试，如下所示</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app /dev/device_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131143433.png" alt="image-20240813114329387"></p>
<p>可以看到“This is chrdev_open”和“open is ok”信息被打印了，证明应用程序运行成功，且调用了驱动程序中的<code>open(...)</code>函数，而“Segmentation fault”相关打印是因为没有对第二个参数进行传入，这里忽略即可，随后使用以下命令对设备进行读测试，如下图（图12-13）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app /dev/device_test <span class="token builtin class-name">read</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131144876.png" alt="image-20240813114421826"></p>
<p>可以看到“This is chrdev_read”信息被打印了出来，证明驱动程序中的read(…)函数被调用了,然后使用以下命令对设备进行写测试，如下图（图12-14）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app /dev/device_test <span class="token function">write</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131144280.png" alt="image-20240813114445231"></p>
<p>可以看到“This is chrdev_write”信息被打印了出来，证明驱动程序中的write(…)函数被调用了。最后可以使用以下命令进行驱动的卸载，如下图（图12-15）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408131145502.png" alt="image-20240813114500456"></p>
<p>至此，字符设备驱动框架实验就完成了。</p>
<h2 id="第13-章杂项设备驱动实验"><a href="#第13-章杂项设备驱动实验" class="headerlink" title="第13 章杂项设备驱动实验"></a>第13 章杂项设备驱动实验</h2><p>经过前面章节的学习，我们已经对字符设备驱动框架有了一定的理解，而本章要讲解的杂项设备属于特殊的一种字符型设备，是对字符设备的一种封装，为最简单的字符设备。为什么从字符设备中单独提取出了杂项设备呢？杂项设备又要如何进行使用呢？带着疑问，让我们进行杂项设备的学习吧！</p>
<h3 id="13-1-杂项设备驱动简介"><a href="#13-1-杂项设备驱动简介" class="headerlink" title="13.1 杂项设备驱动简介"></a>13.1 杂项设备驱动简介</h3><p>在Linux 中，把无法归类的五花八门的设备定义成杂项设备。相较于字符设备，杂项设备有以下两个优点:</p>
<p>(1)<strong>节省主设备号</strong>:<strong>杂项设备的主设备号固定为10</strong>，而字符设备不管是动态分配还是静态分配设备号，都会消耗一个主设备号，进而造成了主设备号浪费。当系统中注册了多个misc 设备驱动时，只需使用子设备号进行区分即可。</p>
<p>(2)<strong>使用简单</strong>：当使用普通的字符设备驱动时，如果开发人员需要导出操作接口给用户空间，就需要注册对应的字符驱动，并创建字符设备class 从而自动在/dev 下生成设备节点，而misc驱动只需要将基本信息通过结构体传递给相应处理函数即可。</p>
<p>在驱动中使用miscdevice 结构体描述misc 设备， 该结构体定义在“ 内核源码/include/linux/miscdevice.h”文件中（在下面的实验代码中需要加入该头文件的引用），具体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">miscdevice <span class="token punctuation">{</span>
    <span class="token keyword">int</span> minor<span class="token punctuation">;</span> 								<span class="token comment">/* 子设备号需要用户填写*/</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>						<span class="token comment">/* 设备名需要用户填写*/</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>fops<span class="token punctuation">;</span>		  <span class="token comment">/* 设备操作集需要用户填写*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>this_device<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>groups<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>nodename<span class="token punctuation">;</span>
    <span class="token class-name">umode_t</span> mode<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>定义一个misc 设备，一般只需要填充<code>minor</code>、<code>name</code>、<code>fops</code> 这三个成员变量。</p>
<ul>
<li>minor 指次设备号，可以从“内核源码/include/linux/miscdevice.h”文件中预定义的次设备号挑选，也可以自行定义子设备号（没有被其他设备使用即可），通常情况下将该参数设置为<code>MISC_DYNAMIC_MINOR</code>，表示自动分配子设备号。</li>
<li>name 表示misc 设备的名字。misc 设备驱动注册成功之后，会在dev 目录下生成名为name的设备节点。</li>
<li>fops 指向了file_operations 的结构体，表示字符设备的操作集合。</li>
</ul>
<h3 id="13-2-杂项设备的注册和卸载"><a href="#13-2-杂项设备的注册和卸载" class="headerlink" title="13.2 杂项设备的注册和卸载"></a>13.2 杂项设备的注册和卸载</h3><p>不同于字符设备的注册和卸载的繁琐，杂项设备的注册可以直接使用函数<code>misc_register</code> 函数来完成，杂项设备的卸载可以直接使用<code>misc_deregister</code> 函数来完成。上述两个函数均定义在“<code>内核源码/include/linux/miscdevice.h</code>”文件当中。</p>
<p>杂项设备的注册：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">int</span> <span class="token function">misc_register</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">miscdevice</span> <span class="token operator">*</span>misc<span class="token punctuation">)</span>
函数作用：
    基于misc_class 构造一个设备，将miscdevice 结构挂载到misc_list 列表上，并初始化与linux设备模型相关的结构。进而起到杂项设备注册的作用。
参数含义：
    misc<span class="token operator">:</span> 杂项设备的结构体指针
函数返回值：申请成功返回<span class="token number">0</span>，申请失败返回负数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>杂项设备的卸载：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">int</span> <span class="token function">misc_deregister</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">miscdevice</span> <span class="token operator">*</span>misc<span class="token punctuation">)</span>
函数作用：
    从mist_list 中删除miscdevice，进而起到杂项设备卸载的作用。
参数含义：
    misc<span class="token operator">:</span> 杂项设备的结构体指针
函数返回值：卸载成功返回<span class="token number">0</span>，申请失败返回负数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>至此，注册和卸载杂项设备的API 函数就讲解完成了，会在接下来的驱动章节中对上述函数进行具体使用。</p>
<h3 id="13-3-杂项设备驱动框架"><a href="#13-3-杂项设备驱动框架" class="headerlink" title="13.3 杂项设备驱动框架"></a>13.3 杂项设备驱动框架</h3><p>MISC 驱动一般使用以下结构：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> xxx_fops<span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> xxx_read<span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">miscdevice</span> xxx_dev<span class="token punctuation">{</span>
    <span class="token punctuation">.</span>minor <span class="token operator">=</span> MISC_DYNAMIC_MINOR<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"xxx"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fops <span class="token operator">=</span> <span class="token operator">&amp;</span>xxx_fops
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">xxx_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"xxx_init\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">misc_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>xxx_dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册杂项设备</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token function">printk</span><span class="token punctuation">(</span> <span class="token string">"misc_register failed\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span> <span class="token string">"misc_register ok\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">xxx_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"xxx_exit\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">misc_deregister</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>xxx_dev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//卸载杂项设备</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>xxx_init<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注册入口函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>xxx_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="13-4-实验程序的编写"><a href="#13-4-实验程序的编写" class="headerlink" title="13.4 实验程序的编写"></a>13.4 实验程序的编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\08。</p>
<p>本小节将编写最简单的misc 驱动，在驱动入口函数中通过misc_register(…)函数注册杂项设备驱动，在驱动出口函数中通过<code>misc_deregister(...)</code>函数注销杂项设备驱动。编写完成的<code>miscdevice.c</code> 代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span>              <span class="token comment">//初始化头文件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span>            <span class="token comment">//最基本的文件，支持动态添加和卸载模块。</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/miscdevice.h&gt;</span>        <span class="token comment">//注册杂项设备头文件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span>                <span class="token comment">//注册设备节点的文件结构体</span></span>

<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> misc_fops <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">//文件操作集</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE <span class="token comment">////将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">miscdevice</span> misc_dev <span class="token operator">=</span> <span class="token punctuation">{</span>       <span class="token comment">//杂项设备结构体</span>
    <span class="token punctuation">.</span>minor <span class="token operator">=</span> MISC_DYNAMIC_MINOR<span class="token punctuation">,</span>     <span class="token comment">//动态申请的次设备号</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">,</span>                  <span class="token comment">//杂项设备名字是hello_misc</span>
    <span class="token punctuation">.</span>fops <span class="token operator">=</span> <span class="token operator">&amp;</span>misc_fops<span class="token punctuation">,</span>              <span class="token comment">//文件操作集</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">misc_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>           
<span class="token punctuation">{</span> 
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">misc_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>misc_dev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在初始化函数中注册杂项设备</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"misc registe is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印注册杂项设备失败</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"misc registe is succeed \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印注册杂项设备成功</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">misc_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
    <span class="token function">misc_deregister</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>misc_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//在卸载函数中注销杂项设备</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">" misc goodbye! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>misc_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>misc_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="13-5-运行测试"><a href="#13-5-运行测试" class="headerlink" title="13.5 运行测试"></a>13.5 运行测试</h3><h4 id="13-5-1-编译驱动程序"><a href="#13-5-1-编译驱动程序" class="headerlink" title="13.5.1 编译驱动程序"></a>13.5.1 编译驱动程序</h4><p>在上一小节中的<code>miscdevice.c</code> 代码同一目录下创建Makefile 文件，Makefile 文件内容用之前的，改一下名字就行，然后使用命令“make”进行驱动的编译，编译完生成miscdevice.ko 目标文件，至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h4 id="13-5-2-运行测试"><a href="#13-5-2-运行测试" class="headerlink" title="13.5.2 运行测试"></a>13.5.2 运行测试</h4><p>将编译生成的驱动模块miscdevice.ko 拷贝到开发板上，输入以下命令加载驱动模块。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod miscdevice.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141715650.png" alt="image-20240814171540545"></p>
<p>可以看到驱动加载之后，打印“misc registe is succeed”,说明misc 驱动注册成功。输入以下命令查看加载的驱动模块，驱动加载成功如下（图13-5）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141715243.png" alt="image-20240814171555191"></p>
<p>然后来到/sys/class/misc 目录下，可以看到名为“test”的文件夹已经被创建了，在<code>/sys/class/misc</code> 目录下有misc 类的所有设备，每个注册的杂项设备对应一个文件夹目录，如下图（图13-6）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141716508.png" alt="image-20240814171615437"></p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141716969.png" alt="image-20240814171622918"></p>
<p>驱动加载成功之后会生成/dev/test 设备驱动文件，输入以下命令查看杂项设备的主次设备号。</p>
<pre class="line-numbers language-none"><code class="language-none">ls /dev/test -al<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>结果如下图（图13-8）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141716892.png" alt="image-20240814171650842"></p>
<p>从上图可以看出，/dev/test 这个杂项设备的主设备号为10，次设备号为53，最后可以使用以下命令对驱动进行卸载，卸载完成如下图（图13-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod miscdevice.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141717418.png" alt="image-20240814171713371"></p>
<h2 id="第14-章内核空间与用户空间数据交互实验"><a href="#第14-章内核空间与用户空间数据交互实验" class="headerlink" title="第14 章内核空间与用户空间数据交互实验"></a>第14 章内核空间与用户空间数据交互实验</h2><p>在“第12 章字符设备驱动框架实验”中，已经对file_operations 结构体的进行了填充，该结构体的每一个成员都对应着一个系统调用，例如read、write 等，在对应的实验中，只是对调用函数进行了标志打印，并没有真正实现设备的读写功能，而在本章节将对内核空间与用户空间的数据交换功能进行实现。</p>
<h3 id="14-1-内核空间与用户空间"><a href="#14-1-内核空间与用户空间" class="headerlink" title="14.1 内核空间与用户空间"></a>14.1 内核空间与用户空间</h3><p>Linux 系统将可访问的内存空间分为了两个部分，一部分是内核空间，一部分是用户空间。操作系统和驱动程序运行在内核空间（内核态），应用程序运行在用户空间（用户态）。</p>
<p>那么为什么要区分用户空间和内核空间呢？</p>
<ul>
<li>（1）内核空间中的代码控制了硬件资源，用户空间中的代码只能通过内核暴露的系统调用接口来使用系统中的硬件资源，这样的设计可以保证操作系统自身的安全性和稳定性。</li>
<li>（2）从另一方面来说，内核空间的代码更偏向于系统管理，而用户空间中的代码更偏重业务逻辑实现，俩者的分工不同。</li>
</ul>
<p>硬件资源管理都是在内核空间完成的，应用程序无法直接对硬件进行操作，只能通过调用相应的内核接口来完成相应的操作。比如应用程序要对磁盘上的一个文件进行读取，应用程序可以向内核发起一个“系统调用”申请——我要读取磁盘上的文件。这个过程其实是通过一个特殊的指令让进程从用户态进入到了内核态。在内核空间中，CPU 可以执行任何命令，包括从磁盘上读取数据，具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并拿到了想要的数据，可以继续往下执行了。</p>
<p>进程只有从用户空间切换到内核空间才可以使用系统的硬件资源，切换的方式有三种：<strong>系统调用，软中断，硬中断</strong>，如下图（图14-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141729630.png" alt="image-20240814172904578"></p>
<h3 id="14-2-用户空间和内核空间数据交换"><a href="#14-2-用户空间和内核空间数据交换" class="headerlink" title="14.2 用户空间和内核空间数据交换"></a>14.2 用户空间和内核空间数据交换</h3><p>内核空间和用户空间的内存是不能互相访问的。但是很多应用程序都需要和内核进行数据的交换，例如应用程序使用read 函数从驱动中读取数据，使用write 函数向驱动中写数据，上述功能就需要使用copy_from_user 和copy_to_user 俩个函数来完成。<code>copy_from_user</code> 函数是将用户空间的数据拷贝到内核空间。<code>copy_to_user</code> 函数是将内核空间的数据拷贝到用户空间。这俩个函数定义在了<code>kernel/include/linux/uaccess.h</code> 文件下，如下所示：</p>
<p><strong><code>copy_to_user</code></strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">copy_to_user_inatomic</span><span class="token punctuation">(</span><span class="token keyword">void</span> __user <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
函数作用：
    把内核空间的数据复制到用户空间。
参数含义：
    <span class="token operator">*</span>to 是用户空间的指针
    <span class="token operator">*</span>from 是内核空间的指针
    n 是从内核空间向用户空间拷贝的字节数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>copy_from_user</code></strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> __user <span class="token operator">*</span>from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span>
函数作用：
    把用户空间的数据复制到内核空间。
参数含义：
    <span class="token operator">*</span>to 是内核空间的指针
    <span class="token operator">*</span>from 是用户空间的指针
    n 是从用户空间向内核空间拷贝的字节数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="14-3-实验程序编写"><a href="#14-3-实验程序编写" class="headerlink" title="14.3 实验程序编写"></a>14.3 实验程序编写</h3><h4 id="14-3-1-驱动程序编写"><a href="#14-3-1-驱动程序编写" class="headerlink" title="14.3.1 驱动程序编写"></a>14.3.1 驱动程序编写</h4><p>本驱动程序对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\09\module。</p>
<p>在该实验中将实现内核空间和用户空间进行数据交换的功能。以12 章编写的字符设备驱动框架实验为基础编写驱动程序，程序使用copy_to_user 函数和copy_from_user 函数来实现内核空间和用户空间互传数据的功能，编写完成的file.c 代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> major <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//主设备号</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> minor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//次设备号</span>
<span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span>   <span class="token comment">// cdev</span>

<span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>          <span class="token comment">//类</span>
<span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span>    <span class="token comment">//设备</span>

<span class="token comment">/*打开设备函数*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_open\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*向设备写入数据函数*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*本章实验重点******/</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//定义写入缓存区kbuf</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_from_user:用户空间向内核空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印copy_from_user函数执行失败</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_write\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"kbuf is %s\r\n"</span><span class="token punctuation">,</span> kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*本章实验重点******/</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"This is cdev_test_read!"</span><span class="token punctuation">;</span><span class="token comment">//定义内核空间数据</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> kbuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_to_user:内核空间向用户空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印copy_to_user函数执行失败</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_read\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_release\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数，定义file_operations结构体类型的变量cdev_test_fops*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span>  <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> cdev_test_write<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_release(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chr_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印动态分配设备号失败</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
    minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
    <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">,</span> dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*4 创建类*/</span>
    class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*5  创建设备*/</span>
    device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chr_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                                     <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>class<span class="token punctuation">,</span> dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>               			<span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                                     <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>chr_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//注册入口函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chr_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//注册出口函数</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上代码在<code>cdev_test_read</code> 函数中使用<code>copy_to_user</code> 函数将内核数据拷贝到用户空间，在<code>cdev_test_write</code> 函数中使用<code>copy_from_user</code> 函数将用户空间数据拷贝到内核空间。</p>
<p>14.3.2 编写测试APP<br>本应用程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\09\app</code>。</p>
<p>编写测试APP 其实是在编写Linux 应用，编译完成的应用程序app.c 代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">//主函数</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>   <span class="token comment">//定义int类型的文件描述符</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//定义读取缓存区buf1</span>
    <span class="token keyword">char</span> buf2<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"nihao"</span><span class="token punctuation">;</span> <span class="token comment">//定义写入缓存区buf2</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开字符设备驱动     //默认是阻塞的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf1<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从/dev/test文件读取数据</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"buf1 is %s \r\n"</span><span class="token punctuation">,</span> buf1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印读取的数据</span>

    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf2<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向/dev/test文件写入数据</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="14-4-运行测试"><a href="#14-4-运行测试" class="headerlink" title="14.4 运行测试"></a>14.4 运行测试</h3><h4 id="14-4-1-编译驱动程序"><a href="#14-4-1-编译驱动程序" class="headerlink" title="14.4.1 编译驱动程序"></a>14.4.1 编译驱动程序</h4><p>在上一小节中的file.c 代码同一目录下创建Makefile 文件，Makefile 文件内容与之前一致：然后使用命令“make”进行驱动的编译，编译完生成file.ko 目标文件，至此我们的驱动模块就编译成功了，下面进行应用程序编译.</p>
<h4 id="14-4-2-编译应用程序"><a href="#14-4-2-编译应用程序" class="headerlink" title="14.4.2 编译应用程序"></a>14.4.2 编译应用程序</h4><p>因为测试APP 是要在开发板上运行的，所以需要<code>aarch64-linux-gnu-gcc</code> 来编译，输入以下命令，编译完成以后会生成一个app 的可执行程序，如下图（图14-5）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc app.c <span class="token parameter variable">-o</span> app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下面进行驱动程序的测试。</p>
<h4 id="14-4-3-运行测试"><a href="#14-4-3-运行测试" class="headerlink" title="14.4.3 运行测试"></a>14.4.3 运行测试</h4><p>驱动模块file.ko 和测试程序app 都已经准备好了，接下来就是运行测试。首先输入以下命令加载驱动程序，如下图（图14–6）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod file.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141741661.png" alt="image-20240814174110604"></p>
<p>输入以下命令运行应用程序，如下图（图14-7）所示</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141741990.png" alt="image-20240814174119933"></p>
<p>由上图可知，打印“This is cdev_test_open”信息说明成功打开了字符设备驱动。<br>打印“ This is cdev_test_read”和“buf1 is This is cdev_test_read!”说明应用程序成功读取到内核的数据。<br>打印“This is cdev_test_write”和“kbuf is nihao”说明应用程序向内核写数据成功。<br>最后打印“This is cdev_test_release”说明卸载字符设备。</p>
<h2 id="第15-章文件私有数据实验"><a href="#第15-章文件私有数据实验" class="headerlink" title="第15 章文件私有数据实验"></a>第15 章文件私有数据实验</h2><p>在之前章节编写的驱动程序中，将生成字符设备的一些硬件属性（设备号、类、设备名称等）全都写成了变量的形式，虽然这样编写驱动代码不会产生报错，但是会显得有点不专业。通常在驱动开发中会为设备定义相关的设备结构体，将硬件属性的描述信息全部放在该结构体中，在本章节中将对设备结构体的功能实现和文件私有数据进行学习。</p>
<h3 id="15-1-文件私有数据简介"><a href="#15-1-文件私有数据简介" class="headerlink" title="15.1 文件私有数据简介"></a>15.1 文件私有数据简介</h3><p>Linux 中并没有明确规定要使用文件私有数据，但是在linux 驱动源码中，广泛使用了文件私有数据，这是Linux 驱动遵循的“潜规则”，实际上也体现了Linux 面向对象的思想。<code>struct file</code> 结构体中专门为用户留了一个域用于定义私有数据。结构体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token punctuation">{</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">llist_node</span> fu_llist<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> fu_rcuhead<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> f_u<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">path</span> f_path<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>f_inode<span class="token punctuation">;</span> <span class="token comment">/* cached value */</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>f_op<span class="token punctuation">;</span>
    
    
    <span class="token comment">/*
    * Protects f_ep_links, f_flags.
    * Must not be taken from IRQ context.
    */</span>
    <span class="token class-name">spinlock_t</span> f_lock<span class="token punctuation">;</span>
    <span class="token keyword">enum</span> <span class="token class-name">rw_hint</span> f_write_hint<span class="token punctuation">;</span>
    <span class="token class-name">atomic_long_t</span> f_count<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> f_flags<span class="token punctuation">;</span>
    <span class="token class-name">fmode_t</span> f_mode<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mutex</span> f_pos_lock<span class="token punctuation">;</span>
    <span class="token class-name">loff_t</span> f_pos<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">fown_struct</span> f_owner<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>f_cred<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file_ra_state</span> f_ra<span class="token punctuation">;</span>
    
    u64 f_version<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SECURITY</span></span>
    <span class="token keyword">void</span> <span class="token operator">*</span>f_security<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    <span class="token comment">/* needed for tty driver, and maybe others */</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>private_data<span class="token punctuation">;</span>						<span class="token comment">//私有数据</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_EPOLL</span></span>
    <span class="token comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_headf_ep_links</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_headf_tfile_llink</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* #ifdef CONFIG_EPOLL */</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>f_mapping<span class="token punctuation">;</span>
    <span class="token class-name">errseq_t</span> f_wb_err<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>文件私有数据的概念在Linux 驱动中有着非常广泛的应用，文件私有数据就是将私有数据<code>private_data</code> 指向设备结构体。通过它可以将私有数据一路从open 函数带到read, write 函数层层传入。一般是在open 的时候赋值，read、write 时使用。open 函数中私有数据的使用如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，定义了一个设备结构体<code>dev1</code>，然后在<code>open</code> 函数中，将私有数据<code>private_data</code>指向了设备结构体<code>dev1</code>。<br>我们可以在read write 函数中通过<code>private_data</code> 访问设备结构体，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> _user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token class-name">off_t</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="15-2-实验程序编写"><a href="#15-2-实验程序编写" class="headerlink" title="15.2 实验程序编写"></a>15.2 实验程序编写</h3><h4 id="15-2-1-驱动程序编写"><a href="#15-2-1-驱动程序编写" class="headerlink" title="15.2.1 驱动程序编写"></a>15.2.1 驱动程序编写</h4><p>本驱动程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\10\module</code>。<br>本章实验将编写Linux 下的使用文件私有数据实例代码，在open 函数中对私有数据结构体赋值，在write 函数中使用。编写完成的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>              <span class="token comment">//设备号</span>
    <span class="token keyword">int</span> major <span class="token punctuation">;</span>                         <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>                          <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span>  <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>         <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span>   <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">//缓存区buf</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span>  <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>  <span class="token comment">//定义一个device_test结构体变量</span>


<span class="token comment">/*打开设备函数*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span>  <span class="token comment">//设置私有数据</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_open\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*向设备写入数据函数*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span> <span class="token comment">//在write函数中读取private_data</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_from_user:用户空间向内核空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_write\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"kbuf is %s\r\n"</span><span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印kbuf的值</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_to_user:内核空间向用户空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_read\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_release\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>         <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span>         <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span>            <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> cdev_test_write<span class="token punctuation">,</span>         <span class="token comment">//将open字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span><span class="token comment">//将open字段指向chrdev_release(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chr_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
    dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
    <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*创建设备*/</span>
  dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chr_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>chr_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chr_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="15-2-2-编写测试APP"><a href="#15-2-2-编写测试APP" class="headerlink" title="15.2.2 编写测试APP"></a>15.2.2 编写测试APP</h4><p>本应用程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\10\app</code>。<br>编写测试APP 其实是在编写Linux 应用，在应用程序中向设备文件写入数据，编写完成的应用程序app.c 代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//主函数</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"nihao"</span><span class="token punctuation">;</span>  <span class="token comment">//定义写入缓存区buf1</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打开/dev/test设备</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf1<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向/dev/test设备写入数据</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="15-3-运行测试"><a href="#15-3-运行测试" class="headerlink" title="15.3 运行测试"></a>15.3 运行测试</h3><h4 id="15-3-1-编译驱动程序"><a href="#15-3-1-编译驱动程序" class="headerlink" title="15.3.1 编译驱动程序"></a>15.3.1 编译驱动程序</h4><p>在上一小节中的file.c 代码同一目录下创建Makefile 文件，Makefile 文件内容如下：然后使用命令“make”进行驱动的编译，编译完生成file.ko 目标文件，至此我们的驱动模块就编译成功了，下面进行应用程序编译，</p>
<h4 id="15-3-2-编译应用程序"><a href="#15-3-2-编译应用程序" class="headerlink" title="15.3.2 编译应用程序"></a>15.3.2 编译应用程序</h4><p>因为测试APP 是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc 来编译，输入以下命令，编译完成以后会生成一个app 的可执行程序，如下图（图15-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc app.c <span class="token parameter variable">-o</span> app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下面进行驱动程序的测试。</p>
<h4 id="15-3-3-运行测试"><a href="#15-3-3-运行测试" class="headerlink" title="15.3.3 运行测试"></a>15.3.3 运行测试</h4><p>驱动模块file.ko 和测试程序app 都已经准备好了，接下来就是运行测试。输入以下命令加载驱动程序</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">insmod file<span class="token punctuation">.</span>ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141756422.png" alt="image-20240814175600365"></p>
<p>驱动加载成功之后会生成/dev/test 设备驱动文件，输入以下命令查看杂项设备的主次设备号。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/test <span class="token parameter variable">-al</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>结果如下图（图15-6）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141756712.png" alt="image-20240814175626657"></p>
<p>运行应用程序，如下（图15-6）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408141756937.png" alt="image-20240814175638881"></p>
<p>在此实验中，将硬件属性的信息全部放在一个结构体private_data，依然可以实现字符设备的操作。</p>
<h2 id="第16-章一个驱动兼容不同设备实验"><a href="#第16-章一个驱动兼容不同设备实验" class="headerlink" title="第16 章一个驱动兼容不同设备实验"></a>第16 章一个驱动兼容不同设备实验</h2><p>在Linux 中，使用主设备号来表示对应某一类驱动，使用次设备号来表示这类驱动下的各个设备。假如现在驱动要支持的主设备号相同，但是次设备号不同的设备。驱动程序要怎样编写呢，上一章节学习的私有数据private_date 在此时就派上了用场，具体是怎样使用的呢，多个设备是如何在一个驱动中兼容的呢，带着疑问，让我们开始本章节的学习吧。</p>
<h3 id="16-1-container-of-函数简介"><a href="#16-1-container-of-函数简介" class="headerlink" title="16.1 container_of 函数简介"></a>16.1 container_of 函数简介</h3><p><code>container_of</code> 在Linux 内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是<strong>通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址</strong>。那么可以使用这个函数获取不同设备的地址，来对不同的设备进行操作，从而一个驱动可以兼容不同的设备。</p>
<p><strong><code>container_of</code></strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token function">container_of</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span>type<span class="token punctuation">,</span>member<span class="token punctuation">)</span>
函数作用：
    通过结构体变量中某个成员的首地址获取到整个结构体变量的首地址。
参数含义：
    ptr 是结构体变量中某个成员的地址。
    type 是结构体的类型
    member 是该结构体变量的具体名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>container_of 宏的作用是通过结构体内某个成员变量的地址和该变量名，以及结构体类型。找到该结构体变量的地址。</p>
<h3 id="16-2-实验程序编写"><a href="#16-2-实验程序编写" class="headerlink" title="16.2 实验程序编写"></a>16.2 实验程序编写</h3><h4 id="16-2-1-驱动程序编写"><a href="#16-2-1-驱动程序编写" class="headerlink" title="16.2.1 驱动程序编写"></a>16.2.1 驱动程序编写</h4><p>本驱动程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\11\module</code>。<br>本章实验将使用container_of 函数编写一个驱动兼容不同设备的实例代码，编写完成的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">device_test</span>
<span class="token punctuation">{</span>
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>             <span class="token comment">//设备号</span>
    <span class="token keyword">int</span> major<span class="token punctuation">;</span>                          <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor<span class="token punctuation">;</span>                         <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>        <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>   <span class="token comment">//定义一个device_test结构体变量dev1</span>
<span class="token keyword">struct</span> <span class="token class-name">device_test</span> dev2<span class="token punctuation">;</span>  <span class="token comment">//定义一个device_test结构体变量dev2</span>

<span class="token comment">/*打开设备函数*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//设置dev1的次设备号为0</span>
    dev2<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">//设置dev2的次设备号为1</span>

<span class="token comment">//inode-&gt;i_rdev 为该 inode 的设备号，使用container_of函数找到结构体变量dev1 dev2的地址</span>
<span class="token comment">//然后设置私有数据</span>
    file<span class="token operator">-&gt;</span>private_data <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>inode<span class="token operator">-&gt;</span>i_cdev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">,</span> cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_open\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*向设备写入数据函数*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

    <span class="token comment">//如果次设备号是0，则为dev1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>minor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_from_user:用户空间向内核空间传数据</span>
        <span class="token punctuation">{</span>
            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">" test_dev-&gt;kbuf is %s\r\n"</span><span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//如果次设备号是1，则为dev2</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>minor <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_from_user:用户空间向内核空间传数据</span>
        <span class="token punctuation">{</span>
            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">" test_dev-&gt;kbuf is %s\r\n"</span><span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_to_user:内核空间向用户空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_read\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_release\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数,定义file_operations结构体类型的变量cdev_test_fops*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> cdev_test_write<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_release(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chr_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号,,这里注册2个设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
    dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>

    <span class="token comment">//对设备1进行操作</span>
    <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
    <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*4 创建类*/</span>
    dev1<span class="token punctuation">.</span>class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*5 创建设备*/</span>
    dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev2<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
    dev2<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev2<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev2<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>

    <span class="token comment">//对设备2进行操作</span>
  <span class="token comment">/*2 初始化cdev*/</span>
    dev2<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev2<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
    <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev2<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*4 创建类*/</span>
    dev2<span class="token punctuation">.</span>class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*5  创建设备*/</span>
    dev2<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev2<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chr_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev2<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//删除设备</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev2<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev2<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">//删除类</span>
    
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>chr_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chr_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="16-2-2-编写测试APP"><a href="#16-2-2-编写测试APP" class="headerlink" title="16.2.2 编写测试APP"></a>16.2.2 编写测试APP</h4><p>本应用程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\11\app</code>。<br>编写应用程序，打开生成的俩个设备，并向俩个设备中写入数据，编写完成的应用程序app.c代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd1<span class="token punctuation">;</span>  <span class="token comment">//定义设备1的文件描述符</span>
    <span class="token keyword">int</span> fd2<span class="token punctuation">;</span>  <span class="token comment">//定义设备2的文件描述符</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"nihao /dev/test1"</span><span class="token punctuation">;</span>   <span class="token comment">//定义写入缓存区buf1</span>
    <span class="token keyword">char</span> buf2<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"nihao /dev/test2"</span><span class="token punctuation">;</span>   <span class="token comment">//定义写入缓存区buf2</span>
    fd1 <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test1"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开设备1：test1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd1 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd1<span class="token punctuation">,</span>buf1<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向设备1写入数据</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取消文件描述符到文件的映射</span>

    fd2<span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test2"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打开设备2：test2</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd2 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd2<span class="token punctuation">,</span>buf2<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向设备2写入数据</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//取消文件描述符到文件的映射</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="16-3-运行测试"><a href="#16-3-运行测试" class="headerlink" title="16.3 运行测试"></a>16.3 运行测试</h3><h4 id="16-3-1-编译驱动程序"><a href="#16-3-1-编译驱动程序" class="headerlink" title="16.3.1 编译驱动程序"></a>16.3.1 编译驱动程序</h4><p>在上一小节中的file.c 代码同一目录下创建Makefile 文件，Makefile 文件与前面保持一致：然后使用命令“make”进行驱动的编译，编译完生成file.ko 目标文件，至此我们的驱动模块就编译成功了，下面进行应用程序编译</p>
<h4 id="16-3-2-编译应用程序"><a href="#16-3-2-编译应用程序" class="headerlink" title="16.3.2 编译应用程序"></a>16.3.2 编译应用程序</h4><p>因为测试APP 是要在开发板上运行的，所以需要<code>aarch64-linux-gnu-gcc</code> 来编译，输入以下命令，编译完成以后会生成一个app 的可执行程序，如下图（图16-4）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">aarch64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">-</span>gcc app<span class="token punctuation">.</span>c <span class="token operator">-</span>o app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408150937416.png" alt="image-20240815093718307"></p>
<p>下面进行驱动程序的测试。</p>
<h4 id="16-3-2-运行测试"><a href="#16-3-2-运行测试" class="headerlink" title="16.3.2 运行测试"></a>16.3.2 运行测试</h4><p>驱动模块file.ko 和测试程序app 都已经准备好了，接下来就是运行测试。<br>输入以下命令加载驱动模块，如下图（图16-6）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod file.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408150937502.png" alt="image-20240815093752441"></p>
<p>驱动加载成功之后会生成<code>/dev/test1</code> 和<code>/dev/test2</code> 设备驱动文件，输入以下命令查看设备，可以看到一个驱动创建并管理了多个驱动设备，如下图（图16-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/test* <span class="token parameter variable">-al</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408150938897.png" alt="image-20240815093812836"></p>
<p>运行应用程序，如下（图16-10）所示:</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408150940929.png" alt="image-20240815094001862"></p>
<p>如上图所示，可以看到用户顺利向俩个设备写入数据，且每个设备拥有私有数据。</p>
<h2 id="第17-章Linux-错误处理实验"><a href="#第17-章Linux-错误处理实验" class="headerlink" title="第17 章Linux 错误处理实验"></a>第17 章Linux 错误处理实验</h2><p>在前面章节进行的字符设备驱动实验中，即使是最简单的注册字符设备，也存在注册失败的可能性，因此在之前编写的驱动代码中采用检查函数返回值的方式，确认函数是否成功执行，而在本章节中将采用<code>goto</code> 语句对Linux 错误处理进行更进一步的处理。</p>
<h3 id="17-1-goto-语句简介"><a href="#17-1-goto-语句简介" class="headerlink" title="17.1 goto 语句简介"></a>17.1 goto 语句简介</h3><p>在编写驱动程序时，驱动程序应该提供函数执行失败后处理的能力。如果驱动程序中函数执行失败了，必须取消掉所有失败前的注册，否则内核会处于一个不稳定的状态，因为它包含了不存在代码的内部指针。在处理Linux 错误时，最好使用goto 语句，goto 语句的使用示例如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> init <span class="token function">my_init_function</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">register_this</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">,</span> <span class="token string">"skull"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    	<span class="token keyword">goto</span> fail_this<span class="token punctuation">;</span>
    
    err <span class="token operator">=</span> <span class="token function">register_that</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">,</span> <span class="token string">"skull"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> fail_that<span class="token punctuation">;</span>
    
    err <span class="token operator">=</span> <span class="token function">register_those</span><span class="token punctuation">(</span>ptr3<span class="token punctuation">,</span> <span class="token string">"skull"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> fail_those<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    
    fail_those<span class="token operator">:</span>
    <span class="token function">unregister_that</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">,</span> <span class="token string">"skull"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    fail_that<span class="token operator">:</span>
    <span class="token function">unregister_this</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">,</span> <span class="token string">"skull"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    fail_this<span class="token operator">:</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在以上代码中试图注册3 个虚构设备，goto 语句在失败情况下使用，对之前已经成功注册的设施进行注销。使用goto 语句处理的时候，应该遵循“先进后出”的原则，如下图（图17-1）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408150944099.png" alt="image-20240815094459038" style="zoom:80%;">

<p>如果在驱动代码中初始化和卸载函数比较复杂，goto 方法可能变得难于管理，为了使代码重复性最小以及流程化，Linux 提供了更简便的方法，我们接着来学习下一小节。</p>
<h3 id="17-2-IS-ERR-简介"><a href="#17-2-IS-ERR-简介" class="headerlink" title="17.2 IS_ERR()简介"></a>17.2 IS_ERR()简介</h3><p>对于任何一个指针来说，必然存在三种情况，一种是合法指针，一种是NULL(也就是空指针)，一种是错误指针(也就是无效指针)。在Linux 内核中，所谓的错误指针已经指向了内核空间的最后一页，例如，对于一个64 位系统来说，内核空间最后地址为0xffffffffffffffff，那么最后一页的地址是0xfffffffffffff000~0xffffffffffffffff，这段地址是被保留的，如果指针落在这段地<br>址之内，说明是错误的无效指针。</p>
<p>在Linux 内核源码中实现了指针错误的处理机制，相关的函数接口主要有<code>IS_ERR()</code>、<code>PTR_ERR()</code>、<code>ERR_PTR()</code>等，其函数的源码在<code>include/linux/err.h</code> 文件中，如下所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408150946620.png" alt="image-20240815094609549"></p>
<p>如上图所示，在Linux 源码中IS_ERR()函数其实就是判断指针是否出错，如果指针指向了内核空间的最后一页，就说明指针是一个无效指针，如果指针并不是落在内核空间的最后一页，就说明这指针是有效的。无效的指针能表示成一种负数的错误码，如果想知道这个指针是哪个错误码，使用PTR_ERR 函数转化。0xfffffffffffff000~0xffffffffffffffff 这段地址和Linux 错误码是一一对应的，内核错误码保存在errno-base.h 文件中。如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_ASM_GENERIC_ERRNO_BASE_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_ASM_GENERIC_ERRNO_BASE_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPERM</span> 		<span class="token expression"><span class="token number">1</span> </span><span class="token comment">/* Operation not permitted */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENOENT</span> 		<span class="token expression"><span class="token number">2</span> </span><span class="token comment">/* No such file or directory */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ESRCH</span> 		<span class="token expression"><span class="token number">3</span> </span><span class="token comment">/* No such process */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EINTR</span> 		<span class="token expression"><span class="token number">4</span> </span><span class="token comment">/* Interrupted system call */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EIO</span> 		<span class="token expression"><span class="token number">5</span> </span><span class="token comment">/* I/O error */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENXIO</span> 		<span class="token expression"><span class="token number">6</span> </span><span class="token comment">/* No such device or address */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">E2BIG</span> 		<span class="token expression"><span class="token number">7</span> </span><span class="token comment">/* Argument list too long */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENOEXEC</span> 	<span class="token expression"><span class="token number">8</span> </span><span class="token comment">/* Exec format error */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EBADF</span> 		<span class="token expression"><span class="token number">9</span> </span><span class="token comment">/* Bad file number */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ECHILD</span> 		<span class="token expression"><span class="token number">10</span> </span><span class="token comment">/* No child processes */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EAGAIN</span> 		<span class="token expression"><span class="token number">11</span> </span><span class="token comment">/* Try again */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENOMEM</span> 		<span class="token expression"><span class="token number">12</span> </span><span class="token comment">/* Out of memory */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EACCES</span> 		<span class="token expression"><span class="token number">13</span> </span><span class="token comment">/* Permission denied */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EFAULT</span> 		<span class="token expression"><span class="token number">14</span> </span><span class="token comment">/* Bad address */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENOTBLK</span> 	<span class="token expression"><span class="token number">15</span> </span><span class="token comment">/* Block device required */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EBUSY</span> 		<span class="token expression"><span class="token number">16</span> </span><span class="token comment">/* Device or resource busy */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EEXIST</span> 		<span class="token expression"><span class="token number">17</span> </span><span class="token comment">/* File exists */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXDEV</span> 		<span class="token expression"><span class="token number">18</span> </span><span class="token comment">/* Cross-device link */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENODEV</span> 		<span class="token expression"><span class="token number">19</span> </span><span class="token comment">/* No such device */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENOTDIR</span> 	<span class="token expression"><span class="token number">20</span> </span><span class="token comment">/* Not a directory */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EISDIR</span> 		<span class="token expression"><span class="token number">21</span> </span><span class="token comment">/* Is a directory */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EINVAL</span> 		<span class="token expression"><span class="token number">22</span> </span><span class="token comment">/* Invalid argument */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENFILE</span> 		<span class="token expression"><span class="token number">23</span> </span><span class="token comment">/* File table overflow */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EMFILE</span> 		<span class="token expression"><span class="token number">24</span> </span><span class="token comment">/* Too many open files */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENOTTY</span> 		<span class="token expression"><span class="token number">25</span> </span><span class="token comment">/* Not a typewriter */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ETXTBSY</span> 	<span class="token expression"><span class="token number">26</span> </span><span class="token comment">/* Text file busy */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EFBIG</span> 		<span class="token expression"><span class="token number">27</span> </span><span class="token comment">/* File too large */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENOSPC</span> 		<span class="token expression"><span class="token number">28</span> </span><span class="token comment">/* No space left on device */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ESPIPE</span> 		<span class="token expression"><span class="token number">29</span> </span><span class="token comment">/* Illegal seek */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EROFS</span> 		<span class="token expression"><span class="token number">30</span> </span><span class="token comment">/* Read-only file system */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EMLINK</span> 		<span class="token expression"><span class="token number">31</span> </span><span class="token comment">/* Too many links */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EPIPE</span> 		<span class="token expression"><span class="token number">32</span> </span><span class="token comment">/* Broken pipe */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EDOM</span> 		<span class="token expression"><span class="token number">33</span> </span><span class="token comment">/* Math argument out of domain of func */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERANGE</span> 		<span class="token expression"><span class="token number">34</span> </span><span class="token comment">/* Math result not representable */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>那么如何判断函数返回的指针是有效地址还是错误码呢？对于<code>IS_ERR()</code>的使用，实例代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">myclass <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"myclass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>myclass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ret <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>myclass<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">goto</span> fail<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

mydevice <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>myclass<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">MKDEV</span><span class="token punctuation">(</span>major<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"simple-device"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>mydevice<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>myclass<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>mydevice<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">goto</span> fail<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，调用了<code>class_create()</code>和<code>device_create()</code>函数，必须使用<code>IS_ERR()</code>函数判断返回的指针是否是有效的，如果是无效的，需要调用<code>PTR_ERR()</code>函数将无效指针转换为错误码，并进行错误码的返回。</p>
<h3 id="17-3-实验程序编写"><a href="#17-3-实验程序编写" class="headerlink" title="17.3 实验程序编写"></a>17.3 实验程序编写</h3><h4 id="17-3-1-驱动程序编写"><a href="#17-3-1-驱动程序编写" class="headerlink" title="17.3.1 驱动程序编写"></a>17.3.1 驱动程序编写</h4><p>本驱动程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\12\module</code>。</p>
<p>本实验在15 章的驱动程序基础上进行编写，进行Linux 错误处理实验。当创建设备号，初始化cdev，注册字符设备，创建类，创建设备的这些函数执行失败时，应该怎么处理呢，编写好的驱动程序如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
     <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//定义缓存区kbuf</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span>  <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>   <span class="token comment">//定义一个device_test结构体变量</span>


<span class="token comment">/*打开设备函数*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span>  <span class="token comment">//设置私有数据</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_open\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*向设备写入数据函数*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_from_user:用户空间向内核空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_write\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"kbuf is %s\r\n"</span><span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    
    <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_to_user:内核空间向用户空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_read\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_release\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> cdev_test_write<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_release(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chr_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
        <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
    dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*创建设备*/</span>
  dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

 err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>

err_class_create<span class="token operator">:</span>
       <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>

err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>

err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chr_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>chr_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chr_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="17-3-2-编写测试APP"><a href="#17-3-2-编写测试APP" class="headerlink" title="17.3.2 编写测试APP"></a>17.3.2 编写测试APP</h4><p>本应用程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\12\app</code>。<br>编写应用程序app.c，完成的应用程序app.c 代码如下所示，应用程序只是起简单的测试作用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//主函数</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"nihao"</span><span class="token punctuation">;</span>  <span class="token comment">//定义写入缓存区buf1</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打开/dev/test设备</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf1<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向/dev/test设备写入数据</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="17-4-运行测试"><a href="#17-4-运行测试" class="headerlink" title="17.4 运行测试"></a>17.4 运行测试</h3><h4 id="17-4-1-编译驱动程序"><a href="#17-4-1-编译驱动程序" class="headerlink" title="17.4.1 编译驱动程序"></a>17.4.1 编译驱动程序</h4><p>在上一小节中的file.c 代码同一目录下创建Makefile 文件，Makefile 文件内容用之前的，然后使用命令“make”进行驱动的编译，编译完生成file.ko 目标文件，至此我们的驱动模块就编译成功了。</p>
<h4 id="17-4-2-编译应用程序"><a href="#17-4-2-编译应用程序" class="headerlink" title="17.4.2 编译应用程序"></a>17.4.2 编译应用程序</h4><p>下面进行应用程序编译， 因为测试APP 是要在开发板上运行的， 所以需要<code>aarch64-linux-gnu-gcc</code> 来编译，输入以下命令，编译完成以后会生成一个app 的可执行程序，如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc app.c <span class="token parameter variable">-o</span> app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下面进行驱动程序的测试。</p>
<h4 id="17-4-3-运行测试"><a href="#17-4-3-运行测试" class="headerlink" title="17.4.3 运行测试"></a>17.4.3 运行测试</h4><p>驱动模块file.ko 和测试程序app 都已经准备好了，接下来就是运行测试。输入以下命令，加载驱动程序，如下图（图17-6）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151008353.png" alt="image-20240815100842288"></p>
<p>运行应用程序如下（图17-7）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151008215.png" alt="image-20240815100852149"></p>
<p>卸载驱动程序，如下图（图17-8）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151009980.png" alt="image-20240815100901919"></p>
<h2 id="第18-章-点亮LED-灯实验-GPIO基础知识"><a href="#第18-章-点亮LED-灯实验-GPIO基础知识" class="headerlink" title="第18 章 点亮LED 灯实验(GPIO基础知识)"></a>第18 章 点亮LED 灯实验(GPIO基础知识)</h2><p>经过前面章节的学习，我们已经对字符设备相关的知识进行了学习和实验，但实际上并没有涉及到对硬件的操作，而在本小节中将通过字符设备驱动及相关的应用程序对LED 灯进行控制，通过对硬件的实际操作，从而对之前学习到的知识进行整合与回顾。</p>
<h3 id="18-1-查看原理图"><a href="#18-1-查看原理图" class="headerlink" title="18.1 查看原理图"></a>18.1 查看原理图</h3><p>首先打开底板原理图，如下图（图18-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151010173.png" alt="image-20240815101011101"></p>
<p>由上图可以看出，LED 灯是由<code>GPIO0_B7</code> 控制的。当GPIO0_B7 为高电平时，三极管Q16导通，LED9 点亮。当GPIO0_B7 为低电平时，三极管Q16 截止，LED9 不亮。</p>
<h3 id="18-2-查询寄存器地址"><a href="#18-2-查询寄存器地址" class="headerlink" title="18.2 查询寄存器地址"></a>18.2 查询寄存器地址</h3><p>在上一小节，我们查询到了控制LED 灯的GPIO 为GPIO0_B7。在接下来的实验中需要对GPIO 进行配置，一般情况下需要对GPIO 的<strong>复用寄存器，方向寄存器，数据寄存器</strong>进行配置。接下来我们打开RK3568 的参考手册part1 查找这几个寄存器的地址。</p>
<p><strong>查找复用寄存器</strong></p>
<p>打开参考手册part1 的第三章，GPIOB 的<strong>复用寄存器</strong>的偏移地址如下（图18-2）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151012938.png" alt="image-20240815101240858"></p>
<p>搜索<code>gpio0b7</code>，如下图（图18-3）所示，gpio0b7_sel 在<code>PMU_GRF_GPIO0B_IOMUX_H</code> 上，所以偏移地址为<code>0x000C</code>。<code>gpio0b7</code> 可以通过控制[14:12]位来选择复用为哪个功能，我们要控制led 灯，所以功能要复用为gpio。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151014424.png" alt="image-20240815101446338"></p>
<p>复用寄存器的基地址如下图(图18-4)所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151015080.png" alt="image-20240815101537999"></p>
<p>所以<strong>复用寄存器地址=基地址+偏移地址=<code>0xFDC2000C</code></strong> 。使用<code>io</code> 命令查看此寄存器的地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">io <span class="token parameter variable">-r</span> <span class="token parameter variable">-4</span> 0xFDC2000C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151016904.png" alt="image-20240815101621842"></p>
<p>如上图(图18-5)所示，寄存器值为00000001，[14:12]位为000，如下图（图18-6）所示，所以默认设置的为gpio 功能。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151016521.png" alt="image-20240815101647450"></p>
<p><strong>查找方向寄存器</strong></p>
<p>打开参考手册part1 的第16 章节，数据寄存器的偏移地址如下图（图18-7）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151017894.png" alt="image-20240815101704802"></p>
<p>GPIO 有四组GPIO，分别是GPIOA，GPIOB，GPIOC，GPIOD。每组又以A0<del>A7, B0</del>B7, C0<del>C7, D0</del>D7 作为编号区分。GPIO0B7 在<code>GPIO_SWPORT_DDR_L</code> 上所以，方向寄存器的偏移地址为0x0008。接着查看<code>GPIO_SWPORT_DDR_L</code> 寄存器的具体描述，如下图（图18-8）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151023343.png" alt="image-20240815102343259"></p>
<p>如上图（图18-8）所示，[31:16]位属性是WO，也就是只可写入。这[31:16]位是写标志位，是低16 位的写使能。如果低16 位中某一位要设置输入输入输出，则对应高位写标志也应该设置为1。[15：0] 是数据方向控制寄存器低位，如果要设置某个GPIO 为输出，则对应位置1，如果要设置某个GPIO 为输入，则对应位置0。那么GPIO0 B7 ，我们要设置第15 位为输入还是输出，那么对应的[31:16]位写使能也要置1。</p>
<p>打开参考手册part1 的1.1 小节Address Mapping。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151024739.png" alt="image-20240815102406649"></p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151024392.png" alt="image-20240815102415311"></p>
<p>如上图（图18-10）所示，GPIO0 的基地址为0xFDD60000。<strong>方向寄存器的地址=基地址+偏移地址=0xFDD60000+0x0008=0xFDD60008</strong><br>然后使用IO 命令查看该寄存器的值，如下（图18-11）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151024412.png" alt="image-20240815102457349"></p>
<p>如下图（图18-11）所示，第15 位默认为1，设置GPIO0_B7 为输出。</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151025272.png" alt="image-20240815102514204" style="zoom:80%;">

<p>查找数据寄存器</p>
<p>打开参考手册part1 的1.1 小节Address Mapping。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151025275.png" alt="image-20240815102533184"></p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151025128.png" alt="image-20240815102538048"></p>
<p>如上图（图18-13）所示，GPIO0 的基地址为0xFDD60000。<br>数据寄存器的偏移地址如下（图18-14）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151026941.png" alt="image-20240815102601867"></p>
<p>所以数据寄存器的地址为基地址+偏移地址=0xFDD60000。使用IO 命令查看地址的值，如下（图18-15）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151026957.png" alt="image-20240815102624896"></p>
<p>我们来看一下这个数据寄存器的描述，如下图（图18-16）所示，</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151026416.png" alt="image-20240815102636328"></p>
<p>分析上图的方法和在分析方向寄存器的方法同理，由上图可知，如果要控制第15 位为高电平（置1），需要设置31 位为1，那么点亮灯，需要向数据寄存器写入0x8000c040，如下图（图18-17）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151027636.png" alt="image-20240815102700563" style="zoom:67%;">

<p>如果要灭灯，需要设置第15 位为0 ，第31 位为1，那么向数据寄存器中写入0x80004040，如下图（图18-18）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151027516.png" alt="image-20240815102716444" style="zoom:67%;">

<p><strong>总结</strong></p>
<ul>
<li><strong>复用关系寄存器</strong>的基地址为<code>0xFDC20000</code> ，偏移地址为<code>000C</code> ，所以要操作的地址为<code>基地址+偏移地址=0xFDC2000C</code></li>
<li>GPIO 的基地址为<code>0xFDD60000</code>，偏移地址为<code>0x0008</code>，所以<strong>方向寄存器</strong>要操作的地址为<code>基地址+偏移地址=0xFDD60008</code></li>
<li>GPIO 的基地址为<code>0xFDD60000</code>，偏移地址为<code>0x0000</code>，所以<strong>数据寄存器</strong>要操作的地址为<code>基地址+偏移地址=0xFDD60000</code></li>
<li>默认的数据寄存器的值：<code>0x8000c040</code> 亮灯，<code>0x80004040</code> 灭灯18.3 实验程序编写</li>
</ul>
<h3 id="18-3-实验程序编写"><a href="#18-3-实验程序编写" class="headerlink" title="18.3 实验程序编写"></a>18.3 实验程序编写</h3><h4 id="18-3-1-驱动程序编写"><a href="#18-3-1-驱动程序编写" class="headerlink" title="18.3.1 驱动程序编写"></a>18.3.1 驱动程序编写</h4><p>本驱动程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\13\module</code>。<br>本次实验在15 章的驱动程序基础上进行编写，通过在应用层传入0/1 数据到内核，如果传入数据是1，则设置GPIO 的数据寄存器值为0x8000c040，如果应用层传入0，则设置GPIO的数据寄存器值为0x80004040，这样就可以达到控制led 的效果， 编写好的驱动程序file.c如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/io.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">GPIO_DR</span> <span class="token expression"><span class="token number">0xFDD60000</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>
   
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
     <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>vir_gpio_dr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span>  <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>  


<span class="token comment">/*打开设备函数*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span><span class="token comment">//设置私有数据</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_open\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*向设备写入数据函数*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_from_user:用户空间向内核空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//如果应用层传入的数据是1，则打开灯</span>
            <span class="token operator">*</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>vir_gpio_dr<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x8000c040</span><span class="token punctuation">;</span>   <span class="token comment">//设置数据寄存器的地址</span>
              <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"test_dev-&gt;kbuf [0]  is %d\n"</span><span class="token punctuation">,</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打印传入的数据</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">//如果应用层传入的数据是0，则关闭灯</span>
    <span class="token punctuation">{</span>
            <span class="token operator">*</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>vir_gpio_dr<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x80004040</span><span class="token punctuation">;</span> <span class="token comment">//设置数据寄存器的地址</span>
            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"test_dev-&gt;kbuf [0]  is %d\n"</span><span class="token punctuation">,</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印传入的数据</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    
    <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_to_user:内核空间向用户空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_read\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_release\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> cdev_test_write<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_release(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chr_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
   dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*5  创建设备*/</span>
  dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">/*本实验重点*****/</span>
    dev1<span class="token punctuation">.</span>vir_gpio_dr<span class="token operator">=</span><span class="token function">ioremap</span><span class="token punctuation">(</span>GPIO_DR<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将物理地址转化为虚拟地址</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>vir_gpio_dr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>vir_gpio_dr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//PTR_ERR()来返回错误代码</span>
        <span class="token keyword">goto</span> err_ioremap<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

err_ioremap<span class="token operator">:</span>
        <span class="token function">iounmap</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>vir_gpio_dr<span class="token punctuation">)</span><span class="token punctuation">;</span>

err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>

err_class_create<span class="token operator">:</span>
       <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>

err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>

err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chr_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>chr_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chr_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>18.3.2 编写测试APP<br>本应用程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\13\app</code>。</p>
<p>编写测试app,led 驱动加载成功之后会生成<code>/dev/test</code> 节点，应用程序APP 通过操作/dev/test文件来完成对LED 设备的控制。向/dev/test 文件写入0 表示关闭LED 灯，写入1 表示打开LED灯。编写完成的应用程序app.c 代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开led驱动</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// atoi()将字符串转为整型，这里将第一个参数转化为整型后，存放在 buf[0]中</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向/dev/test文件写入数据</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//关闭文件</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="18-4-运行测试"><a href="#18-4-运行测试" class="headerlink" title="18.4 运行测试"></a>18.4 运行测试</h3><h4 id="18-4-1-编译驱动程序"><a href="#18-4-1-编译驱动程序" class="headerlink" title="18.4.1 编译驱动程序"></a>18.4.1 编译驱动程序</h4><p>在上一小节中的file.c 代码同一目录下创建Makefile 文件，Makefile 文件内容用之前的：然后使用命令“make”进行驱动的编译，编译完生成file.ko 目标文件，</p>
<h4 id="18-4-2-编译应用程序"><a href="#18-4-2-编译应用程序" class="headerlink" title="18.4.2 编译应用程序"></a>18.4.2 编译应用程序</h4><p>至此我们的驱动模块就编译成功了，下面进行应用程序编译，因为测试APP 是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc 来编译，输入以下命令，编译完成以后会生成一个app 的可执行程序，如下图（图18-21）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">aarch64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">-</span>gcc app<span class="token punctuation">.</span>c <span class="token operator">-</span>o app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下面进行驱动程序的测试。</p>
<h4 id="18-4-3-运行测试"><a href="#18-4-3-运行测试" class="headerlink" title="18.4.3 运行测试"></a>18.4.3 运行测试</h4><p>驱动模块file.ko 和测试程序app 都已经准备好了，接下来就是运行测试。输入以下命令加载驱动程序，如下（图18-22）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod file.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151036522.png" alt="image-20240815103646449"></p>
<p>然后运行测试程序，输入“./app 1”，LED 灯点亮，如下图（图18-24）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151037221.png" alt="image-20240815103700151"></p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151037021.png" alt="image-20240815103707877" style="zoom:50%;">

<p>输入“./app 0”,LED 灯熄灭，如下图（图18-26）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151037470.png" alt="image-20240815103720400"></p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151037109.png" alt="image-20240815103724995" style="zoom:50%;">

<h1 id="第三篇并发与竞争"><a href="#第三篇并发与竞争" class="headerlink" title="第三篇并发与竞争"></a>第三篇并发与竞争</h1><h2 id="第19-章并发与竞争实验"><a href="#第19-章并发与竞争实验" class="headerlink" title="第19 章并发与竞争实验"></a>第19 章并发与竞争实验</h2><p>在前面章节的学习中，相信大家已经对用户空间与内核空间数据传递进行了实验，假如要传递的数据被存放在了全局变量，该数据就可以作为共享资源被多个任务共同读写，从而造成数据的错误传输，多个程序同时访问一个共享资源产生的问题就叫做竞争。竞争产生的根本原因就是Linux 系统的并发访问。</p>
<p>在本章节中首先会对并发与并行的概念进行讲解，随后对竞争产生的原因进行总结，最后以一个实际的竞争实验加深大家的理解。下面就让我们开始本章节的学习吧。</p>
<h3 id="19-1-并发与竞争"><a href="#19-1-并发与竞争" class="headerlink" title="19.1 并发与竞争"></a>19.1 并发与竞争</h3><h4 id="19-1-1-并发"><a href="#19-1-1-并发" class="headerlink" title="19.1.1 并发"></a>19.1.1 并发</h4><p>早期计算机大多只有一个CPU 核心，一个CPU 在同一时间只能执行一个任务，当系统中有多个任务等待执行时，CPU 只能执行完一个再执行下一个。而计算机的很多指令会涉及I/O操作，执行速度远远低于CPU 内高速存储器的存取速度，这就导致CPU 经常处于空闲状态，只能等待I/O 操作完成后才能继续执行后面的指令。为了提高CPU 利用率，减少等待时间，提出了CPU 并发工作理论。</p>
<p>所谓并发，就是通过算法将CPU 资源合理地分配给多个任务，当一个任务执行I/O 操作时，CPU 可以转而执行其它的任务，等到I/O 操作完成以后，或者新的任务遇到I/O 操作时，CPU 再回到原来的任务继续执行。</p>
<p>下图（图19-1）展示了两个任务并发执行的过程（<strong>为了容易理解，这里以两个任务并发执行为例，当然一个CPU 核心并不仅仅只能两个任务并发</strong>）：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151041785.png" alt="image-20240815104101714"></p>
<p>虽然CPU 在同一时刻只能执行一个任务，但是通过将CPU 的使用权在恰当的时机分配给不同的任务，使得多个任务看起来是一起执行的（CPU 的执行速度极快，多任务切换的时间也极短）。至此关于并发的概念就讲解完成了。</p>
<h4 id="19-1-2-并行"><a href="#19-1-2-并行" class="headerlink" title="19.1.2 并行"></a>19.1.2 并行</h4><p>并发是针对单核CPU 提出的，而并行则是针对多核CPU 提出的。和单核CPU 不同，多核CPU 真正实现了“同时执行多个任务”。多核CPU 的每个核心都可以独立地执行一个任务，而且多个核心之间不会相互干扰。在不同核心上执行的多个任务，是真正地同时运行，这种状态就叫做并行。双核CPU 的工作状态如下图（图19-2）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151041696.png" alt="image-20240815104149618"></p>
<p>双核CPU 执行两个任务时，每个核心各自执行一个任务，和单核CPU 在两个任务之间不断切换相比，它的执行效率更高。<br>至此对于并行的概念就讲解完成了。</p>
<h4 id="19-1-3-并发-并行"><a href="#19-1-3-并发-并行" class="headerlink" title="19.1.3 并发+并行"></a>19.1.3 并发+并行</h4><p>在并行的工作状态中，两个CPU 分别执行两个任务，是一种理想状态。但是在实际场景中，处于运行状态的任务是非常多的，以实际办公电脑为例，windows 系统在开机之后会运行几十个任务，而CPU 往往只有4 核、8 核等，远远低于任务的数量，这个时候就会同时存在并发和并行两种情况，即所有核心在并行工作的同时，每个核心还要并发工作。<br>例如一个双核CPU 要执行四个任务，它的工作状态如下图（图19-3）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151042885.png" alt="image-20240815104227812"></p>
<p>为了容易理解，这里是以两个任务并发执行为例，当然一个CPU 核心并不仅仅只能两个任务并发，并发任务的数量和操作系统的分配方式、以及每个任务的工作状态有关系。<br>至此，对于并发+并行的概念讲解就结束了。</p>
<p>并发可以看作是并行的理想状态，为了便于讲解和避免产生歧义，之后的章节无论是并发还是并行，都会统称为并发。</p>
<h4 id="19-1-4-竞争"><a href="#19-1-4-竞争" class="headerlink" title="19.1.4 竞争"></a>19.1.4 竞争</h4><p>并发可能会造成多个程序同时访问一个共享资源，这时候由并发同时访问一个共享资源产生的问题就叫做竞争。<br>竞争产生的原因如下所示：</p>
<ul>
<li>（1）多线程的并发访问。由于Linux 是多任务操作系统，所以多线程访问是竞争产生的基本原因。</li>
<li>（2）中断程序的并发访问。中断任务产生后，CPU 会立刻停止当前工作，从而去执行中断中的任务，如果中断任务对共享资源进行了修改，就会产生竞争。</li>
<li>（3）抢占式并发访问。linux2.6 及更高版本引入了抢占式内核，高优先级的任务可以打断低优先级的任务。在线程访问共享资源的时候，另一个线程打断了现在正在访问共享资源的线程同时也对共享资源进行操作，从而造成了竞争。</li>
<li>（4）多处理器(SMP）并发访问。多核处理器之间存在核间并发访问。</li>
</ul>
<h4 id="19-1-5-共享资源的保护"><a href="#19-1-5-共享资源的保护" class="headerlink" title="19.1.5 共享资源的保护"></a>19.1.5 共享资源的保护</h4><p>竞争是由并发访问同一个共享资源产生的。为了防止“竞争”的产生就要对共享资源进行保护，这里提到的共享资源又是什么呢？<br>以实际生活中的共享资源为例，可以是公共电话，也可以是共享单车、共享充电宝等公共物品，以上都属于共享资源的范畴，以公共电话为例，每个人都可以对它进行使用，但在同一时间内只能由一个人进行使用，如果两个人都要对电话进行使用，则产生了竞争。而在实际的驱动的代码中，共享资源可以是全局变量，也可以是驱动中的设备结构体等，需要根据具体的驱动程序来进行分析。在下一小节的实验中，会以全局变量为例，进行并发与竞争实验。</p>
<h3 id="19-2-实验程序的编写"><a href="#19-2-实验程序的编写" class="headerlink" title="19.2 实验程序的编写"></a>19.2 实验程序的编写</h3><h3 id="19-2-1-驱动程序编写"><a href="#19-2-1-驱动程序编写" class="headerlink" title="19.2.1 驱动程序编写"></a>19.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\14\module</code>。<br>本实验将编写并发与竞争的驱动代码， 首先完善字符设备驱动框架， 然后通过<code>copy_from_user(...)</code>函数接收用户空间传递到内核空间的数据并进行判断，如果接收到的字符串数据为“topeet”会在睡眠4 秒钟后打印接收到的数据，如果接收到的字符串数据为“itop”会在睡眠2 秒钟后打印接收到的数据。</p>
<p>编写完成的example.c 代码如下所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">open_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is open_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">read_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	<span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"topeet"</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串变量kbuf</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is read_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span>ubuf<span class="token punctuation">,</span>kbuf<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_to_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串全局变量kbuf</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">write_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span>ubuf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_from_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是topeet就睡眠四秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是itop就睡眠两秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user buf is %s \n"</span><span class="token punctuation">,</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">release_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//printk("\nthis is release_test \n");</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> <span class="token punctuation">{</span>
       <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span><span class="token comment">//定义dev_t类型变量dev_num来表示设备号</span>
       <span class="token keyword">int</span> major<span class="token punctuation">,</span>minor<span class="token punctuation">;</span><span class="token comment">//定义int类型的主设备号major和次设备号minor</span>
       <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span><span class="token comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span>
       <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class_test<span class="token punctuation">;</span><span class="token comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> dev1<span class="token punctuation">;</span><span class="token comment">//创建chrdev_test类型的</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> fops_test <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
      <span class="token punctuation">.</span>open <span class="token operator">=</span> open_test<span class="token punctuation">,</span><span class="token comment">//将open字段指向open_test(...)函数</span>
      <span class="token punctuation">.</span>read <span class="token operator">=</span> read_test<span class="token punctuation">,</span><span class="token comment">//将read字段指向read_test(...)函数</span>
      <span class="token punctuation">.</span>write <span class="token operator">=</span> write_test<span class="token punctuation">,</span><span class="token comment">//将write字段指向write_test(...)函数</span>
      <span class="token punctuation">.</span>release <span class="token operator">=</span> release_test<span class="token punctuation">,</span><span class="token comment">//将release字段指向release_test(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">atomic_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_name"</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//自动获取设备号，设备名chrdev_name</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MAJOR()函数获取主设备号</span>
	dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MINOR()函数获取次设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d,minor is %d\n"</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>major<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span><span class="token operator">&amp;</span>fops_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span>
	dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	<span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_add()函数进行字符设备的添加</span>
	dev1<span class="token punctuation">.</span>class_test <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span><span class="token string">"class_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用class_create进行类的创建，类名称为class_test</span>
	<span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"device_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用device_create进行设备的创建，设备名称为device_test</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">atomic_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的设备</span>
	<span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的类</span>
	<span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除添加的字符设备cdev_test</span>
	<span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放字符设备所申请的设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>atomic_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>atomic_exit<span class="token punctuation">)</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于重要逻辑部分已经加粗，后续章节的实验都是对上述并发与竞争实验的改进，以不同的方式来避免竞争的产生。</p>
<h4 id="19-2-2-编写测试APP"><a href="#19-2-2-编写测试APP" class="headerlink" title="19.2.2 编写测试APP"></a>19.2.2 编写测试APP</h4><p>本实验应用程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\14\app</code>。<br>本测试app 较为简单，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c 内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//定义int类型的文件描述符</span>
	<span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义读取缓冲区str1</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open failed \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="19-3-运行测试"><a href="#19-3-运行测试" class="headerlink" title="19.3 运行测试"></a>19.3 运行测试</h3><h4 id="19-3-1-编译驱动程序"><a href="#19-3-1-编译驱动程序" class="headerlink" title="19.3.1 编译驱动程序"></a>19.3.1 编译驱动程序</h4><p>在上一小节中的example.c 代码同一目录下创建Makefile 文件，Makefile 文件内容同上，然后使用命令“make”进行驱动的编，编译完生成example.ko 目标文件，至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h4 id="19-3-2-编译应用程序"><a href="#19-3-2-编译应用程序" class="headerlink" title="19.3.2 编译应用程序"></a>19.3.2 编译应用程序</h4><p>来到应用程序app.c 文件的存放路径如下图（图19-7）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151053695.png" alt="image-20240815105333625"></p>
<p>然后使用以下命令对app.c 进行交叉编译，编译完成如下图（图19-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> app app.c <span class="token parameter variable">-static</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151053804.png" alt="image-20240815105355732"></p>
<p>生成的app 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="19-3-3-运行测试"><a href="#19-3-3-运行测试" class="headerlink" title="19.3.3 运行测试"></a>19.3.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图19-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod example.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151055054.png" alt="image-20240815105541977"></p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test 进行查看，如下图（图19-10）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/device_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151056793.png" alt="image-20240815105612721"></p>
<p>可以看到device_test 节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图19-11）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app /dev/device_test topeet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151056196.png" alt="image-20240815105643121"></p>
<p>可以看到传递的buf 值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图19-12）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app /dev/device_test topeet <span class="token operator">&amp;</span>
./app /dev/device_test itop <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151057967.png" alt="image-20240815105722883"></p>
<p>在不存在竞争的情况下，传递的两个字符串数据应该是topeet 和itop，而在上图中的打印信息为两个itop，原因是第二个app 应用程序运行之后对共享资源进行了修改，两个app 应用程序就产生了竞争关系，会在之后的章节中使用不同的方法对上述驱动程序进行改进，从而避免竞争的产生。<br>最后可以使用以下命令进行驱动的卸载，如下图（图19-13）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod example.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151058725.png" alt="image-20240815105803647"></p>
<p>至此，并发与竞争的实验就完成了。</p>
<h2 id="第20-章原子操作实验"><a href="#第20-章原子操作实验" class="headerlink" title="第20 章原子操作实验"></a>第20 章原子操作实验</h2><p>在上一章节的实验中，对并发与竞争进行了实验，两个app 应用程序之间对共享资源的竞争访问引起了数据传输错误，而在Linux 内核中，提供了四种处理并发与竞争的常见方法，分别是原子操作、自旋锁、信号量、互斥体，在之后的几个章节中会依次对上述四种方法进行讲解。<br>本章首先对四种常见方法中的原子操作进行讲解。</p>
<h3 id="20-1-原子操作"><a href="#20-1-原子操作" class="headerlink" title="20.1 原子操作"></a>20.1 原子操作</h3><p>“原子”是化学世界中不可再分的最小微粒，一切物质都由原子组成。在Linux 内核中的原子操作可以理解为“不可被拆分的操作”，就是不能被更高等级中断抢夺优先的操作。在C语言中可以使用以下代码对一个整形变量赋值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> v<span class="token punctuation">;</span><span class="token comment">//定义一个int 类型的变量v</span>
v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//将int 类型的变量v 赋值为1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>而上述代码仍然不是“不可拆分的操作”，C 语言程序仍然需要翻译成汇编指令，在汇编指令的执行过程中仍可能会有竞争的产生。而原子操作会将整形变量的操作当成一个整体，不可再进行分割。而原子操作又可以进一步细分为“整型原子操作”和“位原子操作”，这里首先对整型原子操作进行讲解。</p>
<p>在Linux 内核中使用atomic_t 和atomic64_t 结构体分别来完成32 位系统和64 位系统的整形数据原子操作，两个结构体定义在“内核源码/include/linux/types.h”文件中，具体定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> counter<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">atomic_t</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_64BIT</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> counter<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">atomic64_t</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例如可以使用以下代码定义一个64 位系统的原子整形变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">atomic64_t</span> v<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在成功定义原子变量之后，必然要对原子变量进行读取、加减等动作，原子操作的部分常用API 函数如下所示，定义在“<code>内核源码/include/linux/atomic.h</code>”文件中，所以在接下来的实验中需要加入该头文件的引用。</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ATOMIC_INIT(int i)</td>
<td align="left">定义原子变量的时候对其初始化，赋值为i</td>
</tr>
<tr>
<td align="left">int atomic_read(atomic_t *v)</td>
<td align="left">读取v 的值，并且返回。</td>
</tr>
<tr>
<td align="left">void atomic_set(atomic_t *v, int i)</td>
<td align="left">向原子变量v 写入i 值。</td>
</tr>
<tr>
<td align="left">void atomic_add(int i, atomic_t *v)</td>
<td align="left">原子变量v 加上i 值。</td>
</tr>
<tr>
<td align="left">void atomic_sub(int i, atomic_t *v)</td>
<td align="left">原子变量v 减去i 值。</td>
</tr>
<tr>
<td align="left">void atomic_inc(atomic_t *v)</td>
<td align="left">原子变量v 加1</td>
</tr>
<tr>
<td align="left">void atomic_dec(atomic_t *v)</td>
<td align="left">原子变量v 减1</td>
</tr>
<tr>
<td align="left">int atomic_dec_return(atomic_t *v)</td>
<td align="left">原子变量v 减1，并返回v 的值。</td>
</tr>
<tr>
<td align="left">int atomic_inc_return(atomic_t *v)</td>
<td align="left">原子变量v 加1，并返回v 的值。</td>
</tr>
<tr>
<td align="left">int atomic_sub_and_test(int i, atomic_t *v)</td>
<td align="left">原子变量v 减i，如果结果为0 就返回真，否则返回假</td>
</tr>
<tr>
<td align="left">int atomic_dec_and_test(atomic_t *v)</td>
<td align="left">原子变量v 减1，如果结果为0 就返回真，否则返回假</td>
</tr>
<tr>
<td align="left">int atomic_inc_and_test(atomic_t *v)</td>
<td align="left">原子变量v 加1，如果结果为0 就返回真，否则返回假</td>
</tr>
<tr>
<td align="left">int atomic_add_negative(int i, atomic_t *v)</td>
<td align="left">原子变量v 加i，如果结果为负就返回真，否则返回假</td>
</tr>
</tbody></table>
<p>至此，对于整型原子操作的相关API 函数就讲解完成了，会在下一小节中使用上述原子整形操作API 进行相应的实验。</p>
<p>下面对原子位操作进行讲解，和原子整形变量不同，原子位操作没有atomic_t 的数据结构，原子位操作是直接对内存进行操作，原子位操作相关API 函数如下（图表20-2）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151127532.png" alt="image-20240815112758451"></p>
<p>对于原子位操作的知识就不再深入讲解和实验，感兴趣的同学可以到相关网站上进行自主学习。<br>在下一小节中，将会使用原子整形操作对19 章的并发与竞争实验进行改进。</p>
<h3 id="20-2-实验程序的编写"><a href="#20-2-实验程序的编写" class="headerlink" title="20.2 实验程序的编写"></a>20.2 实验程序的编写</h3><h4 id="20-2-1-驱动程序编写"><a href="#20-2-1-驱动程序编写" class="headerlink" title="20.2.1 驱动程序编写"></a>20.2.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\15\module</code>。</p>
<p>为了解决第19 章实验中并发与竞争的问题，本章节实验将加入原子整形操作相关实验代码，在<code>open()</code>函数和<code>release()</code>函数中加入原子整形变量v 的赋值代码，并且在<code>open()</code>函数中加入原子整形变量v 的判断代码，从而实现同一时间内只允许一个应用打开该设备节点，以此来防止共享资源竞争的产生。</p>
<p>编写完成的atomic.c 代码如下所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/atomic.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/errno.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token class-name">atomic64_t</span> v <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化原子类型变量v,并设置为1</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">open_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">atomic64_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//读取原子类型变量v的值并判断是否等于1</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">atomic64_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将原子类型变量v的值设置为0</span>
	<span class="token comment">//printk("\nthis is open_test \n");</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">read_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	<span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"topeet"</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串变量kbuf</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is read_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span>ubuf<span class="token punctuation">,</span>kbuf<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_to_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串全局变量kbuf</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">write_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span>ubuf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_from_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是topeet就睡眠四秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是itop就睡眠两秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user buf is %s \n"</span><span class="token punctuation">,</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">release_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//printk("\nthis is release_test \n");</span>
	<span class="token function">atomic64_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将原子类型变量v的值赋1</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> <span class="token punctuation">{</span>
       <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span><span class="token comment">//定义dev_t类型变量dev_num来表示设备号</span>
       <span class="token keyword">int</span> major<span class="token punctuation">,</span>minor<span class="token punctuation">;</span><span class="token comment">//定义int类型的主设备号major和次设备号minor</span>
       <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span><span class="token comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span>
       <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class_test<span class="token punctuation">;</span><span class="token comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> dev1<span class="token punctuation">;</span><span class="token comment">//创建chrdev_test类型的</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> fops_test <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
      <span class="token punctuation">.</span>open <span class="token operator">=</span> open_test<span class="token punctuation">,</span><span class="token comment">//将open字段指向open_test(...)函数</span>
      <span class="token punctuation">.</span>read <span class="token operator">=</span> read_test<span class="token punctuation">,</span><span class="token comment">//将read字段指向read_test(...)函数</span>
      <span class="token punctuation">.</span>write <span class="token operator">=</span> write_test<span class="token punctuation">,</span><span class="token comment">//将write字段指向write_test(...)函数</span>
      <span class="token punctuation">.</span>release <span class="token operator">=</span> release_test<span class="token punctuation">,</span><span class="token comment">//将release字段指向release_test(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">atomic_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_name"</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//自动获取设备号，设备名chrdev_name</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MAJOR()函数获取主设备号</span>
	dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MINOR()函数获取次设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d,minor is %d\n"</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>major<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span><span class="token operator">&amp;</span>fops_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span>
	dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	<span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_add()函数进行字符设备的添加</span>
	dev1<span class="token punctuation">.</span>class_test <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span><span class="token string">"class_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用class_create进行类的创建，类名称为class_test</span>
	<span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"device_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用device_create进行设备的创建，设备名称为device_test</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">atomic_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的设备</span>
	<span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的类</span>
	<span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除添加的字符设备cdev_test</span>
	<span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放字符设备所申请的设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>atomic_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>atomic_exit<span class="token punctuation">)</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="20-2-2-编写测试APP"><a href="#20-2-2-编写测试APP" class="headerlink" title="20.2.2 编写测试APP"></a>20.2.2 编写测试APP</h4><p>本实验应用程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\15\app</code>。<br>本测试app 代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c 内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//定义int类型的文件描述符</span>
	<span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义读取缓冲区str1</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open failed \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="20-3-3-运行测试"><a href="#20-3-3-运行测试" class="headerlink" title="20.3.3 运行测试"></a>20.3.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图20-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod atomic.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151141133.png" alt="image-20240815114118054"></p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test 进行查看，如下图（图20-10）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/device_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151141002.png" alt="image-20240815114139927"></p>
<p>可以看到device_test 节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图20-11）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app /dev/device_test topeet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151141979.png" alt="image-20240815114153901"></p>
<p>可以看到传递的buf 值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图20-12）所示：</p>
<pre class="line-numbers language-none"><code class="language-none">./app /dev/device_test topeet &amp;
./app /dev/device_test itop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151142959.png" alt="image-20240815114218884"></p>
<p>可以看到应用程序在打开第二次/dev/device_test 文件的时候，出现了“file open failed”打印，证明文件打开失败，只有在第一个应用关闭相应的文件之后，下一个应用才能打开，通过限制同一时间内设备访问数量，来对共享资源进行保护。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图20-13）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod flag.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151142321.png" alt="image-20240815114246240"></p>
<p>至此，原子操作实验就完成了。</p>
<h2 id="第21-章自旋锁实验"><a href="#第21-章自旋锁实验" class="headerlink" title="第21 章自旋锁实验"></a>第21 章自旋锁实验</h2><p>在上一节中对原子操作进行了讲解，并使用原子整形操作对并发与竞争实验进行了改进，但是<strong>原子操作只能对整形变量或者位进行保护，而对于结构体或者其他类型的共享资源，原子操作就力不从心了</strong>，这时候就轮到自旋锁的出场了，下面就让我们一起来进行自旋锁的学习吧。</p>
<h3 id="21-1-自旋锁"><a href="#21-1-自旋锁" class="headerlink" title="21.1 自旋锁"></a>21.1 自旋锁</h3><p>自旋锁是为了保护共享资源提出的一种锁机制。<strong>自旋锁（spin lock）</strong>是一种非阻塞锁，也就是说，如果某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，<strong>而是在不断的消耗CPU 的时间，不停的试图获取锁</strong>。</p>
<p>在有些场景中，同步资源(用来保持一致性的两个或多个资源)的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果计算机有多个CPU 核心，能够让两个或以上的线程同时并行执行，这样我们就可以让后面那个请求锁的线程不放弃CPU 的执行时间，直到持有锁的线程释放锁，后面请求锁的线程才可以获取锁。</p>
<p>为了让后面那个请求锁的线程“稍等一下”，我们需让它进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么该线程便不必阻塞，并且直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。我们再举个形象生动的例子，以现实生活中银行ATM 机办理业务为例，ATM 机防护舱在同一时间内只允许一个人进入，当有人进入ATM 机防护舱之后，两秒钟之后自动上锁，其他也想要存取款的人员，只能在外部等待，办理完相应的存取款业务之后，舱内人员需要手动打开防护锁，其他人才能进入其中，办理业务。而自旋锁在驱动中的使用和上述ATM 机办理业务流程相同，当一个任务要访问某个共享资源之前需要先获取相应的自旋锁，自旋锁只能被一个任务持有，在该任务持有自旋锁的过程中，其他任务只能原地等待该自旋锁的释放，在等待过程中的任务同样会持续占用CPU，消耗CPU 资源，所以临界区的代码不能太多。</p>
<p>如果自旋锁被错误使用可能会导致死锁的产生，对于自旋锁死锁会在下一章节进行详细说明，并进行相应的实验。<br>内核中以spinlock_t 结构体来表示自旋锁，定义在“<code>内核源码/include/linux/spinlock_types.h</code>”文件中，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> <span class="token punctuation">{</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
    	<span class="token keyword">struct</span> <span class="token class-name">raw_spinlock</span> rlock<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_LOCK_ALLOC</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">LOCK_PADSIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">raw_spinlock</span><span class="token punctuation">,</span> dep_map<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            u8 __padding<span class="token punctuation">[</span>LOCK_PADSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">struct</span> <span class="token class-name">lockdep_map</span> dep_map<span class="token punctuation">;</span>
    	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">spinlock_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>自旋锁相关API 函数定义在“内核源码/include/linux/spinlock.h”文件中，所以在本章节的实验中要加入该头文件（spinlock.h 头文件包含spinlock_types.h 等，所以只需加入spinlock.h 头文件即可），部分API 函数如下（表21-1）所示，</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SPINLOCK(spinlock_t lock)</td>
<td>定义并初始化自旋锁。</td>
</tr>
<tr>
<td>int spin_lock_init(spinlock_t *lock)</td>
<td>初始化自旋锁。</td>
</tr>
<tr>
<td>void spin_lock(spinlock_t *lock)</td>
<td>获取指定的自旋锁，也叫做加锁。</td>
</tr>
<tr>
<td>void spin_unlock(spinlock_t *lock)</td>
<td>释放指定的自旋锁。</td>
</tr>
<tr>
<td>int spin_trylock(spinlock_t *lock)</td>
<td>尝试获取指定的自旋锁，如果没有获取到就返回0</td>
</tr>
<tr>
<td>int spin_is_locked(spinlock_t *lock)</td>
<td>检查指定的自旋锁是否被获取，如果没有被获取就返回非0，否则返回0。</td>
</tr>
</tbody></table>
<p>除了上述API 之外还有其他与终端相关的自旋锁API 函数，会在接下来的自旋锁死锁章节进行讲解。<br>自旋锁的使用步骤：</p>
<ul>
<li>1 在访问临界资源的时候先申请自旋锁</li>
<li>2 获取到自旋锁之后就进入临界区，获取不到自旋锁就“原地等待”。</li>
<li>3 退出临界区的时候要释放自旋锁。</li>
</ul>
<p>在下一小节中将使用上述自旋锁API 进行相应的实验，利用自旋锁相关知识来对第19 章节的并发与竞争实验进行优化。</p>
<h3 id="21-2-实验程序的编写"><a href="#21-2-实验程序的编写" class="headerlink" title="21.2 实验程序的编写"></a>21.2 实验程序的编写</h3><h4 id="21-2-1-驱动程序编写"><a href="#21-2-1-驱动程序编写" class="headerlink" title="21.2.1 驱动程序编写"></a>21.2.1 驱动程序编写</h4><p>本实验对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\16\module。</p>
<p>与上一章节使用原子整形操作避免并发与竞争逻辑相同，在驱动入口函数初始化自旋锁，然后在open 函数中使用自旋锁实现对设备的互斥访问，最后在release 函数中解锁，表示设备被释放了，可以被其他的应用程序使用。上述操作都将共享资源由自旋锁进行保护，从而实现同一时间内只允许一个应用打开该设备节点，以此来防止共享资源竞争的产生。</p>
<p>编写完成的spinlock.c 代码如下所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/spinlock.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token class-name">spinlock_t</span> spinlock_test<span class="token punctuation">;</span><span class="token comment">//定义spinlock_t类型的自旋锁变量spinlock_test</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//定义flag标准为，flag等于1表示设备没有被打开，等于0则证明设备已经被打开了</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">open_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//printk("\nthis is open_test \n");</span>
	<span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自旋锁加锁</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//判断标志位flag的值是否等于1</span>
		<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自旋锁解锁</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//将标志位的值设置为0</span>
	<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自旋锁解锁</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">read_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	<span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"topeet"</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串变量kbuf</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is read_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span>ubuf<span class="token punctuation">,</span>kbuf<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_to_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串全局变量kbuf</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">write_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span>ubuf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_from_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是topeet就睡眠四秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是itop就睡眠两秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user buf is %s \n"</span><span class="token punctuation">,</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">release_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is release_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自旋锁加锁</span>
	flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自旋锁解锁</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> <span class="token punctuation">{</span>
       <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span><span class="token comment">//定义dev_t类型变量dev_num来表示设备号</span>
       <span class="token keyword">int</span> major<span class="token punctuation">,</span>minor<span class="token punctuation">;</span><span class="token comment">//定义int类型的主设备号major和次设备号minor</span>
       <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span><span class="token comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span>
       <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class_test<span class="token punctuation">;</span><span class="token comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> dev1<span class="token punctuation">;</span><span class="token comment">//创建chrdev_test类型的</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> fops_test <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
      <span class="token punctuation">.</span>open <span class="token operator">=</span> open_test<span class="token punctuation">,</span><span class="token comment">//将open字段指向open_test(...)函数</span>
      <span class="token punctuation">.</span>read <span class="token operator">=</span> read_test<span class="token punctuation">,</span><span class="token comment">//将read字段指向read_test(...)函数</span>
      <span class="token punctuation">.</span>write <span class="token operator">=</span> write_test<span class="token punctuation">,</span><span class="token comment">//将write字段指向write_test(...)函数</span>
      <span class="token punctuation">.</span>release <span class="token operator">=</span> release_test<span class="token punctuation">,</span><span class="token comment">//将release字段指向release_test(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">atomic_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">spin_lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock_test<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_name"</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//自动获取设备号，设备名chrdev_name</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MAJOR()函数获取主设备号</span>
	dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MINOR()函数获取次设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d,minor is %d\n"</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>major<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span><span class="token operator">&amp;</span>fops_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span>
	dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	<span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_add()函数进行字符设备的添加</span>
	dev1<span class="token punctuation">.</span>class_test <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span><span class="token string">"class_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用class_create进行类的创建，类名称为class_test</span>
	<span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"device_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用device_create进行设备的创建，设备名称为device_test</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">atomic_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的设备</span>
	<span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的类</span>
	<span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除添加的字符设备cdev_test</span>
	<span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放字符设备所申请的设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>atomic_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>atomic_exit<span class="token punctuation">)</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="21-2-2-编写测试APP"><a href="#21-2-2-编写测试APP" class="headerlink" title="21.2.2 编写测试APP"></a>21.2.2 编写测试APP</h4><p>本实验应用程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\16\app</code>。<br>本测试app 代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c 内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//定义int类型的文件描述符</span>
	<span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义读取缓冲区str1</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open failed \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="21-3-运行测试"><a href="#21-3-运行测试" class="headerlink" title="21.3 运行测试"></a>21.3 运行测试</h3><h4 id="21-3-3-运行测试"><a href="#21-3-3-运行测试" class="headerlink" title="21.3.3 运行测试"></a>21.3.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图21-7）所示：</p>
<pre class="line-numbers language-none"><code class="language-none">insmod spinlock.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151205475.png" alt="image-20240815120554389"></p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test 进行查看，如下图（21-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/device_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151401486.png" alt="image-20240815140149402"></p>
<p>可以看到device_test 节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图21-9）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token operator">/</span>app <span class="token operator">/</span>dev<span class="token operator">/</span>device_test topeet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151402912.png" alt="image-20240815140212827"></p>
<p>可以看到传递的buf 值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图21-10）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app /dev/device_test topeet <span class="token operator">&amp;</span>
./app /dev/device_test itop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151402416.png" alt="image-20240815140243327"></p>
<p>可以看到应用程序在打开第二次/dev/device_test 文件的时候，出现了“file open failed”打印，证明文件打开失败，只有在第一个应用关闭相应的文件之后，下一个应用才能打开。本次实验的自旋锁只是对标志位flag 进行保护，flag 用来表示设备的状态，确保同一时间内，该设备只能被一个应用程序打开。进而对共享资源进行保护。<br>最后可以使用以下命令进行驱动的卸载，如下图（图21-11）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod spinlock.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151403097.png" alt="image-20240815140312012"></p>
<p>至此，自旋锁实验就完成了。</p>
<h2 id="第22-章自旋锁死锁实验"><a href="#第22-章自旋锁死锁实验" class="headerlink" title="第22 章自旋锁死锁实验"></a>第22 章自旋锁死锁实验</h2><p>在上一小节中，学习了内核中自旋锁的使用，而自旋锁若是使用不当就会产生死锁，在本章将会对自旋锁的特殊情况-死锁进行讲解。</p>
<h3 id="22-1-自旋锁死锁"><a href="#22-1-自旋锁死锁" class="headerlink" title="22.1 自旋锁死锁"></a>22.1 自旋锁死锁</h3><p>死锁是指两个或多个事物在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。当多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进，这种情况就是死锁。</p>
<p>自旋锁死锁发生存在两种情况：<br>（1）<strong>第一种情况是拥有自旋锁的进程A 在内核态阻塞了</strong>，内核调度B 进程，碰巧B 进程也要获得自旋锁，此时B 只能自旋转。而此时抢占已经关闭(在单核条件下)不会调度A 进程了，B 永远自旋，产生死锁，如下图（图22-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151410945.png" alt="image-20240815141049857"></p>
<p>相应的解决办法是，在自旋锁的使用过程中要尽可能短的时间内拥有自旋锁，而且不能在临界区中调用导致线程休眠的函数。<br>第二种情况是进程A 拥有自旋锁，中断到来，CPU 执行中断函数，<strong>中断处理函数需要获得自旋锁</strong>，访问共享资源，此时无法获得锁，只能自旋，从而产生死锁，如下图（图22-2）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151414481.png" alt="image-20240815141440388"></p>
<p>对于中断引发的死锁，最好的解决方法就是在获取锁之前关闭本地中断，Linux 内核在“<code>/include/linux/spinlock.h</code>”文件中提供了相应的API 函数，如下（图22-3）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_irq(spinlock_t *lock)</td>
<td>禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irq(spinlock_t *lock)</td>
<td>激活本地中断，并释放自旋锁。</td>
</tr>
<tr>
<td>void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)</td>
<td>恢复中断状态，关闭中断并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，打开中断并释放自旋锁</td>
</tr>
<tr>
<td>void spin_lock_bh(spinlock_t *lock)</td>
<td>关闭下半部，获取自旋锁</td>
</tr>
<tr>
<td>void spin_unlock_bh(spinlock_t *lock)</td>
<td>打开下半部，获取自旋锁</td>
</tr>
</tbody></table>
<p>由于Linux 内核运行是非常复杂的，很难确定某个时刻的中断状态，因此建议使用<code>spin_lock_irqsave/spin_unlock_irqrestore</code>，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。</p>
<p>在下一小节中将进行自旋锁死锁实验，本次实验所采取的是第一种情况，<strong>即拥有自旋锁的进程A 在内核态阻塞了，内核调度B 进程，碰巧B 进程也要获得自旋锁，依次产生死锁</strong>。</p>
<h3 id="22-2-实验程序的编写"><a href="#22-2-实验程序的编写" class="headerlink" title="22.2 实验程序的编写"></a>22.2 实验程序的编写</h3><h4 id="22-2-1-驱动程序编写"><a href="#22-2-1-驱动程序编写" class="headerlink" title="22.2.1 驱动程序编写"></a>22.2.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\17\module</code>。</p>
<p>本章节实验以19 章并发与竞争实验为基础，在open()函数中加入了自旋锁加锁，在close()函数中加入了自旋锁解锁，由于在write()函数中存在sleep()睡眠函数，所以会造成内核阻塞，睡眠期间如果使用另一个进程获取该自旋锁，就会造成死锁。</p>
<p>编写完成的dielock.c 代码如下所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/spinlock.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token class-name">spinlock_t</span> spinlock_test<span class="token punctuation">;</span><span class="token comment">//定义spinlock_t类型的自旋锁变量spinlock_test</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">open_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//printk("\nthis is open_test \n");</span>
	<span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自旋锁加锁</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">read_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	<span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"topeet"</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串变量kbuf</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is read_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span>ubuf<span class="token punctuation">,</span>kbuf<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_to_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串全局变量kbuf</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">write_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span>ubuf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_from_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是topeet就睡眠四秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是itop就睡眠两秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user buf is %s \n"</span><span class="token punctuation">,</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">release_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is release_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自旋锁解锁</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> <span class="token punctuation">{</span>
       <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span><span class="token comment">//定义dev_t类型变量dev_num来表示设备号</span>
       <span class="token keyword">int</span> major<span class="token punctuation">,</span>minor<span class="token punctuation">;</span><span class="token comment">//定义int类型的主设备号major和次设备号minor</span>
       <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span><span class="token comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span>
       <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class_test<span class="token punctuation">;</span><span class="token comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> dev1<span class="token punctuation">;</span><span class="token comment">//创建chrdev_test类型的</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> fops_test <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
      <span class="token punctuation">.</span>open <span class="token operator">=</span> open_test<span class="token punctuation">,</span><span class="token comment">//将open字段指向open_test(...)函数</span>
      <span class="token punctuation">.</span>read <span class="token operator">=</span> read_test<span class="token punctuation">,</span><span class="token comment">//将read字段指向read_test(...)函数</span>
      <span class="token punctuation">.</span>write <span class="token operator">=</span> write_test<span class="token punctuation">,</span><span class="token comment">//将write字段指向write_test(...)函数</span>
      <span class="token punctuation">.</span>release <span class="token operator">=</span> release_test<span class="token punctuation">,</span><span class="token comment">//将release字段指向release_test(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">atomic_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">spin_lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock_test<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_name"</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//自动获取设备号，设备名chrdev_name</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MAJOR()函数获取主设备号</span>
	dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MINOR()函数获取次设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d,minor is %d\n"</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>major<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span><span class="token operator">&amp;</span>fops_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span>
	dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	<span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_add()函数进行字符设备的添加</span>
	dev1<span class="token punctuation">.</span>class_test <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span><span class="token string">"class_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用class_create进行类的创建，类名称为class_test</span>
	<span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"device_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用device_create进行设备的创建，设备名称为device_test</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">atomic_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的设备</span>
	<span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的类</span>
	<span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除添加的字符设备cdev_test</span>
	<span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放字符设备所申请的设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>atomic_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>atomic_exit<span class="token punctuation">)</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="22-2-2-编写测试APP"><a href="#22-2-2-编写测试APP" class="headerlink" title="22.2.2 编写测试APP"></a>22.2.2 编写测试APP</h4><p>本实验应用程序对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\17\app</code>。</p>
<p>本测试app 代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c 内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//定义int类型的文件描述符</span>
	<span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义读取缓冲区str1</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open failed \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于本次测试的CPU 为多核心CPU，其他核心仍旧可以调度其他进程，所以需要多次使用taskset 函数指定CPU 进行进程的运行，以此来产生死锁，在与app.c 同级目录下创建名为app.sh的脚本文件，脚本内容如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">#!/bin/bash
taskset -c 0 ./app /dev/device_test topeet &amp;
taskset -c 1 ./app /dev/device_test topeet &amp;
taskset -c 2 ./app /dev/device_test topeet &amp;
taskset -c 3 ./app /dev/device_test topeet &amp;
taskset -c 0 ./app /dev/device_test topeet &amp;
taskset -c 1 ./app /dev/device_test topeet &amp;
taskset -c 2 ./app /dev/device_test topeet &amp;
taskset -c 3 ./app /dev/device_test topeet &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>保存退出之后，需要使用以下命令赋予脚本可执行权限，如下图（图22-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">777</span> app.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151642508.png" alt="image-20240815164247412"></p>
<p>至此测试程序app.c 和运行脚本app.sh 就编写完成了。</p>
<h3 id="22-3-运行测试"><a href="#22-3-运行测试" class="headerlink" title="22.3 运行测试"></a>22.3 运行测试</h3><h4 id="22-3-1-编译驱动程序"><a href="#22-3-1-编译驱动程序" class="headerlink" title="22.3.1 编译驱动程序"></a>22.3.1 编译驱动程序</h4><p>在上一小节中的dielock.c 代码同一目录下创建Makefile 文件，Makefile 文件内容上小节：然后使用命令“make”进行驱动的编译，编译完生成dielock.ko 目标文件，至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h4 id="22-3-2-编译应用程序"><a href="#22-3-2-编译应用程序" class="headerlink" title="22.3.2 编译应用程序"></a>22.3.2 编译应用程序</h4><p>来到应用程序app.c 文件的存放路径如下图（图22-8）所示：然后使用以下命令对app.c 进行交叉编译，编译完成如下图（图22-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> app app.c <span class="token parameter variable">-static</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>生成的app 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="22-3-3-运行测试"><a href="#22-3-3-运行测试" class="headerlink" title="22.3.3 运行测试"></a>22.3.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图22-10）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod dielock.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151653548.png" alt="image-20240815165348452"></p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test 进行查看，如下图（图22-11）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/device_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151654378.png" alt="image-20240815165413289"></p>
<p>可以看到device_test 节点已经被自动创建了，然后使用以下命令运行app.sh 脚本，该脚本会指定CPU 在加锁之后进入内核休眠状态，如下图（图22-12）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408151654033.png" alt="image-20240815165438938"></p>
<p>在指令输入之后，串口终端无法输入，引发了死锁，进而造成了系统崩溃，所以在编写驱动的过程中，要尽可能的避免死锁的出现。<br>至此，自旋锁死锁驱动实验就完成了。</p>
<h2 id="第23-章信号量实验"><a href="#第23-章信号量实验" class="headerlink" title="第23 章信号量实验"></a>第23 章信号量实验</h2><p>在上面两个章节对自旋锁和自旋锁死锁进行了学习，自旋锁会让请求的任务原地“自旋”，在等待的过程中会循环检测自旋锁的状态，进而占用系统资源，而本章节要讲解的信号量也是解决竞争的一种常用方法，与自旋锁不同的是，信号量会使等待的线程进入休眠状态，适用于那些占用资源比较久的场合。下面对信号量相关知识的进行讲解。</p>
<h3 id="23-1-信号量"><a href="#23-1-信号量" class="headerlink" title="23.1 信号量"></a>23.1 信号量</h3><p>信号量是操作系统中最典型的用于同步和互斥的手段，本质上是一个全局变量，信号量的值表示控制访问资源的线程数，可以根据实际情况来自行设置，<strong>如果在初始化的时候将信号量量值设置为大于1，那么这个信号量就是计数型信号量，允许多个线程同时访问共享资源。如果将信号量量值设置为1，那么这个信号量就是二值信号量，同一时间内只允许一个线程访问共享资源</strong>，注意！<strong>信号量的值不能小于0。当信号量的值为0 时，想访问共享资源的线程必须等待，直到信号量大于0 时，等待的线程才可以访问</strong>。当访问共享资源时，信号量执行“减一”操作，访问完成后再执行“加一”操作。</p>
<p><strong>相比于自旋锁，信号量具有休眠特性，因此适用长时间占用资源的场合，但由于信号量会引起休眠，所以不能用在中断函数中</strong>，最后如果共享资源的持有时间比较短，使用信号量的话会造成频繁的休眠，反而带来更多资源的消耗，使用自旋锁反而效果更好。在同时使用信号量和自旋锁的时候，要先获取信号量，再使用自旋锁，因为信号量会导致睡眠。</p>
<p>以现实生活中的银行办理业务为例，银行的业务办理窗口就是共享资源，业务办理窗口的数量就是信号量量值，进入银行之后，客户需要领取相应的排序码，然后在休息区进行等待，可以看作线程的睡眠阶段，当前面的客户办理完业务之后，相应的窗口会空闲出来，可以看作信号量的释放，之后银行会通过广播，提醒下一位客户到指定的窗口进行业务的办理，可以看作线程的唤醒并获取到信号量，访问共享资源的过程。</p>
<p>Linux 内核使用semaphore 结构体来表示信号量，该结构体定义在“内核源码/include/linux/semaphore.h”文件内（所以在下一章节的信号量实验中需要加入该头文件），结构体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token punctuation">{</span>
    <span class="token class-name">raw_spinlock_t</span> lock<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> wait_list<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>与信号量相关的API 函数同样定义在semaphore.h 文件内，部分常用API 函数如下（表23-1）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEAMPHORE(name)</td>
<td>定义信号量，并且设置信号量的值为1。</td>
</tr>
<tr>
<td>void sema_init(struct semaphore *sem, int val)</td>
<td>初始化信号量sem，设置信号量值为val。</td>
</tr>
<tr>
<td>void down(struct semaphore *sem)</td>
<td>获取信号量，不能被中断打断，如ctrl+c</td>
</tr>
<tr>
<td>int down_interruptible(struct semaphore *sem)</td>
<td>获取信号量，可以被中断打断，如ctrl+c</td>
</tr>
<tr>
<td>void up(struct semaphore *sem)</td>
<td>释放信号量</td>
</tr>
<tr>
<td>int down_trylock(struct semaphore *sem);</td>
<td>尝试获取信号量，如果能获取到信号量就获取，并且返回0。<br>如果不能就返回非0</td>
</tr>
</tbody></table>
<p>至此，关于信号量相关的知识就讲解完成了，上述API 函数会在下一小节的实验中用到。</p>
<h3 id="23-2-实验程序的编写"><a href="#23-2-实验程序的编写" class="headerlink" title="23.2 实验程序的编写"></a>23.2 实验程序的编写</h3><h4 id="23-2-1-驱动程序编写"><a href="#23-2-1-驱动程序编写" class="headerlink" title="23.2.1 驱动程序编写"></a>23.2.1 驱动程序编写</h4><p>本实验对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\18\module。</p>
<p>与之前章节设置标志位，在同一时间内只允许一个任务对共享资源进行访问的方式所不同，本小节将采用信号量的方式避免竞争的产生。本实验设置的信号量量值为1，所以需要在open()函数中加入信号量获取函数，在release()函数中加入信号量释放函数即可。</p>
<p>编写完成的semaphore.c 代码如下所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/semaphore.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">semaphore</span> semaphore_test<span class="token punctuation">;</span><span class="token comment">//定义一个semaphore类型的结构体变量semaphore_test</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">open_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is open_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>semaphore_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//信号量数量-1</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">read_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	<span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"topeet"</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串变量kbuf</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is read_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span>ubuf<span class="token punctuation">,</span>kbuf<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_to_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串全局变量kbuf</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">write_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span>ubuf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_from_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是topeet就睡眠四秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是itop就睡眠两秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user buf is %s \n"</span><span class="token punctuation">,</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">release_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>semaphore_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//信号量数量加1	</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is release_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> <span class="token punctuation">{</span>
       <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span><span class="token comment">//定义dev_t类型变量dev_num来表示设备号</span>
       <span class="token keyword">int</span> major<span class="token punctuation">,</span>minor<span class="token punctuation">;</span><span class="token comment">//定义int类型的主设备号major和次设备号minor</span>
       <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span><span class="token comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span>
       <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class_test<span class="token punctuation">;</span><span class="token comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> dev1<span class="token punctuation">;</span><span class="token comment">//创建chrdev_test类型的</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> fops_test <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
      <span class="token punctuation">.</span>open <span class="token operator">=</span> open_test<span class="token punctuation">,</span><span class="token comment">//将open字段指向open_test(...)函数</span>
      <span class="token punctuation">.</span>read <span class="token operator">=</span> read_test<span class="token punctuation">,</span><span class="token comment">//将read字段指向read_test(...)函数</span>
      <span class="token punctuation">.</span>write <span class="token operator">=</span> write_test<span class="token punctuation">,</span><span class="token comment">//将write字段指向write_test(...)函数</span>
      <span class="token punctuation">.</span>release <span class="token operator">=</span> release_test<span class="token punctuation">,</span><span class="token comment">//将release字段指向release_test(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">atomic_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>semaphore_test<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化信号量结构体semaphore_test，并设置信号量的数量为1</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_name"</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//自动获取设备号，设备名chrdev_name</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MAJOR()函数获取主设备号</span>
	dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MINOR()函数获取次设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d,minor is %d\n"</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>major<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span><span class="token operator">&amp;</span>fops_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span>
	dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	<span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_add()函数进行字符设备的添加</span>
	dev1<span class="token punctuation">.</span>class_test <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span><span class="token string">"class_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用class_create进行类的创建，类名称为class_test</span>
	<span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"device_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用device_create进行设备的创建，设备名称为device_test</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">atomic_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的设备</span>
	<span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的类</span>
	<span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除添加的字符设备cdev_test</span>
	<span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放字符设备所申请的设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>atomic_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>atomic_exit<span class="token punctuation">)</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>23.2.2 编写测试APP<br>本实验应用程序对应的网盘路径为： iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\18\app。<br>本测试app 代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//定义int类型的文件描述符</span>
	<span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义读取缓冲区str1</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open failed \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> 
		<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="23-3-运行测试"><a href="#23-3-运行测试" class="headerlink" title="23.3 运行测试"></a>23.3 运行测试</h3><h4 id="23-3-1-编译驱动程序"><a href="#23-3-1-编译驱动程序" class="headerlink" title="23.3.1 编译驱动程序"></a>23.3.1 编译驱动程序</h4><p>在上一小节中的semaphore.c 代码同一目录下创建Makefile 文件，然后使用命令“make”进行驱动的编译。编译完生成semaphore.ko 目标文件，至此驱动模块就编译成功了，下面进行应用程序的安装。</p>
<h4 id="23-3-2-编译应用程序"><a href="#23-3-2-编译应用程序" class="headerlink" title="23.3.2 编译应用程序"></a>23.3.2 编译应用程序</h4><p>来到应用程序app.c 文件的存放路径如下图（图23-5）所示：然后使用以下命令对app.c 进行交叉编译，编译完成如下图（图23-6）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> app app.c <span class="token parameter variable">-static</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>生成的app 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="23-3-3-运行测试"><a href="#23-3-3-运行测试" class="headerlink" title="23.3.3 运行测试"></a>23.3.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图23-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod semaphore.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161026982.png" alt="image-20240816102553850"></p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test 进行查看，如下图（图23-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/device_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161026669.png" alt="image-20240816102627600"></p>
<p>可以看到device_test 节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图23-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app /dev/device_test topeet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161026140.png" alt="image-20240816102647072"></p>
<p>可以看到传递的buf 值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图23-10）所示：</p>
<pre class="line-numbers language-none"><code class="language-none">./app /dev/device_test topeet &amp;
./app /dev/device_test itop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161027448.png" alt="image-20240816102710368"></p>
<p>上述打印信息正常，证明数据被正确传递了，没有发生共享资源的竞争，第一个任务运行之后，由于设置的信号量量值为1，所以第二个任务会进入休眠状态，第一个任务执行完毕之后，会唤醒第二个任务去执行，所以避免了并发与竞争。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图23-11）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod semaphore.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161027832.png" alt="image-20240816102757761"></p>
<p>至此，信号量实验就完成了。</p>
<h2 id="第24-章互斥锁实验"><a href="#第24-章互斥锁实验" class="headerlink" title="第24 章互斥锁实验"></a>第24 章互斥锁实验</h2><p>在上一章节中对信号量进行了学习，而本章节要学习的互斥锁可以说是“量值”为1 的信号量，最终实现的效果相同，既然有了信号量，那为什么还要有互斥锁呢，带着疑问，让我们来进行本章节的学习吧！</p>
<h3 id="24-1-互斥锁"><a href="#24-1-互斥锁" class="headerlink" title="24.1 互斥锁"></a>24.1 互斥锁</h3><p>在上一章节中，<strong>将信号量量值设置为1，最终实现的就是互斥效果</strong>，与本章节要学习的互斥锁功能相同，虽然两者功能相同但是具体的实现方式是不同的，<strong>但是使用互斥锁效率更高、更简洁，所以如果使用到的信号量“量值”为1，一般将其修改为使用互斥锁实现</strong>。</p>
<p>当有多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制。线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定或者非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性，能够保证多个线程访问共享数据不会出现资源竞争及数据错误。</p>
<p>为了方便大家理解，这里举个例子来说明。比如公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。那么怎么解决这种情况呢？只要我在打印着的时候别人是不允许打印的，只有等我打印结束后别人才允许打印。这个过程有点类似于，把打印机放在一个房间里，给这个房间安把锁，这个锁默认是打开的。当A 需要打印时，他先过来检查这把锁有没有锁着，没有的话就进去，同时上锁在房间里打印。而在这时，刚好B 也需要打印，B 同样先检查锁，发现锁是锁住的，他就在门外等着。而当A 打印结束后，他会开锁出来，这时候B 才进去上锁打印。看了这个例子，相信大家已经理解了互斥锁。</p>
<p>互斥锁会导致休眠，所以在中断里面不能用互斥锁。同一时刻只能有一个线程持有互斥锁，并且只有持有者才可以解锁，并且不允许递归上锁和解锁。</p>
<p>内核中以mutex 结构体来表示互斥体，定义在“内核源码/include/linux/mutex.h”文件中，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mutex</span> <span class="token punctuation">{</span>
    <span class="token class-name">atomic_long_t</span> owner<span class="token punctuation">;</span>
    <span class="token class-name">spinlock_t</span> wait_lock<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_MUTEX_SPIN_ON_OWNER</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">optimistic_spin_queue</span> osq<span class="token punctuation">;</span> <span class="token comment">/* Spinner MCS lock */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> wait_list<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_MUTEXES</span></span>
    <span class="token keyword">void</span> <span class="token operator">*</span>magic<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_LOCK_ALLOC</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">lockdep_map</span> dep_map<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一些和互斥体相关的API 函数也定义在mutex.h 文件中，常用API 函数如下（表24-1）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>DEFINE_MUTEX(name)</code></td>
<td>定义并初始化一个mutex 变量。</td>
</tr>
<tr>
<td><code>void mutex_init(mutex *lock)</code></td>
<td>初始化mutex。</td>
</tr>
<tr>
<td><code>void mutex_lock(struct mutex *lock)</code></td>
<td>获取mutex，也就是给mutex 上锁。如果获取不到就进休眠。</td>
</tr>
<tr>
<td><code>void mutex_unlock(struct mutex *lock)</code></td>
<td>释放mutex，也就给mutex 解锁。</td>
</tr>
<tr>
<td><code>int mutex_is_locked(struct mutex *lock)</code></td>
<td>判断mutex 是否被获取，如果是的话就返回1，否则返回0。</td>
</tr>
<tr>
<td><code>int mutex_trylock(struct mutex *lock);</code></td>
<td>尝试获取mutex，，得到锁返回真1 反之返回0</td>
</tr>
</tbody></table>
<p>至此，关于互斥体相关的知识就讲解完成了，在下一小节的实验中会对上述API 函数进行运用。</p>
<h3 id="24-2-实验程序的编写"><a href="#24-2-实验程序的编写" class="headerlink" title="24.2 实验程序的编写"></a>24.2 实验程序的编写</h3><h4 id="24-2-1-驱动程序编写"><a href="#24-2-1-驱动程序编写" class="headerlink" title="24.2.1 驱动程序编写"></a>24.2.1 驱动程序编写</h4><p>本实验对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\19\module。</p>
<p>本小节实验将使用互斥体对19 章的并发与竞争实验进行改进，由于互斥体在同一时间内只允许一个任务对共享资源进行，所以除了在atomic_init()函数内加入初始化互斥锁函数之外，只需要在open()函数中加入互斥锁加锁函数，在release()函数中加入互斥锁解锁函数即可。</p>
<p>编写完成的mutex.c 代码如下所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/mutex.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">mutex</span> mutex_test<span class="token punctuation">;</span><span class="token comment">//定义mutex类型的互斥锁结构体变量mutex_test</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">open_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is open_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//互斥锁加锁</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">read_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	<span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"topeet"</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串变量kbuf</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is read_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span>ubuf<span class="token punctuation">,</span>kbuf<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_to_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义char类型字符串全局变量kbuf</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">write_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>ubuf<span class="token punctuation">,</span><span class="token class-name">size_t</span> len<span class="token punctuation">,</span><span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span>ubuf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用copy_from_user接收用户空间传递的数据</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"topeet"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是topeet就睡眠四秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span><span class="token string">"itop"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果传递的kbuf是itop就睡眠两秒钟</span>
		<span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user buf is %s \n"</span><span class="token punctuation">,</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">release_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//互斥锁解锁</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\nthis is release_test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> <span class="token punctuation">{</span>
       <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span><span class="token comment">//定义dev_t类型变量dev_num来表示设备号</span>
       <span class="token keyword">int</span> major<span class="token punctuation">,</span>minor<span class="token punctuation">;</span><span class="token comment">//定义int类型的主设备号major和次设备号minor</span>
       <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span><span class="token comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span>
       <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class_test<span class="token punctuation">;</span><span class="token comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">chrdev_test</span> dev1<span class="token punctuation">;</span><span class="token comment">//创建chrdev_test类型的</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> fops_test <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
      <span class="token punctuation">.</span>open <span class="token operator">=</span> open_test<span class="token punctuation">,</span><span class="token comment">//将open字段指向open_test(...)函数</span>
      <span class="token punctuation">.</span>read <span class="token operator">=</span> read_test<span class="token punctuation">,</span><span class="token comment">//将read字段指向read_test(...)函数</span>
      <span class="token punctuation">.</span>write <span class="token operator">=</span> write_test<span class="token punctuation">,</span><span class="token comment">//将write字段指向write_test(...)函数</span>
      <span class="token punctuation">.</span>release <span class="token operator">=</span> release_test<span class="token punctuation">,</span><span class="token comment">//将release字段指向release_test(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">atomic_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex_test<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"chrdev_name"</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//自动获取设备号，设备名chrdev_name</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MAJOR()函数获取主设备号</span>
	dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用MINOR()函数获取次设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d,minor is %d\n"</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>major<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span><span class="token operator">&amp;</span>fops_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span>
	dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span><span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	<span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cdev_add()函数进行字符设备的添加</span>
	dev1<span class="token punctuation">.</span>class_test <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span><span class="token string">"class_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用class_create进行类的创建，类名称为class_test</span>
	<span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"device_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用device_create进行设备的创建，设备名称为device_test</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">atomic_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">,</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的设备</span>
	<span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除创建的类</span>
	<span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除添加的字符设备cdev_test</span>
	<span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放字符设备所申请的设备号</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>atomic_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>atomic_exit<span class="token punctuation">)</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="24-2-2-编写测试APP"><a href="#24-2-2-编写测试APP" class="headerlink" title="24.2.2 编写测试APP"></a>24.2.2 编写测试APP</h4><p>本实验应用程序对应的网盘路径为： iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\19\app。</p>
<p><strong>本测试app 代码和上一章节相同</strong>，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，</p>
<h3 id="24-3-运行测试"><a href="#24-3-运行测试" class="headerlink" title="24.3 运行测试"></a>24.3 运行测试</h3><h4 id="24-3-1-编译驱动程序"><a href="#24-3-1-编译驱动程序" class="headerlink" title="24.3.1 编译驱动程序"></a>24.3.1 编译驱动程序</h4><p>在上一小节中的mutex.c 代码同一目录下创建Makefile 文件，Makefile 文件内容。然后使用命令“make”进行驱动的编译，编译完生成mutex.ko 目标文件，至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h4 id="24-3-2-编译应用程序"><a href="#24-3-2-编译应用程序" class="headerlink" title="24.3.2 编译应用程序"></a>24.3.2 编译应用程序</h4><p>来到应用程序app.c 文件的存放路径如下图（图24-5）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161036677.png" alt="image-20240816103619606"></p>
<p>然后使用以下命令对app.c 进行交叉编译，编译完成如下图（图24-6）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> app app.c <span class="token parameter variable">-static</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>生成的app 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<p>24.3.3 运行测试<br>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图24-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod mutex.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161037098.png" alt="image-20240816103708022"></p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test 进行查看，如下图（图24-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/device_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161037604.png" alt="image-20240816103726533"></p>
<p>可以看到device_test 节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图24-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app /dev/device_test topeet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161037420.png" alt="image-20240816103747343"></p>
<p>可以看到传递的buf 值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图24-10）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./app /dev/device_test topeet <span class="token operator">&amp;</span>
./app /dev/device_test itop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161038388.png" alt="image-20240816103812299"></p>
<p>与23 章实验测试现象相同，两个app 被同时运行，最终打印信息正常，证明数据被正确传递了，没有发生共享资源的竞争，证明互斥量就起到了作用。<br>最后可以使用以下命令进行驱动的卸载，如下图（图24-11）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod mutex.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161038563.png" alt="image-20240816103834491"></p>
<p>至此，互斥体实验就完成了。</p>
<h1 id="第四篇高级字符设备进阶"><a href="#第四篇高级字符设备进阶" class="headerlink" title="第四篇高级字符设备进阶"></a>第四篇高级字符设备进阶</h1><h2 id="第25-章IO-模型引入实验"><a href="#第25-章IO-模型引入实验" class="headerlink" title="第25 章IO 模型引入实验"></a>第25 章IO 模型引入实验</h2><p>我们经常提到IO、NIO 这些名词。那么，到底什么是IO 呢？什么又是NIO 呢？另外，我们平时又会听到两组很相似的概念：阻塞/非阻塞、同步/异步。那么，阻塞和非阻塞有什么区别呢？同步和异步的差别又在哪里呢？</p>
<p>为了更好的理解IO 模型，在本章节将对IO 的概念、IO 的执行过程及IO 模型的分类进行详细分析，下面就让我们一起进入IO 的世界吧！</p>
<h3 id="25-1-IO-的概念"><a href="#25-1-IO-的概念" class="headerlink" title="25.1 IO 的概念"></a>25.1 IO 的概念</h3><p>IO 是英文Input 和Output 的首字母，代表了输入和输出，当然这样的描述有一点点抽象，更直观的意思是计算机的输入与输出。在冯.诺依曼结构中，将计算机分成了5 个部分，分别是运算器，控制器，存储器，输入设备，输出设备。如下图（图25-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161043409.png" alt="image-20240816104322308"></p>
<p>上图中的输入设备指的是鼠标和键盘等向计算机输入数据和信息的设备，输出设备指的是电脑显示器等用于计算机信息输出的设备，下面对计算机输入输出过程进行实际举例，当敲击键盘（输入设备）任意按键后，按键的数据会传递给计算机，计算机CPU 会对数据进行运算，运算完成之后会将数据输出到显示器（输出设备）上，整个过程如下图（图25-2）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161043303.png" alt="image-20240816104343227"></p>
<p>上述事例中，鼠标、显示器只是输入输出的直观表现形式，而在计算机架构层面上，IO 是涉及计算机核心与其他设备间数据迁移的过程。以磁盘IO 为例，内存读取磁盘数据和将内存数据写入磁盘，就是一对输入输出的过程。</p>
<p>至此，对于IO 的概念就讲解完成了，在下一小节中将对IO 执行过程进行分析。</p>
<h3 id="25-2-IO-执行过程"><a href="#25-2-IO-执行过程" class="headerlink" title="25.2 IO 执行过程"></a>25.2 IO 执行过程</h3><p>操作系统（Linux）负责对计算机的资源进行管理和对进程进行调度，应用程序运行在操作系统上，处于用户空间。应用程序不能直接对硬件进行操作，只能通过操作系统提供的API 来操作硬件。需要将进程切换到内核空间，才能进行IO 操作，并且应用程序不能直接操作内核空间的数据，需要把内核空间的数据拷贝到用户空间。</p>
<p>应用程序运行在用户空间，它不存在实质的IO 过程，真正的IO 是在操作系统执行的。那么应用程序操作IO 就会有两个动作：IO 调用和IO 执行。IO 调用是应用程序向操作系统内核发起调用，IO 执行是操作系统内核完成的IO 操作。</p>
<p>一个完整的IO 过程需要包含以下三个步骤，如下图（图25-3）所示：</p>
<ul>
<li>（1） 用户空间的应用程序向内核发起IO 调用请求(系统调用)</li>
<li>（2） 内核操作系统准备数据，把IO 设备的数据加载到内核缓冲区</li>
<li>（3） 操作系统拷贝数据，把内核缓冲区的数据拷贝到用户进程缓冲区</li>
</ul>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161045022.png" alt="image-20240816104518918"></p>
<h3 id="25-3-IO-模型的分类"><a href="#25-3-IO-模型的分类" class="headerlink" title="25.3 IO 模型的分类"></a>25.3 IO 模型的分类</h3><p>假设有这样一个场景，从磁盘中循环读取100M 的数据并处理，磁盘读取100M 需要花费20 秒的时间，CPU 同样也需要20 秒的时间处理完这些数据。如果采用传统的模式编写代码：读数据-&gt;等待数据读取完毕-&gt;数据处理，可以发现，数据的读取花费了一半的时间，而这就导致该任务的效率极其低下，那么能不能在等待数据的同时对数据进行处理呢？当然可以！这时候就轮到IO 编程模型来出场了。</p>
<p>IO 模型根据实现的功能可以划分为为<strong>阻塞IO、非阻塞IO、信号驱动IO， IO 多路复用和异步IO</strong>。根据等待IO 的执行结果进行划分，前四个IO 模型又被称为同步IO，如下图（图25-3）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161046354.png" alt="image-20240816104637272"></p>
<p>所谓同步，即发出一个功能调用后，只有得到结果该调用才会返回。异步的概念和同步相对。当一个异步过程调用发出后，调用者并不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>以现实生活去餐馆吃饭为例，根据菜单进行点餐之后，这时会存在两个选择，第一个选择是在餐馆等待饭菜制作完毕，这就是同步IO 的具体表现。第二个选择是，离开餐馆去做其他的事情，工作人员会在饭菜制作完成之后提醒你回餐馆取餐，这就是异步IO 的具体表现。</p>
<p><strong>下面让我们来认识一下这五种IO 模型。</strong></p>
<p><strong>1 阻塞IO</strong></p>
<p>以阻塞读为例：进程进行IO 操作时(如read 操作)，首先会发起一个系统调用，从而转到内核空间进行处理，内核空间的数据没有准备就绪时，进程会被阻塞，不会继续向下执行，直到内核空间的数据准备完成后，数据才会从内核空间拷贝到用户空间，最后返回用户进程，由用户空间进行数据的处理，如下图（图25-5）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161048675.png" alt="image-20240816104822588" style="zoom:80%;">

<p>以现实生活中的钓鱼为例，在做好相应准备抛下鱼钩之后，需要耐心等待鱼儿的上钩，等待的过程中必须聚精会神的关注鱼竿的状态，鱼儿上钩之后立刻扬竿，这就是阻塞IO 在实际生活中的事例。</p>
<p>通过上述例子可以总结出阻塞IO 的优势与不足，首先可以及时的获取结果，并立刻对获取到的结果进行处理，然而在获取结果之前，无法去处理其他任务，需要时刻对结果进行监听。</p>
<p>阻塞IO 比较有代表性的是C 语言中的scanf()函数。编写好的io.c 文件，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i = %d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在以上代码中，scanf 函数用于从键盘上接收数据，如果键盘不进行数据的输入，该任务会持续阻塞，只有键盘输入数据之后，才会有相应的输入值打印到系统终端上。输入以下命令进行可执行文件的编译，如下（图25-7）所示</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc io.c <span class="token parameter variable">-o</span> io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>编译完成之后，输入“./io”运行可执行文件，如下所示，键盘没有输入数据时，该任务会持续阻塞，当在键盘上输入“123”之后，输入的值才会被打印出来，如下（图25-9）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161050960.png" alt="image-20240816105003887"></p>
<p><strong>2 非阻塞IO</strong></p>
<p>和阻塞IO 模型不同，非阻塞IO 进行IO 操作时，如果内核数据没有准备好，内核会立即向进程返回err，不会进行阻塞；如果内核空间数据准备就绪，内核会立即把数据返回给用户空间的进程，如下图（图25-10）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161050713.png" alt="image-20240816105055631" style="zoom:80%;">

<p>仍旧以现实生活中钓鱼为例，在做好相应准备抛下鱼钩之后，这次并没有持续不断的关注鱼竿的状态，而是去做其他的事情（不阻塞等待结果），每隔几分钟对鱼竿的状态进行检查，如果没有鱼儿上钩，就继续去做其他事情，如果上钩了就把鱼钓上来,这就是非阻塞IO 在实际生活中的事例。</p>
<p>从上述案例中可以看出非阻塞IO 的优点是效率高，同样的时间可以做更多的事。但是缺点也很明显，需要不断对结果进行轮询查看，从而导致结果获取不及时（结果可能在两次轮询之间就已经准备完毕，但是只能在发起轮询的时候才能知道），如果要增加非阻塞IO 的实时性，就要加快轮询的频率，但这样无疑也会增加CPU 的负担。</p>
<p><strong>3 IO 多路复用</strong></p>
<p>通常情况下使用select()、poll()、epoll()函数实现IO 多路复用。这里以select 函数为例进行讲解，使用时可以对select 传入多个描述符，并设置超时时间。当执行select 的时候，系统会发起一个系统调用，内核会遍历检查传入的描述符是否有事件发生（如可读、可写事件）。如有，立即返回，否则进入睡眠状态，使进程进入阻塞状态，直到任何一个描述符事件产生后（或者等待超时）立刻返回。此时用户空间需要对全部描述符进行遍历，以确认具体是哪个发生了事件，这样就能使用一个进程对多个IO 进行管理，如下图（图25-11）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161051898.png" alt="image-20240816105159819" style="zoom:80%;">

<p>继续以现实生活中的钓鱼为例，和之前案例只有一个鱼竿不同，这次会在十个不同的地方做好相应准备抛下鱼钩，并把十个鱼竿连在了一个铃铛上，这样只要铃铛响了就表示有鱼上钩，只需挨个检查到底是哪个鱼竿有鱼上钩即可。</p>
<p>这样的优点是一个进程/线程可以同时监听和处理多路IO，效率成倍提高。但是IO 多路复用并不是能医治百病的良药，虽然IO 多路复用可以监听多个IO，但是实际上对结果的处理也只能依次进行，比较适合IO 密集但是每一路IO 数据量不多且到达时间分散的场合（如网络聊天）。</p>
<p>另外select 监听的描述符有上限（一般描述符最大不超过1024），而且需要遍历究竟是哪一个IO 产生了数据。因此IO 较多时，效率不高（这个问题被epoll 解决，感兴趣的读者可以自行了解）。</p>
<p><strong>4 信号驱动</strong></p>
<p>信号驱动IO 顾名思义与信号相关。系统在一些事件发生之后，会对进程发出特定的信号，而信号与处理函数相绑定，当信号产生时就会调用绑定的处理函数。例如在Linux 系统任务执行的过程中可以按下ctrl+C 来对任务进行终止，系统实际上是对该进程发送一个SIGINT 信号，该信号的默认处理函数就是退出当前程序。</p>
<p>具体到IO 模型上，可以对SIGIO 信号注册相应的信号处理函数，并打开对应描述符的信号驱动。每当有IO 数据产生时，系统就会发送一个SIGIO 信号，进而调用相应的信号处理函数，从而在这个处理函数中对数据进行读取，如下图（图25-12）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161053783.png" alt="image-20240816105341698" style="zoom:80%;">

<p>仍旧以现实生活中的钓鱼为例，在做好相应准备抛下鱼钩之后，这次同样没有持续不断的关注鱼竿的状态，而是去做其他的事情（不阻塞等待结果），与之前不同的是，在鱼竿处绑定了一个提醒铃铛，当鱼咬钩之后，铃铛就会响(有SIGIO 信号)，进而得知到鱼儿上钩的消息之，这样就可以及时把鱼钓上来了(调用处理函数)。</p>
<p><strong>5 异步IO</strong></p>
<p>aio_read 函数常常用于异步IO，当进程使用aio_read 读取数据时，如果数据尚未准备就绪就立即返回，不会阻塞。若数据准备就绪就会把数据从内核空间拷贝到用户空间的缓冲区中，然后执行定义好的回调函数对接收到的数据进行处理。</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161054722.png" alt="image-20240816105415638" style="zoom:80%;">

<p>最后，还是以钓鱼为例。小马同学喜欢吃新鲜的鱼，但是不想自己钓，所以他请了一个助手来帮他钓鱼，他自己去忙其他的事情（进程不阻塞，立即返回）。如果有鱼上钩助手会帮忙钓上来（将数据拷贝到指定的缓冲区），并立即通知小马同学回来把鱼取走（处理数据）。</p>
<h2 id="第26-章阻塞IO-实验"><a href="#第26-章阻塞IO-实验" class="headerlink" title="第26 章阻塞IO 实验"></a>第26 章阻塞IO 实验</h2><p>在上一章节，对IO 的相关概念和五种IO 模型分类进行了学习，在接下来的章节中将分别对四种同步IO 进行详细的讲解和实验，本章节要讲解的IO 模型是阻塞IO，阻塞IO 在Linux内核中是非常常用的IO 模型，所依赖的机制是等待队列。下面让我们来开始阻塞IO 的学习吧。</p>
<h3 id="26-1-什么是等待队列"><a href="#26-1-什么是等待队列" class="headerlink" title="26.1 什么是等待队列"></a>26.1 什么是等待队列</h3><p>在Linux 驱动程序中，阻塞进程可以使用等待队列来实现。<strong>等待队列是内核实现阻塞和唤醒的内核机制</strong>，以双循环链表为基础结构，由链表头和链表项两部分组成，分别表示等待队列头和等待队列元素，如下图（图26-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161101590.png" alt="image-20240816110111498"></p>
<p>等待队列头使用结构体wait_queue_head_t 来表示，等待队列头是一个等待队列的头部，这个结构体定义在文件include/linux/wait.h 里面，结构体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">_wait_queue_head</span><span class="token punctuation">{</span>
    <span class="token class-name">spinlock_t</span> lock<span class="token punctuation">;</span> <span class="token comment">//自旋锁</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> task_list <span class="token comment">//链表头</span>
<span class="token punctuation">}</span>；
typefef <span class="token keyword">struct</span> <span class="token class-name">_wait_queue_head</span> <span class="token class-name">wait_queue_head_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>等待队列项使用结构体<code>wait_queue_t</code> 来表示，等待队列项是等待队列元素，该结构体同样定义在文件<code>include/linux/wait.h</code> 里面，结构体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">_wait_queue</span><span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>private<span class="token punctuation">;</span>
    <span class="token class-name">wait_queue_func_t</span> func<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> task_list<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_wait_queue</span> <span class="token class-name">wait_queue_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="26-2-等待队列API-函数"><a href="#26-2-等待队列API-函数" class="headerlink" title="26.2 等待队列API 函数"></a>26.2 等待队列API 函数</h3><p><strong>1 定义并初始化等待队列头</strong></p>
<p>等待队列要想被使用，第一步就是对等待队列头进行初始化，有俩种办法如下所示：方法一：使用<code>DECLARE_WAIT_QUEUE_HEAD</code> 宏静态创建等待队列头，宏定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DECLARE_WAIT_QUEUE_HEAD</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token class-name">wait_queue_head_t</span> name <span class="token operator">=</span> <span class="token function">__WAIT_QUEUE_HEAD_INITIALIZER</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>参数name 表示要定义的队列头名字。通常以全局变量的方式定义,如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DECLARE_WAIT_QUEUE_HEAD</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>方法二：使用<code>init_waitqueue_head</code> 宏动态初始化等待队列头，宏定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">init_waitqueue_head</span><span class="token expression"><span class="token punctuation">(</span>q<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">lock_class_key</span> __key<span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
        <span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__init_waitqueue_head</span><span class="token punctuation">(</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">,</span> #q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>__key<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>参数q 表示需要初始化的队列头指针。使用宏定义如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">wait_queue_head_t</span> head<span class="token punctuation">;</span> 		<span class="token comment">//等待队列头</span>
<span class="token function">init_waitqueue_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">//初始化等待队列头指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>然后再来学习如何创建等待队列元素，也就是等待队列项。</p>
<p><strong>2 创建等待队列项</strong></p>
<p>一般使用宏<code>DECLARE_WAITQUEUE(name,tsk)</code>给当前正在运行的进程创建并初始化一个等待队列项，宏定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DECLARE_WAITQUEUE</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> tsk<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">wait_queue_entry</span> name <span class="token operator">=</span> <span class="token function">__WAITQUEUE_INITIALIZER</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> tsk<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>第一个参数name 是等待队列项的名字，第二个参数tsk 表示此等待队列项属于哪个任务（进程），一般设置为current。在Linux 内核中current 相当于一个全局变量，表示当前进程。创建等待队列项如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DECLARE_WAITQUEUE</span><span class="token punctuation">(</span>wait<span class="token punctuation">,</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//给当前正在运行的进程创建一个名为wait 的等待队列项。</span>
<span class="token function">add_wait_queue</span><span class="token punctuation">(</span>wq<span class="token punctuation">,</span><span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将wait 这个等待队列项加到wq 这个等待队列当中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>3 添加/删除队列</strong></p>
<p>当设备没有准备就绪（如没有可读数据）而需要进程阻塞的时候，就需要将进程对应的等待队列项添加到前面创建的等待队列中，只有添加到等待队列中以后进程才能进入休眠态。当设备可以访问时（如有可读数据），再将进程对应的等待队列项从等待队列中移除即可。</p>
<p>等待队列项添加队列函数如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型<span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">add_wait_queue</span><span class="token punctuation">(</span><span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>q<span class="token punctuation">,</span><span class="token class-name">wait_queue_t</span> <span class="token operator">*</span>wait<span class="token punctuation">)</span>
函数功能<span class="token operator">:</span>
    <span class="token punctuation">(</span>通过等待队列头<span class="token punctuation">)</span>向等待队列中添加队列项
参数含义<span class="token operator">:</span>
    wq_head 表示等待队列项要加入等待队列的等待队列头
    wq_entry 表示要加入的等待队列项
函数返回值
    无<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>等待队列项移除队列函数如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">void</span> <span class="token function">remove_wait_queue</span><span class="token punctuation">(</span><span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>q<span class="token punctuation">,</span><span class="token class-name">wait_queue_t</span> <span class="token operator">*</span>wait<span class="token punctuation">)</span>
函数功能：
    要删除的等待队列项所处的等待队列头
函数含义：
    第一个参数q 表示等待队列项要加入等待队列的等待队列头
    第二个参数wait 表示要加入的等待队列项
函数返回值：
    无<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>4 等待事件</strong></p>
<p>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程，使用如下所示的宏，是不可中断的阻塞等待。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__wait_event</span><span class="token expression"><span class="token punctuation">(</span>wq_head<span class="token punctuation">,</span> condition<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">___wait_event</span><span class="token punctuation">(</span>wq_head<span class="token punctuation">,</span> condition<span class="token punctuation">,</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

宏定义功能：
    不可中断的阻塞等待，让调用进程进入不可中断的睡眠状态，在等待队列里面睡眠直到condition 变成真，被内核唤醒。
参数含义：
    第一个参数wq<span class="token operator">:</span> <span class="token class-name">wait_queue_head_t</span> 类型变量
    第二个参数condition <span class="token operator">:</span> 等待条件，为假时才可以进入休眠。如果condition 为真，则不会休眠<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>除此之外，<code>wait_event_interruptible</code> 的宏是可中断的阻塞等待。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__wait_event_interruptible</span><span class="token expression"><span class="token punctuation">(</span>wq_head<span class="token punctuation">,</span> condition<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token function">___wait_event</span><span class="token punctuation">(</span>wq_head<span class="token punctuation">,</span> condition<span class="token punctuation">,</span> TASK_INTERRUPTIBLE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

宏含义功能：
    可中断的阻塞等待，让调用进程进入可中断的睡眠状态，直到condition 变成真被内核唤醒或信号打断唤醒。
参数含义：
    第一个参数wq <span class="token operator">:</span><span class="token class-name">wait_queue_head_t</span> 类型变量
    第二个参数condition <span class="token operator">:</span>等待条件。为假时才可以进入休眠。如果condition 为真，则不会休眠。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>wait_event_timeout()</code> 宏也与<code>wait_event()</code>类似.不过如果所给的睡眠时间为负数则立即返回.如果在睡眠期间被唤醒,且condition 为真则返回剩余的睡眠时间,否则继续睡眠直到到达或超过给定的睡眠时间,然后返回0。</p>
<p><code>wait_event_interruptible_timeout()</code> 宏与<code>wait_event_timeout()</code>类似,不过如果在睡眠期间被信号打断则返回<code>ERESTARTSYS</code> 错误码。<br><code>wait_event_interruptible_exclusive()</code> 宏同样和<code>wait_event_interruptible()</code>一样,不过该睡眠的进程是一个互斥进程</p>
<p>注意：<strong>调用的时要确认condition 值是真还是假，如果调用condition 为真，则不会休眠。</strong></p>
<p><strong>5 等待队列唤醒</strong></p>
<p>当设备可以使用的时候就要唤醒进入休眠态的进程，唤醒可以使用如下俩个函数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
函数功能：
    唤醒所有休眠进程
参数含义：
    q 表示要唤醒的等待队列的等待队列头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token function">wake_up_interruptible</span><span class="token punctuation">(</span><span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
函数功能：
    唤醒可中断的休眠进程
参数含义：
    q 表示要唤醒的等待队列的等待队列头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="26-3-等待队列使用方法"><a href="#26-3-等待队列使用方法" class="headerlink" title="26.3 等待队列使用方法"></a>26.3 等待队列使用方法</h3><ul>
<li>步骤一：初始化等待队列头，并将条件置成假(condition=0)。</li>
<li>步骤二：在需要阻塞的地方调用wait_event()，使进程进入休眠状态。</li>
<li>步骤三：当条件满足时，需要解除休眠，先将条件(condition=1),然后调用wake_up 函数唤醒等待队列中的休眠进程。</li>
</ul>
<h3 id="26-4-实验程序编写"><a href="#26-4-实验程序编写" class="headerlink" title="26.4 实验程序编写"></a>26.4 实验程序编写</h3><h4 id="26-4-1-驱动程序编写"><a href="#26-4-1-驱动程序编写" class="headerlink" title="26.4.1 驱动程序编写"></a>26.4.1 驱动程序编写</h4><p>本实验对应的驱动网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\20\module。<br>接着编写等待队列的实验代码，在此代码中，按照上一小节等待队列使用方法的三个步骤进行编写，在read 函数中调用<code>wait_event_interruptible</code> 函数阻塞，使进程进入休眠状态。在write 函数中唤醒等待队列中的休眠进程。编写好的驱动程序如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/io.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">&lt;linux/wait.h&gt;</span></span>


<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
     <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span>  flag<span class="token punctuation">;</span>  <span class="token comment">//标志位</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span>  <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>  
<span class="token function">DECLARE_WAIT_QUEUE_HEAD</span><span class="token punctuation">(</span>read_wq<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//定义并初始化等待队列头</span>

<span class="token comment">/*打开设备函数*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span><span class="token comment">//设置私有数据</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is cdev_test_open\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*向设备写入数据函数*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_from_user:用户空间向内核空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    test_dev<span class="token operator">-&gt;</span>flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//将条件置1</span>
    <span class="token function">wake_up_interruptible</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_wq<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//并使用wake_up_interruptible唤醒等待队列中的休眠进程</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    
    <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

    <span class="token function">wait_event_interruptible</span><span class="token punctuation">(</span>read_wq<span class="token punctuation">,</span>test_dev<span class="token operator">-&gt;</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//可中断的阻塞等待，使进程进入休眠态</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_to_user:内核空间向用户空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> cdev_test_write<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_release(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chr_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
   dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*5  创建设备*/</span>
  dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

 err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>

err_class_create<span class="token operator">:</span>
       <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>

err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>

err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>




<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chr_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>chr_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chr_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="26-4-2-编写测试APP"><a href="#26-4-2-编写测试APP" class="headerlink" title="26.4.2 编写测试APP"></a>26.4.2 编写测试APP</h4><p>本实验对应的应用程序网盘路径为： <code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\20\app</code>。<br>接下来编写应用程序read.c，此程序实现了从设备读取数据的功能。编写好的应用程序如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   
    <span class="token keyword">char</span> buf2<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开led驱动</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read before \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf1<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从/dev/test文件读取数据</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"buf is %s  \n"</span><span class="token punctuation">,</span>buf1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read after \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//关闭文件</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同理，编写应用程序write.c，实现向设备写入数据的功能，编写好的应用程序如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   
    <span class="token keyword">char</span> buf2<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"nihao"</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开led驱动</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write before \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf2<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向/dev/test文件写入数据</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write after\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//关闭文件</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="26-5-运行测试"><a href="#26-5-运行测试" class="headerlink" title="26.5 运行测试"></a>26.5 运行测试</h3><h4 id="26-5-1-编译驱动程序"><a href="#26-5-1-编译驱动程序" class="headerlink" title="26.5.1 编译驱动程序"></a>26.5.1 编译驱动程序</h4><p>在上一小节中的wq.c 代码同一目录下创建Makefile 文件，Makefile 文件内容。然后使用命令“make”进行驱动的编译，编译完生成wq.ko 目标文件，至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h4 id="26-5-2-编译应用程序"><a href="#26-5-2-编译应用程序" class="headerlink" title="26.5.2 编译应用程序"></a>26.5.2 编译应用程序</h4><p>来到存放应用程序read.c 和write.c 的文件夹下，使用以下命令对read.c 和write.c 进行交叉编译，编译完成如下图（图26-4）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">aarch64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">-</span>gcc <span class="token operator">-</span>o read read<span class="token punctuation">.</span>c <span class="token operator">-</span><span class="token keyword">static</span>
aarch64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">-</span>gcc <span class="token operator">-</span>o write write<span class="token punctuation">.</span>c <span class="token operator">-</span><span class="token keyword">static</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161116530.png" alt="image-20240816111649439"></p>
<p>生成的read write 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="26-5-3-运行测试"><a href="#26-5-3-运行测试" class="headerlink" title="26.5.3 运行测试"></a>26.5.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图26-5）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod wq.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161117069.png" alt="image-20240816111721981"></p>
<p>输入以下命令运行read 可执行文件，如下图（图26-6）所示，read 应用程序进程阻塞</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161117766.png" alt="image-20240816111738676"></p>
<p>然后输入以下命令运行write 可执行文件，如下图（图26-7）所示，使用write 函数向设备写入数据，唤醒等待队列中的休眠进程。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161117587.png" alt="image-20240816111750501"></p>
<p>在使用可执行程序write 向缓冲区写入数据时，read 可执行程序读取到了缓冲区的数据并打印。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161118542.png" alt="image-20240816111836452"></p>
<h2 id="第27-章非阻塞IO-实验"><a href="#第27-章非阻塞IO-实验" class="headerlink" title="第27 章非阻塞IO 实验"></a>第27 章非阻塞IO 实验</h2><p>上个章节中我们学习了阻塞IO，<strong>阻塞IO 是通过等待队列</strong>来实现的，那么如何让驱动实现非阻塞呢？带着疑问，让我们开始本章节非阻塞IO 的学习吧！</p>
<h3 id="27-1-非阻塞IO-简介"><a href="#27-1-非阻塞IO-简介" class="headerlink" title="27.1 非阻塞IO 简介"></a>27.1 非阻塞IO 简介</h3><p>应用程序可以使用如下所示示例代码来实现阻塞访问：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fd<span class="token punctuation">;</span>
<span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/xxx_dev"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 阻塞方式打开*/</span>
ret <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 读取数据*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看出<strong>对于设备驱动文件的默认读取方式就是阻塞式的</strong>，所以之前实验例程测试APP都是采用阻塞IO。<br>如果应用程序要采用非阻塞的方式来访问驱动设备文件，可以使用如下所示代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fd<span class="token punctuation">;</span>
<span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/xxx_dev"</span><span class="token punctuation">,</span> O_RDWR <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 非阻塞方式打开*/</span>
ret <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 读取数据*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用open 函数打开“/dev/xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候是非阻塞方式了。</p>
<h3 id="27-2-实验程序编写"><a href="#27-2-实验程序编写" class="headerlink" title="27.2 实验程序编写"></a>27.2 实验程序编写</h3><h4 id="27-2-1-编写测试APP"><a href="#27-2-1-编写测试APP" class="headerlink" title="27.2.1 编写测试APP"></a>27.2.1 编写测试APP</h4><p>非阻塞IO 实验需要应用程序和驱动配合，所以需要编写驱动代码和应用测试代码。本实验对应的应用程序网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\21\app</code>。<br>首先来编写应用测试代码read.c，在此代码中使用非阻塞的方式打开设备，编写好的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  <span class="token comment">//定义int类型的文件描述符</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//定义读取缓冲区buf</span>
    <span class="token keyword">char</span> buf2<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//定义读取缓冲区buf</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span>O_RDWR<span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开led驱动</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read before \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
         <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf1<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从/dev/test文件读取数据</span>
         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"buf is %s \n"</span><span class="token punctuation">,</span>buf1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打印读取的数据</span>
         <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read after\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//关闭文件</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着编写应用程序write.c，用来向设备文件写入数据，编写好的应用程序如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   
    <span class="token keyword">char</span> buf2<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"nihao"</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span> O_RDWR<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开led驱动</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write before \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf2<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向/dev/test文件写入数据</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write after\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//关闭文件</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="27-2-1-驱动程序编写"><a href="#27-2-1-驱动程序编写" class="headerlink" title="27.2.1 驱动程序编写"></a>27.2.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\21\module</code>。<br>编写好的驱动程序wq.c 如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/io.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">&lt;linux/wait.h&gt;</span></span>


<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>
   
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
     <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span>  flag<span class="token punctuation">;</span>  <span class="token comment">//标志位</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span>  <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>  

<span class="token function">DECLARE_WAIT_QUEUE_HEAD</span><span class="token punctuation">(</span>read_wq<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//定义并初始化等待队列头</span>

<span class="token comment">/*打开设备函数*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span><span class="token comment">//设置私有数据</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*向设备写入数据函数*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_from_user:用户空间向内核空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    test_dev<span class="token operator">-&gt;</span>flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//将条件置1，并使用wake_up_interruptible唤醒等待队列中的休眠进程</span>
    <span class="token function">wake_up_interruptible</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_wq<span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    
    <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_flags <span class="token operator">&amp;</span> O_NONBLOCK <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>flag <span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">wait_event_interruptible</span><span class="token punctuation">(</span>read_wq<span class="token punctuation">,</span>test_dev<span class="token operator">-&gt;</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//可中断的阻塞等待，使进程进入休眠态</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_to_user:内核空间向用户空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> cdev_test_write<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_release(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chr_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
   dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*5  创建设备*/</span>
  dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

 err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>

err_class_create<span class="token operator">:</span>
       <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>

err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>

err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chr_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>chr_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chr_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="27-3-运行测试"><a href="#27-3-运行测试" class="headerlink" title="27.3 运行测试"></a>27.3 运行测试</h3><h4 id="27-3-1-编译驱动程序"><a href="#27-3-1-编译驱动程序" class="headerlink" title="27.3.1 编译驱动程序"></a>27.3.1 编译驱动程序</h4><p>在上一小节中的wq.c 代码同一目录下创建Makefile 文件，Makefile 文件内容，然后使用命令“make”进行驱动的编译，编译完生成wq.ko 目标文件，至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h4 id="27-3-2-编译应用程序"><a href="#27-3-2-编译应用程序" class="headerlink" title="27.3.2 编译应用程序"></a>27.3.2 编译应用程序</h4><p>来到存放应用程序read.c 和write.c 的文件夹下，使用以下命令对read.c 和write.c 进行交叉编译，编译完成如下图（图27-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> <span class="token builtin class-name">read</span> read.c <span class="token parameter variable">-static</span>
aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> <span class="token function">write</span> write.c <span class="token parameter variable">-static</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161128227.png" alt="image-20240816112845130"></p>
<p>生成的read write 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="27-3-3-测试"><a href="#27-3-3-测试" class="headerlink" title="27.3.3 测试"></a>27.3.3 测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图27-5）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod wq.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161129410.png" alt="image-20240816112905317"></p>
<p>输入以下命令运行read 可执行文件，如下图（图27-6）所示，应用程序进程非阻塞，读取不到数据便返回，然后一直轮询查看是否有数据。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161129269.png" alt="image-20240816112920176"></p>
<p>然后输入以下命令运行write 可执行文件向设备文件写入数据，如下图（图27-7）所示:</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161129166.png" alt="image-20240816112932069"></p>
<p>在使用可执行程序write 向缓冲区写入数据时，read 可执行程序读取到了缓冲区的数据并打印。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161129734.png" alt="image-20240816112946639"></p>
<h2 id="第28-章IO-多路复用实验"><a href="#第28-章IO-多路复用实验" class="headerlink" title="第28 章IO 多路复用实验"></a>第28 章IO 多路复用实验</h2><p>在上俩个章节中，我们对阻塞IO 和非阻塞IO 进行了学习，本章节将学习第三种IO 模型-多路复用IO。</p>
<h3 id="28-1-IO-多路复用简介"><a href="#28-1-IO-多路复用简介" class="headerlink" title="28.1 IO 多路复用简介"></a>28.1 IO 多路复用简介</h3><p>IO 多路复用是一种同步的IO 模型。IO 多路复用可以实现一个进程监视多个文件描述符。一旦某个文件描述符准备就绪，就通知应用程序进行相应的读写操作。没有文件描述符就绪时就会阻塞应用程序，从而释放出CPU 资源。</p>
<p>在第25 章中，我们以钓鱼为例，对IO 多路复用有了一个简单的认识。下面对钓鱼例子进行回顾：小李同时放置了十个鱼竿，并把十个鱼竿连在了一个铃铛上。这样小李就不必在岸边等待。当铃铛响了就表示有鱼上钩，再回来挨个检查到底是哪个鱼竿有鱼上钩即可。接着进一步体会IO 多路复用。</p>
<p>在应用层Linux 提供了三种实现IO 多路复用的模型，分别是select、poll 和epoll。在本驱动手册中主要偏重于对驱动的讲解，所以应用层中select、poll 和epoll 函数的使用在这里做重点讲解。</p>
<p>首先来学习下select、poll 和epoll 函数有什么区别呢？poll 函数和seslect 函数都可以监听多个文件描述符，通过轮询来获取已经准备好的文件描述符。但是epoll 函数将主动轮询变成了被动通知，当事件发生时被动接收通知。为了方便理解，举个形象的例子。假如poll 和select是公司的前台，某天一位客户来公司找硬件工程师-小李，请求前台帮忙找人。于是poll 和select前台带着这位客户挨个屋子寻找小李，直到找到小李为止。假如epoll 是公司的前台，他提前统计了公司每个员工的工位。当客户来找小李的时候，不必像poll select 一样，可以直接带着客户到硬件部门去找小李。从上面的俩个例子，明显对比epoll 的效率更高。假如公司园区很大，那么poll select 需要花费很长时间寻找小李，而epoll 已经提前知道小李坐在哪个工位了，直接带客户去找小李即可。</p>
<p>select,poll,epoll 有什么区别呢？在单个线程中，<strong>select 函数最大可以监视1024 个文件描述符</strong>，<strong>而poll 函数和select 函数并没有什么区别</strong>，<strong>只是poll 函数没有最大文件描述符的限制</strong>。在本章节的实验中，以poll 为例进行实验。在Linux 应用程序中poll 函数如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
<span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
函数功能：
    监视并等待多个文件描述符的属性变化
    
函数参数：
    第一个参数fds<span class="token operator">:</span> 要监视的文件描述符集合以及要监视的事件，为一个数组，数组元素都是结构体pollfd 类型，pollfd 结构体如下所示：
        <span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> fd<span class="token punctuation">;</span> <span class="token comment">//被监视的文件描述符</span>
            <span class="token keyword">short</span> events<span class="token punctuation">;</span> <span class="token comment">//等待的事件</span>
            <span class="token keyword">short</span> revents<span class="token punctuation">;</span> <span class="token comment">//实际发生的事件</span>
        <span class="token punctuation">}</span>；
        在pollfd 结构体中，
            第一个成员fd 是被监视的文件描述符。
            第二个成员events 是要监视的事件，可监视的事件类型如下所示：
                    POLLIN 有数据可以读取
                    POLLPRI 有紧急的数据需要读取
                    POLLOUT 可以写数据
                    POLLERR 指定的文件描述符发生错误
                    POLLHUP 指定的文件描述符挂起
                    POLLNVAL 无效的请求
                    POLLRDNORM 等同于POLLIN
            第三个成员是返回事件，由Linux 内核设置具体的返回事件。
    第二个参数nfds<span class="token operator">:</span> poll 函数要监视的文件描述符数量
    第三个参数timeout<span class="token operator">:</span>指定等待的时间，单位是ms。无论I<span class="token operator">/</span>O 是否准备好，时间到，POLL就会返回。如果timepoll 大于<span class="token number">0</span> 等待指定的时间，如果timeout 等于<span class="token number">0</span>，立即返回。如果timeout等于<span class="token operator">-</span><span class="token number">1</span>，事件发生以后才返回。
        
函数返回值：
    失败返回<span class="token operator">-</span><span class="token number">1</span>，成功返回revents 不为<span class="token number">0</span> 的文件描述符个数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当应用程序使用select 或者poll 函数对驱动程序进行非阻塞访问时，驱动程序中file_operations 操作集的poll 函数会执行。所以需要完善驱动中的poll 函数。驱动中的poll 函数原型如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>poll<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">poll_table_struct</span> <span class="token operator">*</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
函数参数：
    filp<span class="token operator">:</span>要打开的文件描述符
    wait<span class="token operator">:</span> 结构体poll_table_struct 类型指针，此参数是由应用程序中传递的。一般此参数要传递给poll_wait 函数。
返回值：
    向应用程序返回资源状态，可以返回的资源状态如下：
    POLLIN 有数据可以读取
    POLLPRI 有紧急的数据需要读取
    POLLOUT 可以写数据
    POLLERR 指定的文件描述符发生错误
    POLLHUP 指定的文件描述符挂起
    POLLNVAL 无效的请求
    POLLRDNORM 等同于POLLIN，普通数据可读。
函数功能：
    这个函数要进行下面两项工作。首先，对可能引起设备文件状态变化的等待队列调用 <span class="token function">poll_wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>将对应的等待队列头添加到 poll_table<span class="token punctuation">.</span>然后返回表示是否能对设备进行无阻塞读写访问的掩码。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>驱动程序的poll 函数中调用poll_wait 函数，<strong>注意！poll_wait 函数是不会引起阻塞的</strong>。poll_wait 函数原型如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">poll_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span><span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>queue<span class="token punctuation">,</span>poll_table <span class="token operator">*</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数<code>queue</code> 是要添加到<code>poll_table</code> 中的等待队列头，参数wait 是<code>poll_table</code>，也就是<code>file_operations</code> 中poll 函数的wait 参数。</p>
<h3 id="28-2-实验程序编写"><a href="#28-2-实验程序编写" class="headerlink" title="28.2 实验程序编写"></a>28.2 实验程序编写</h3><h4 id="28-2-1-编写测试APP"><a href="#28-2-1-编写测试APP" class="headerlink" title="28.2.1 编写测试APP"></a>28.2.1 编写测试APP</h4><p>本实验对应的应用程序网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\22\app。<br>**在应用层Linux 提供了三种API 函数，分别是<code>select</code> <code>poll</code> 和<code>epoll</code>**。本次实验使用poll 函数进行实验，如果对select 和epoll 函数感兴趣，可以查找一些系统编程课程学习。</p>
<p>编写好的应用程序read.c 如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;poll.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//要监视的文件描述符</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   
    <span class="token keyword">char</span> buf2<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">pollfd</span>  fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开/dev/test设备，阻塞式访问</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">.</span>fd <span class="token operator">=</span>fd<span class="token punctuation">;</span>
    fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLIN<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read before \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span>fds<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"time out !!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">==</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf1<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从/dev/test文件读取数据</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"buf is %s \n"</span><span class="token punctuation">,</span>buf1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read after\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//关闭文件</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码第16 行，在打开设备节点时不使用非阻塞方式，要使用阻塞方式，所以改为O_RDWR。</p>
<p>在上述代码的第28 行，使用poll 函数监视并等待多个文件描述符的属性变化。poll 函数第1个参数是被监视的文件描述符，是pollfd 结构体类型的数组，所以在14 行定义了pollfd结构体类型的数组fds。poll 函数第2个参数是要监视的文件描述符数量，这里监视的文件描述符为1 个。poll 函数第3 个参数是指定等待的时间3000ms。</p>
<p>然后编写应用程序write.c，实现向设备文件写入数据的功能，编写好的write.c 如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   
    <span class="token keyword">char</span> buf2<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"nihao"</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开led驱动</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write before \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf2<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向/dev/test文件写入数据</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write after\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//关闭文件</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="28-2-2-驱动程序编写"><a href="#28-2-2-驱动程序编写" class="headerlink" title="28.2.2 驱动程序编写"></a>28.2.2 驱动程序编写</h4><p>本实验对应的驱动程序网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\22\module</code>。<br>IO 多路复用实验需要应用程序和驱动程序进行配合，接下来编写驱动程序。编写好的驱动程序如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/io.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">&lt;linux/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/poll.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>
   
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
     <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span>  flag<span class="token punctuation">;</span>  <span class="token comment">//标志位</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span>  <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>  
<span class="token function">DECLARE_WAIT_QUEUE_HEAD</span><span class="token punctuation">(</span>read_wq<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//定义并初始化等待队列头</span>

<span class="token comment">/*打开设备函数*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span><span class="token comment">//设置私有数据</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*向设备写入数据函数*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_from_user:用户空间向内核空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    test_dev<span class="token operator">-&gt;</span>flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">wake_up_interruptible</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_wq<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_flags <span class="token operator">&amp;</span> O_NONBLOCK <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>flag <span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">wait_event_interruptible</span><span class="token punctuation">(</span>read_wq<span class="token punctuation">,</span>test_dev<span class="token operator">-&gt;</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_to_user:内核空间向用户空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span>  __poll_t  <span class="token function">cdev_test_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">poll_table_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>  <span class="token comment">//设置私有数据</span>
     __poll_t mask<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    
     <span class="token function">poll_wait</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span><span class="token operator">&amp;</span>read_wq<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//应用阻塞</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    
     <span class="token punctuation">{</span>
         mask <span class="token operator">|=</span> POLLIN<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">return</span> mask<span class="token punctuation">;</span>
     
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> cdev_test_write<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_release(...)函数</span>
    <span class="token punctuation">.</span>poll <span class="token operator">=</span> cdev_test_poll<span class="token punctuation">,</span>  <span class="token comment">//将poll字段指向chrdev_poll(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chr_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
   dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*5  创建设备*/</span>
  	dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
    err_class_create<span class="token operator">:</span>
        <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chr_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>chr_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chr_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先在第9 行代码添加<code>&lt;linux/poll.h&gt;头文件</code>。然后在第94 行将poll 字段指向<code>chrdev_poll(...)</code>函数，最后在73 行到84 行编写这个函数。</p>
<h3 id="28-3-运行测试"><a href="#28-3-运行测试" class="headerlink" title="28.3 运行测试"></a>28.3 运行测试</h3><h4 id="28-3-1-编译驱动程序"><a href="#28-3-1-编译驱动程序" class="headerlink" title="28.3.1 编译驱动程序"></a>28.3.1 编译驱动程序</h4><p>在上一小节中的poll.c 代码同一目录下创建Makefile 文件，Makefile 文件内容，然后使用命令“make”进行驱动的编译，编译完生成poll.ko 目标文件，至此驱动模块就编译成功了，下面进行应用程序read.c 和write.c 的编译。</p>
<h4 id="28-3-2-编译应用程序"><a href="#28-3-2-编译应用程序" class="headerlink" title="28.3.2 编译应用程序"></a>28.3.2 编译应用程序</h4><p>来到存放应用程序read.c 和write.c 的文件夹下，使用以下命令对read.c 和write.c 进行交叉编译，编译完成如下图（图28-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> <span class="token builtin class-name">read</span> read.c <span class="token parameter variable">-static</span>
aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> <span class="token function">write</span> write.c <span class="token parameter variable">-static</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161157602.png" alt="image-20240816115729497"></p>
<p>生成的read write 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="28-3-3-测试"><a href="#28-3-3-测试" class="headerlink" title="28.3.3 测试"></a>28.3.3 测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图28-5）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161157503.png" alt="image-20240816115751402"></p>
<p>在加载驱动程序之后，会生成如下图（图28-6）所示的设备节点，在应用程序中也是操作这个设备节点。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161158987.png" alt="image-20240816115802890"></p>
<p>首先运行read 可执行程序，如下（图28-7）所示，在三秒钟以后打印“time out”。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161158688.png" alt="image-20240816115809589"></p>
<p>然后运行write 可执行程序写入数据，如下（图28-8）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161158045.png" alt="image-20240816115816950"></p>
<p>接着可以看到read 读取到了数据，如下（图28-9）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161158665.png" alt="image-20240816115829563"></p>
<h2 id="第29-章信号驱动IO-实验"><a href="#第29-章信号驱动IO-实验" class="headerlink" title="第29 章信号驱动IO 实验"></a>第29 章信号驱动IO 实验</h2><p>本章节要讲解的信号驱动IO 是最后一个IO 模型，在第25 章中我们已经对信号驱动IO 有了基本的认识，本章节将对信号驱动IO 进行深入的学习，最后通过相应的实验，来加深对信号驱动IO 的理解。</p>
<h3 id="29-1-信号驱动IO-简介"><a href="#29-1-信号驱动IO-简介" class="headerlink" title="29.1 信号驱动IO 简介"></a>29.1 信号驱动IO 简介</h3><p>信号驱动IO 不需要应用程序查询设备的状态，一旦设备准备就绪，会触发SIGIO 信号，进而调用注册的处理函数。仍旧以钓鱼为例。小马同学喜欢吃新鲜的鱼，但是不想自己钓，所以他请了一个助手来帮他钓鱼，他自己去忙其他的事情（进程不阻塞，立即返回）。如果有鱼上钩助手会帮忙钓上来（将数据拷贝到指定的缓冲区），并立即通知小马同学回来把鱼取走（处理数据）。</p>
<p>如果要实现信号驱动IO，需要应用程序和驱动程序配合，应用程序使用信号驱动IO 的步骤有三步：</p>
<ul>
<li>步骤1 ：注册信号处理函数应用程序使用signal 函数来注册SIGIO 信号的信号处理函数。</li>
<li>步骤2： 设置能够接收这个信号的进程</li>
<li>步骤3： 开启信号驱动IO 通常使用fcntl 函数的F_SETFL 命令打开FASYNC 标志。</li>
</ul>
<p>fcntl 函数如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">int</span> <span class="token function">fcntl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
函数功能：
    fcntl 函数可以用来操作文件描述符
函数参数<span class="token operator">:</span>
    fd<span class="token operator">:</span> 被操作的文件描述符
    cmd<span class="token operator">:</span> 操作文件描述符的命令，cmd 参数决定了要如何操作文件描述符fd
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">:</span> 根据cmd 的参数来决定是不是需要使用第三个参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>操作文件描述符的命令如下表（表29-1）所示：</p>
<table>
<thead>
<tr>
<th>命令名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F_DUPFD</td>
<td>复制文件描述符</td>
</tr>
<tr>
<td>F_GETFD</td>
<td>获取文件描述符标志</td>
</tr>
<tr>
<td>F_SETFD</td>
<td>设置文件描述符标志</td>
</tr>
<tr>
<td>F_GETFL</td>
<td>获取文件状态标志</td>
</tr>
<tr>
<td>F_SETFL</td>
<td>设置文件状态标志</td>
</tr>
<tr>
<td>F_GETLK</td>
<td>获取文件锁</td>
</tr>
<tr>
<td>F_SETLK</td>
<td>设置文件锁</td>
</tr>
<tr>
<td>F_SETLKW</td>
<td>类似F_SETLK，但等待返回</td>
</tr>
<tr>
<td>F_GETOWN</td>
<td>获取当前接收SIGIO 和SIGURG 信号的进程ID 和进程组ID</td>
</tr>
<tr>
<td>F_SETOWN</td>
<td>设置当前接收SIGIO 和SIGURG 信号的进程ID 和进程组ID</td>
</tr>
</tbody></table>
<p>接下来学习驱动程序实现fasync 方法</p>
<p><strong>步骤1</strong></p>
<p>当应用程序开启信号驱动IO 时，会触发驱动中的fasync 函数。所以首先在<code>file_operations</code>结构体中实现<code>fasync</code> 函数，函数原型如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fasync<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span><span class="token keyword">int</span> on<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>步骤2</strong></p>
<p>在驱动中的<code>fasync</code> 函数调用<code>fasync_helper</code> 函数来操作<code>fasync_struct</code> 结构体，<code>fasync_helper</code>函数原型如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fasync_helper</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span><span class="token keyword">int</span> on<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">fasync_struct</span> <span class="token operator">*</span><span class="token operator">*</span>fapp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>步骤3：</strong></p>
<p>当设备准备好的时候，驱动程序需要调用<code>kill_fasync</code> 函数通知应用程序，此时应用程序的<code>SIGIO</code> 信号处理函数就会被执行。<code>kill_fasync</code> 负责发送指定的信号，函数原型如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kill_fasync</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">fasync_struct</span> <span class="token operator">*</span><span class="token operator">*</span>fp<span class="token punctuation">,</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span><span class="token keyword">int</span> band<span class="token punctuation">)</span>
函数参数：
    fp<span class="token operator">:</span> 要操作的fasync_struct
    sig<span class="token operator">:</span> 发送的信号
    band<span class="token operator">:</span> 可读的时候设置成POLLIN ，可写的时候设置成POLLOUT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="29-2-实验程序编写"><a href="#29-2-实验程序编写" class="headerlink" title="29.2 实验程序编写"></a>29.2 实验程序编写</h3><h4 id="29-2-1-编写测试APP"><a href="#29-2-1-编写测试APP" class="headerlink" title="29.2.1 编写测试APP"></a>29.2.1 编写测试APP</h4><p>本实验对应的应用程序网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\23\app</code>。<br>编写应用程序write.c，在此代码中，调用write 函数向/dev/test 设备写入数据“nihao”。编写好的程序如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   
    <span class="token keyword">char</span> buf2<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"nihao"</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开led驱动</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write before \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf2<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向/dev/test文件写入数据</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write after\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//关闭文件</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后来编写应用程序read.c，在此代码中要使用信号驱动IO 读取数据。编写好的应用程序如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;poll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

<span class="token keyword">int</span> fd<span class="token punctuation">;</span>
<span class="token keyword">char</span> buf1<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   

<span class="token comment">//SIGIO信号的信号处理函数</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf1<span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"buf is %s\n"</span><span class="token punctuation">,</span>buf1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打开led驱动</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">signal</span><span class="token punctuation">(</span>SIGIO<span class="token punctuation">,</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//步骤一：使用signal函数注册SIGIO信号的信号处理函数</span>
    <span class="token comment">//步骤二：设置能接收这个信号的进程</span>
    <span class="token comment">//fcntl函数用来操作文件描述符，</span>
    <span class="token comment">//F_SETOWN 设置当前接收的SIGIO的进程ID</span>
    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_SETOWN<span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

    flags <span class="token operator">=</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_GETFD<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取文件描述符标志</span>
    <span class="token comment">//步骤三  开启信号驱动IO 使用fcntl函数的F_SETFL命令打开FASYNC标志</span>
    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>flags<span class="token operator">|</span> FASYNC<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//关闭文件</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="29-2-2-驱动程序编写"><a href="#29-2-2-驱动程序编写" class="headerlink" title="29.2.2 驱动程序编写"></a>29.2.2 驱动程序编写</h4><p>本实验对应的驱动程序网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\23\module</code>。<br>接下来编写驱动程序，在29.1 小节中介绍了驱动程序中实现fasync 方法的三个步骤，按照这个思路，依次实现这三步，编写好的驱动程序如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/io.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">&lt;linux/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/poll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/signal.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>
   
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
     <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span>  flag<span class="token punctuation">;</span>  <span class="token comment">//标志位</span>
    <span class="token keyword">struct</span> <span class="token class-name">fasync_struct</span> <span class="token operator">*</span>fasync<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span>  <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>  

<span class="token function">DECLARE_WAIT_QUEUE_HEAD</span><span class="token punctuation">(</span>read_wq<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//定义并初始化等待队列头</span>

<span class="token comment">/*打开设备函数*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span><span class="token comment">//设置私有数据</span>
   
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*向设备写入数据函数*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_from_user:用户空间向内核空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    test_dev<span class="token operator">-&gt;</span>flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">wake_up_interruptible</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_wq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">kill_fasync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_dev<span class="token operator">-&gt;</span>fasync<span class="token punctuation">,</span>SIGIO<span class="token punctuation">,</span>POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_flags <span class="token operator">&amp;</span> O_NONBLOCK <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>flag <span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">wait_event_interruptible</span><span class="token punctuation">(</span>read_wq<span class="token punctuation">,</span>test_dev<span class="token operator">-&gt;</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span> test_dev<span class="token operator">-&gt;</span>kbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// copy_to_user:内核空间向用户空间传数据</span>
    <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span>  __poll_t  <span class="token function">cdev_test_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">poll_table_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>  <span class="token comment">//设置私有数据</span>
     __poll_t mask<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    
     <span class="token function">poll_wait</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span><span class="token operator">&amp;</span>read_wq<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//应用阻塞</span>

     <span class="token keyword">if</span> <span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    
     <span class="token punctuation">{</span>
         mask <span class="token operator">|=</span> POLLIN<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">return</span> mask<span class="token punctuation">;</span>
     
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_fasync</span> <span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">int</span> on<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>  <span class="token comment">//设置私有数据</span>
    <span class="token keyword">return</span>  <span class="token function">fasync_helper</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>file<span class="token punctuation">,</span>on<span class="token punctuation">,</span><span class="token operator">&amp;</span>test_dev<span class="token operator">-&gt;</span>fasync<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> cdev_test_write<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_release(...)函数</span>
    <span class="token punctuation">.</span>poll <span class="token operator">=</span> cdev_test_poll<span class="token punctuation">,</span>  <span class="token comment">//将poll字段指向chrdev_poll(...)函数</span>
    <span class="token punctuation">.</span>fasync <span class="token operator">=</span> cdev_test_fasync<span class="token punctuation">,</span>   <span class="token comment">//将fasync字段指向cdev_test_fasync(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">chr_fops_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
   dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*5  创建设备*/</span>
  dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
    err_class_create<span class="token operator">:</span>
        <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">chr_fops_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>chr_fops_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>chr_fops_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="29-3-运行测试"><a href="#29-3-运行测试" class="headerlink" title="29.3 运行测试"></a>29.3 运行测试</h3><h4 id="29-3-1-编译程序"><a href="#29-3-1-编译程序" class="headerlink" title="29.3.1 编译程序"></a>29.3.1 编译程序</h4><p>在上一小节中的fasync.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成fasync.ko 目标文件，如下图（图29-4）所示：至此驱动模块就编译成功了，下面进行交叉编译应用程序。</p>
<h4 id="29-3-2-编译应用程序"><a href="#29-3-2-编译应用程序" class="headerlink" title="29.3.2 编译应用程序"></a>29.3.2 编译应用程序</h4><p>来到存放应用程序read.c 和write.c 的文件夹下，使用以下命令对read.c 和write.c 进行交叉编译，编译完成如下图（图29-5）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> <span class="token builtin class-name">read</span> read.c <span class="token parameter variable">-static</span>
aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> <span class="token function">write</span> write.c <span class="token parameter variable">-static</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161423330.png" alt="image-20240816142309220"></p>
<p>生成的read write 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="29-3-3-测试"><a href="#29-3-3-测试" class="headerlink" title="29.3.3 测试"></a>29.3.3 测试</h4><p>输入以下命令加载驱动程序。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod fasync.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161423433.png" alt="image-20240816142357316"></p>
<p>输入以下命令运行read 应用程序，如下图（图29-7）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161424997.png" alt="image-20240816142406896"></p>
<p>然后输入以下命令运行write 应用程序，如下图（图29-8）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161424028.png" alt="image-20240816142416924"></p>
<p>如下图（图29-9）所示，read 程序窗口打印读取的数据。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161425471.png" alt="image-20240816142511366"></p>
<h2 id="第30-章定时器实验"><a href="#第30-章定时器实验" class="headerlink" title="第30 章定时器实验"></a>第30 章定时器实验</h2><p>在Linux 内核中很多函数是基于定时器进行驱动的，所以时间管理在内核中占有非常重要的地位。本小节将对Linux 中的时间管理相关知识进行学习.</p>
<h3 id="30-1-Linux-定时器"><a href="#30-1-Linux-定时器" class="headerlink" title="30.1 Linux 定时器"></a>30.1 Linux 定时器</h3><p>硬件为内核提供了一个系统定时器来计算流逝的时间（<strong>即基于未来时间点的计时方式，以当前时刻为计时开始的起点，以未来的某一时刻为计时的终点</strong>），内核只有在系统定时器的帮助下才能计算和管理时间，但是内核定时器的精度并不高，所以不能作为高精度定时器使用。并且内核定时器的运行没有周期性，到达计时终点后会自动关闭。<strong>如果要实现周期性定时，就要在定时处理函数中重新开启定时器</strong>。</p>
<p>Linux 内核中使用timer_list 结构体表示内核定时器，该结构体定义在“<code>内核源码/include/linux/timer.h</code>”文件中，具体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">hlist_node</span> entry<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> expires<span class="token punctuation">;</span>					<span class="token comment">/* 定时器超时时间，单位是节拍数*/</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>function<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	 <span class="token comment">/* 定时处理函数*/</span>
    u32 flags<span class="token punctuation">;</span>
    
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_LOCKDEP</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">lockdep_map</span> lockdep_map<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token function">ANDROID_KABI_RESERVE</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ANDROID_KABI_RESERVE</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用以下宏对timer_list 结构体进行定义，_name 为定义的结构体名称，_function 为定时处理函数，该宏同样定义在文件“<code>内核源码/include/linux/timer.h</code>”文件中，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DEFINE_TIMER</span><span class="token expression"><span class="token punctuation">(</span>_name<span class="token punctuation">,</span> _function<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">timer_list</span> _name <span class="token operator">=</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token function">__TIMER_INITIALIZER</span><span class="token punctuation">(</span>_function<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>例如可以使用以下代码对定时器和相应的定时处理函数进行定义</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_TIMER</span><span class="token punctuation">(</span>timer_test<span class="token punctuation">,</span>function_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义一个定时器</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>定时器定义完成之后还需要通过一系列的API 函数来初始化此定时器，部分函数说明如下(表30-1)所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>void add_timer(struct timer_list *timer)</code></td>
<td>向Linux 内核注册定时器，使用add_timer 函数<br>向内核注册定时器以后，定时器就会开始运行</td>
</tr>
<tr>
<td><code>int del_timer(struct timer_list * timer)</code></td>
<td>删除一个定时器</td>
</tr>
<tr>
<td>int mod_timer(struct timer_list *timer,unsigned long expires)</td>
<td>修改定时值， 如果定时器还没有激活的话， <br>mod_timer 函数会激活定时器</td>
</tr>
</tbody></table>
<p>在使用add_timer()函数向Linux 内核注册定时器之前，还需要设置定时时间，定时时间由timer_list 结构体中的expires 参数所确定，单位为节拍数，可以通过图形化界面设置系统节拍的频率，具体路径如下图(图30-2)所示：</p>
<pre class="line-numbers language-none"><code class="language-none">-&gt; Kernel Features
    -&gt; Timer frequency (&lt;choice&gt; [=y])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408161559863.png" alt="image-20240816155948715"></p>
<p>从上图可以看出可选的系统节拍率为100Hz、250Hz、300Hz 和1000Hz，默认情况下选择300Hz。<br>通过全局变量jiffies 来记录自系统启动以来产生节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值，一秒内jiffes 增加的值为设置的系统节拍数，该变量定义在”内核源码/include/linux/jiffies.h”文件中（timer.h 文件中已经包含，不需要重复引用），具体定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> u64 __cacheline_aligned_in_smp jiffies_64<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">volatile</span> __cacheline_aligned_in_smp __jiffy_arch_data jiffies<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>其中jiffies_64 用于64 位系统，而jiffies 用于32 位系统。为了方便开发，Linux 内核还提供了几个jiffies 和ms、us、ns 之间的转换函数，如下(表30-2)所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int jiffies_to_msecs(const unsigned long j)</td>
<td>将jiffies 类型的参数j 分别转换为对应的毫秒</td>
</tr>
<tr>
<td>int jiffies_to_usecs(const unsigned long j)</td>
<td>将jiffies 类型的参数j 分别转换为对应的微秒</td>
</tr>
<tr>
<td>u64 jiffies_to_nsecs(const unsigned long j)</td>
<td>将jiffies 类型的参数j 分别转换为对应的纳秒</td>
</tr>
<tr>
<td>long msecs_to_jiffies(const unsigned int m)</td>
<td>将毫秒转换为jiffies 类型</td>
</tr>
<tr>
<td>long usecs_to_jiffies(const unsigned int u)</td>
<td>将微秒转换为jiffies 类型</td>
</tr>
<tr>
<td>unsigned long nsecs_to_jiffies(u64 n)</td>
<td>将纳秒转换为jiffies 类型</td>
</tr>
</tbody></table>
<p>例如可以使用以下命令进行3 秒钟的定时：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">timer_test<span class="token punctuation">.</span>expires <span class="token operator">=</span> jiffies_64 <span class="token operator">+</span><span class="token function">msecs_to_jiffies</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>至此关于Linux 定时器相关的知识就讲解完成了，在下个小节中将进行相应的实验。</p>
<h3 id="30-2-实验程序编写"><a href="#30-2-实验程序编写" class="headerlink" title="30.2 实验程序编写"></a>30.2 实验程序编写</h3><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\24\module</code>。</p>
<p>本实验将实现五秒钟的计时，五秒钟之后将打印“this is function test”相关字符，为了实现循环打印还需要在定时处理函数中使用mod_timer 函数重新设置定时时间。<br>编写好的驱动程序t<code>imer_mod.c</code> 如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/timer.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">function_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义function_test定时功能函数</span>
<span class="token function">DEFINE_TIMER</span><span class="token punctuation">(</span>timer_test<span class="token punctuation">,</span>function_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义一个定时器</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">function_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"this is function test \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">mod_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_test<span class="token punctuation">,</span>jiffies_64 <span class="token operator">+</span> <span class="token function">msecs_to_jiffies</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用mod_timer函数将定时时间设置为五秒后</span>
<span class="token punctuation">}</span>	

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">timer_mod_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
	timer_test<span class="token punctuation">.</span>expires <span class="token operator">=</span> jiffies_64 <span class="token operator">+</span> <span class="token function">msecs_to_jiffies</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将定时时间设置为五秒后</span>
	<span class="token function">add_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//添加一个定时器</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">timer_mod_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
	<span class="token function">del_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除一个定时器</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"module exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>timer_mod_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>timer_mod_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="30-3-运行测试"><a href="#30-3-运行测试" class="headerlink" title="30.3 运行测试"></a>30.3 运行测试</h3><h4 id="30-3-1-编译驱动程序"><a href="#30-3-1-编译驱动程序" class="headerlink" title="30.3.1 编译驱动程序"></a>30.3.1 编译驱动程序</h4><p>在上一小节中的timer_mod.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成timer_mod.ko 目标文件，至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h4 id="30-3-2-运行测试"><a href="#30-3-2-运行测试" class="headerlink" title="30.3.2 运行测试"></a>30.3.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图30-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod timer_mod.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190924616.png" alt="image-20240819092438500"></p>
<p>可以看到驱动加载之后，每隔五秒钟会打印“this is function test”相关打印，证明编写的驱动程序没有问题，最后使用以下命令卸载相应的驱动，如下图（图30-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod timer_mod.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190925178.png" alt="image-20240819092507108"></p>
<h2 id="第31-章秒字符设备驱动实验"><a href="#第31-章秒字符设备驱动实验" class="headerlink" title="第31 章秒字符设备驱动实验"></a>第31 章秒字符设备驱动实验</h2><p>本章节将实现秒字符设备驱动，以此对之前学习到的知识进行巩固。本章节实验要实现的任务如下：</p>
<ol>
<li>实现字符设备驱动框架，自动生成设备节点。</li>
<li>根据上一小节学到的知识，实现秒计时。</li>
<li>通过原子变量来记录递增的秒数，避免竞争的发生。</li>
<li>通过用户空间和内核空间的数据交换，将记录的秒数传递到应用空间，并通过应用程序打印出来。</li>
</ol>
<h3 id="31-1-实验程序编写"><a href="#31-1-实验程序编写" class="headerlink" title="31.1 实验程序编写"></a>31.1 实验程序编写</h3><h4 id="31-1-1-编写测试APP"><a href="#31-1-1-编写测试APP" class="headerlink" title="31.1.1 编写测试APP"></a>31.1.1 编写测试APP</h4><p>本实验对应的应用程序网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\25\app</code>。<br>首先来编写应用测试代码timer.c，在此代码中每隔一秒钟打印从用户空间传递来的秒数，具体代码内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//定义int类型的文件描述符fd</span>
	<span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment">//定义int类型记录秒数的变量count</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用open()函数以可读可写的方式打开设备文件</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>count<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用read函数读取内核传递来的秒数</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num is %d\n"</span><span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="31-1-2-驱动程序编写"><a href="#31-1-2-驱动程序编写" class="headerlink" title="31.1.2 驱动程序编写"></a>31.1.2 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\25\module</code>。</p>
<p>编写好的驱动程序<code>timer_dev.c</code> 如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/atomic.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
    <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
	<span class="token keyword">int</span> sec<span class="token punctuation">;</span> <span class="token comment">//秒</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">atomic64_t</span> v <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义原子类型变量v，并定义为0</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">function_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义function_test定时功能函数</span>
<span class="token function">DEFINE_TIMER</span><span class="token punctuation">(</span>timer_test<span class="token punctuation">,</span>function_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义一个定时器</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">function_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">atomic64_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原子变量v自增</span>
	dev1<span class="token punctuation">.</span>sec <span class="token operator">=</span> <span class="token function">atomic_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将读取到的原子变量v,赋值给sec</span>
	<span class="token comment">//printk("the sec is %d\n",dev1.sec);</span>
	<span class="token function">mod_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_test<span class="token punctuation">,</span>jiffies_64 <span class="token operator">+</span> <span class="token function">msecs_to_jiffies</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用mod_timer函数将定时时间设置为一秒后</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span><span class="token comment">//设置私有数据</span>
	<span class="token function">add_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_test<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//添加一个定时器</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>sec<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>sec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//使用copy_to_user函数将sec传递到应用层</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">del_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除一个定时器</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_release(...)函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">timer_dev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
    dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*5  创建设备*/</span>
  	dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>

err_class_create<span class="token operator">:</span>
       <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>

err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>

err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">timer_dev_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>timer_dev_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>timer_dev_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="31-2-运行测试"><a href="#31-2-运行测试" class="headerlink" title="31.2 运行测试"></a>31.2 运行测试</h3><h4 id="31-2-1-编译驱动程序"><a href="#31-2-1-编译驱动程序" class="headerlink" title="31.2.1 编译驱动程序"></a>31.2.1 编译驱动程序</h4><p>在上一小节中的timer_dev.c 代码同一目录下创建Makefile 文件，Makefile 文件内容如下，然后使用命令“make”进行驱动的编译，编译完生成timer_dev.ko 目标文件，至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h4 id="31-2-2-编译应用程序"><a href="#31-2-2-编译应用程序" class="headerlink" title="31.2.2 编译应用程序"></a>31.2.2 编译应用程序</h4><p>然后来到存放应用程序timer.c 的文件夹下，使用以下命令对timer.c 进行交叉编译，编译完成如下图（图31-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> timer timer.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>生成的timer 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="31-2-3-运行测试"><a href="#31-2-3-运行测试" class="headerlink" title="31.2.3 运行测试"></a>31.2.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图31-5）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod timer_dev.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190938376.png" alt="image-20240819093849295"></p>
<p>然后输入以下命令进行可执行程序的运行，如下图（图31-6）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./timer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190940712.png" alt="image-20240819094006637"></p>
<p>可以看到每隔一秒钟就会打印由内核空间传递来的秒数，我们要实现的任务就完成了，最后使用以下命令卸载对应的驱动，如下图（图31-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod timer_dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190940600.png" alt="image-20240819094031532"></p>
<h2 id="第32-章Linux-内核打印实验"><a href="#第32-章Linux-内核打印实验" class="headerlink" title="第32 章Linux 内核打印实验"></a>第32 章Linux 内核打印实验</h2><p>本手册的实验都是在buildroot 系统上完成的，由于buildroot 系统已经设置了相应的打印等级，所以驱动的相关打印都能正常显示在串口终端上，如果将实验系统换成了ubuntu，然后加载同样的驱动，会发现打印信息不见了，这一现象的基本原因就是内核打印等级不同，那打印等级是如何修改的呢，查看打印等级的方式又有哪些呢，就让我们进入本章节的学习吧！</p>
<h3 id="32-1-方法一：dmseg-命令"><a href="#32-1-方法一：dmseg-命令" class="headerlink" title="32.1 方法一：dmseg 命令"></a>32.1 方法一：<code>dmseg</code> 命令</h3><p>在终端使用dmseg 命令可以获取内核打印信息，该命令的具体使用方法如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">dmesg</span> 命令
英文全称：	display message（显示信息）
作用：		 kernel 会将打印信息存储在ring buffer 中。可以利用dmesg 命令来查看内核打印信息。。
常用参数:
            -C，--clear 清除内核环形缓冲区
            -c，—-read-clear 读取并清除所有消息
            -T，--显示时间戳
提示：dmesg 命令也可以与grep 命令组合使用。如查找待用usb 关键字的打印信息，就可以使用如下命令:dmseg <span class="token operator">|</span> <span class="token function">grep</span> usb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先在串口终端使用“dmseg”命令，可以看见相应的内核打印信息已经加载了出来，如下图（图32-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190943666.png" alt="image-20240819094313549"></p>
<p>然后使用以下组合命令查找nfs 相关的打印信息，如下图（图32-2）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">grep</span> nfs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190943989.png" alt="image-20240819094335910"></p>
<p>至此关于dmesg 命令就讲解演示完成了。</p>
<h3 id="32-2-方法二：查看kmsg-文件"><a href="#32-2-方法二：查看kmsg-文件" class="headerlink" title="32.2 方法二：查看kmsg 文件"></a>32.2 方法二：查看kmsg 文件</h3><p>内核所有的打印信息都会输出到循环缓冲区’log_buf’，为了能够方便的在用户空间读取内核打印信息，Linux 内核驱动将该循环缓冲区映射到了/proc 目录下的文件节点kmsg。通过cat 或者其他应用程序读取Log Buffer 的时候可以不断的等待新的log，所以<strong>访问<code>/proc/kmsg</code>的方式适合长时间的读取log，一旦有新的log 就可以被打印出来</strong>。<br>首先使用以下命令读取kmsg 文件，在没有新的内核打印信息时会阻塞，如下图（图32-3）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/kmsg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190947969.png" alt="image-20240819094729896"></p>
<p>然后在该设备的其他终端加载任意有打印信息的驱动文件（这里使用的是ssh），如下图（图32-4）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190947007.png" alt="image-20240819094743937"></p>
<p>在串口终端中可以看到对应驱动的打印信息就被打印了出来，如下图（图32-5）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190947761.png" alt="image-20240819094758680"></p>
<h2 id="32-3-方法三：调整内核打印等级"><a href="#32-3-方法三：调整内核打印等级" class="headerlink" title="32.3 方法三：调整内核打印等级"></a>32.3 方法三：调整内核打印等级</h2><p>内核的日志打印由相应的打印等级来控制，可以通过调整内核打印等级来控制打印日志的输出。使用以下命令查看当前默认打印等级，如下图（图32-6）所示:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/sys/kernel/printk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190948808.png" alt="image-20240819094857735"></p>
<p>可以看到内核打印等级由四个数字所决定，“7 4 1 7” 分别对应<code>console_loglevel</code>、<code>default_message_loglevel</code>、<code>minimum_c onsole_loglevel</code>、<code>default_console_loglevel</code>，具体类型说明如下表（表32-7）所示：</p>
<table>
<thead>
<tr>
<th>终端打印类型</th>
<th>对应类型说明</th>
</tr>
</thead>
<tbody><tr>
<td>console_loglevel</td>
<td>只有当printk 打印消息的log 优先级高于console_loglevel 时，才能输出到终端上</td>
</tr>
<tr>
<td>default_message_loglevel</td>
<td>printk 打印消息时默认的log 等级</td>
</tr>
<tr>
<td>minimum_console_loglevel</td>
<td>console_loglevel 可以被设置的最小值</td>
</tr>
<tr>
<td>default_console_loglevel</td>
<td>console_loglevel 的缺省值</td>
</tr>
</tbody></table>
<p>上面的“7 4 1 7”意味着只有优先级高于KERN_DEBUG(7)的打印消息才能输出到终端，在“<code>内核源码/include/linux/kern_levels.h</code>”文件中对于文件打印等级进行了如下打印等级定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_EMERG</span> <span class="token expression">KERN_SOH </span><span class="token string">"0"</span> 		<span class="token comment">/* system is unusable */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_ALERT</span> <span class="token expression">KERN_SOH </span><span class="token string">"1"</span> 		<span class="token comment">/* action must be taken immediately */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_CRIT</span> <span class="token expression">KERN_SOH </span><span class="token string">"2"</span> 			<span class="token comment">/* critical conditions */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_ERR</span> <span class="token expression">KERN_SOH </span><span class="token string">"3"</span> 			<span class="token comment">/* error conditions */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_WARNING</span> <span class="token expression">KERN_SOH </span><span class="token string">"4"</span> 		<span class="token comment">/* warning conditions */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_NOTICE</span> <span class="token expression">KERN_SOH </span><span class="token string">"5"</span> 		<span class="token comment">/* normal but significant condition */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_INFO</span> <span class="token expression">KERN_SOH </span><span class="token string">"6"</span> 			<span class="token comment">/* informational */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_DEBUG</span> <span class="token expression">KERN_SOH </span><span class="token string">"7"</span> 		<span class="token comment">/* debug-level messages */</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>printk 在打印信息前，可以加入相应的打印等级宏定义，具体格式如下所示：<code>printk(打印等级"打印信息")</code><br>接下来将使用以下驱动例程进行实际的打印等级测试：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h&gt;</span></span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">helloworld_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">" 0000 KERN_EMERG\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ALERT <span class="token string">" 1111 KERN_ALERT\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_CRIT <span class="token string">" 2222 KERN_CRIT\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">" 3333 KERN_ERR\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_WARNING <span class="token string">" 4444 KERN_WARNING\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_NOTICE <span class="token string">" 5555 KERN_NOTICE\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">" 6666 KERN_INFO\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_DEBUG <span class="token string">" 7777 KERN_DEBUG\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">" 8888 no_fix\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">helloworld_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_exit\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>helloworld_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>helloworld_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>加载该驱动之后，第5-11 行0-6 等级的打印信息就被打印了出来，第13 行由于没有设置打印等级，所以会被赋予默认打印等级4，高于console_loglevel 打印等级，所以也会被打印出来，最后只有第12 行打印等级为7 的信息，和<code>console_loglevel</code> 打印等级相同，所以不会被打印出来，如下图（图32-8）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190954400.png" alt="image-20240819095429318"></p>
<p>然后使用以下命令将console_loglevel 打印等级设置为4，如下图（图32-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token number">4</span> <span class="token number">4</span> <span class="token number">1</span> <span class="token number">7</span> <span class="token operator">&gt;</span> /proc/sys/kernel/printk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190954128.png" alt="image-20240819095459052"></p>
<p>卸载驱动之后，再一次加载驱动，发现只有打印等级高于4 的相关信息被打印了出来，如下图（图32-10）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408190955139.png" alt="image-20240819095509064"></p>
<p>至此关于内核打印等级的实验就结束了。</p>
<h2 id="第33-章llseek-定位设备驱动实验"><a href="#第33-章llseek-定位设备驱动实验" class="headerlink" title="第33 章llseek 定位设备驱动实验"></a>第33 章llseek 定位设备驱动实验</h2><p>相信经过了前面章节的学习，大家已经对内核空间与用户空间的数据交互很是熟悉，但在之前的例子中都是对字符串的全部内容进行读写，假如现在有这样一个场景，将两个字符串依次进行写入，并对写入完成的字符串进行读取，如果仍采用之前的方式，第二次的写入值会覆盖第一次写入值，那要如何来实现上述功能呢？这就要轮到llseek 出场了。</p>
<h3 id="33-1-定位设备llseek"><a href="#33-1-定位设备llseek" class="headerlink" title="33.1 定位设备llseek"></a>33.1 定位设备llseek</h3><h4 id="33-1-1-lseek-函数的使用"><a href="#33-1-1-lseek-函数的使用" class="headerlink" title="33.1.1 lseek 函数的使用"></a>33.1.1 lseek 函数的使用</h4><p>在应用程序中使用lseek 函数进行读写位置的调整，该函数的具体使用说明如下所示：<code>lseek</code> 函数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token class-name">off_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span>
头文件：
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
函数作用：
    移动文件的读写位置。
参数含义：
    fd<span class="token operator">:</span> 文件描述符；
    <span class="token class-name">off_t</span> offset<span class="token operator">:</span> 偏移量，单位是字节的数量，可以正负，如果是负值表示向前移动；如果是正值，表示向后移动。
    whence：当前位置的基点，可以使用以下三组值。
    <span class="token constant">SEEK_SET</span>：相对于文件开头
    <span class="token constant">SEEK_CUR</span><span class="token operator">:</span>相对于当前的文件读写指针位置
    <span class="token constant">SEEK_END</span><span class="token operator">:</span>相对于文件末尾
函数返回值：
    成功返回当前位移大小，失败返回<span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数使用示例：<br>把文件位置指针设置为5：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>把文件位置设置成文件末尾：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_END</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>确定当前的文件位置：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="33-1-2-驱动程序的完善"><a href="#33-1-2-驱动程序的完善" class="headerlink" title="33.1.2 驱动程序的完善"></a>33.1.2 驱动程序的完善</h4><p>上一小节中讲解的lseek 函数如果要对设备文件生效，还需要完善相应的驱动程序。<code>lseek</code>函数会调用<code>file_operation</code> 结构体中的<code>llseek 接口</code>，所以需要对驱动中的llseek 函数进行填充，并且完善read 和write 函数中偏移相关的部分。<br>下面对相关API 接口函数进行填充：</p>
<p><strong><code>llseek</code> 函数完善</strong>：<br>llseek 填充完成的函数如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">loff_t</span> <span class="token function">cdev_test_llseek</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">loff_t</span> new_offset<span class="token punctuation">;</span><span class="token comment">//定义loff_t 类型的新的偏移值</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>whence<span class="token punctuation">)</span><span class="token comment">//对lseek 函数传递的whence 参数进行判断</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token constant">SEEK_SET</span><span class="token operator">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>offset <span class="token operator">&gt;</span> BUFSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            new_offset <span class="token operator">=</span> offset<span class="token punctuation">;</span><span class="token comment">//如果whence 参数为SEEK_SET，则新偏移值为offset</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token constant">SEEK_CUR</span><span class="token operator">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_pos <span class="token operator">+</span> offset <span class="token operator">&gt;</span> BUFSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_pos <span class="token operator">+</span> offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            new_offset <span class="token operator">=</span> file<span class="token operator">-&gt;</span>f_pos <span class="token operator">+</span> offset<span class="token punctuation">;</span><span class="token comment">//如果whence 参数为SEEK_CUR，则新偏移值为file-&gt;f_pos +</span>
            offset，file<span class="token operator">-&gt;</span>f_pos 为当前的偏移值
        <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token constant">SEEK_END</span><span class="token operator">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_pos <span class="token operator">+</span> offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            new_offset <span class="token operator">=</span> BUFSIZE <span class="token operator">+</span> offset<span class="token punctuation">;</span><span class="token comment">//如果whence 参数为SEEK_END，则新偏移值为BUFSIZE + offset，</span>
            BUFSIZE 为最大偏移量
            <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    file<span class="token operator">-&gt;</span>f_pos <span class="token operator">=</span> new_offset<span class="token punctuation">;</span><span class="token comment">//更新file-&gt;f_pos 偏移值</span>
    <span class="token keyword">return</span> new_offset<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在第4 行使用switch 语句对传递的whence 参数进行判断，whence 在这里可以有三个取值，分别为<code>SEEK_SET</code>、<code>SEEK_CUR</code> 和<code>SEEK_END</code>。<br>在6-16、17-28、29-38 行代码中，分别对三个参数所代表的功能进行实现，其中需要注意的是<code>file-&gt;f_pos</code> 指的是当前文件的偏移值。<br>在第40 行和41 行分别对f_pos 偏移值进行更新，对新的偏移值进行返回。</p>
<p><strong>read 接口函数完善</strong>：<br>填充完成的read 接口函数如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">loff_t</span> p <span class="token operator">=</span> <span class="token operator">*</span>off<span class="token punctuation">;</span><span class="token comment">//将读取数据的偏移量赋值给loff_t 类型变量p</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> count <span class="token operator">=</span> size<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">&gt;</span> BUFSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果当前偏移值比最大偏移量大则返回错误</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;</span> BUFSIZE <span class="token operator">-</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
        count <span class="token operator">=</span> BUFSIZE <span class="token operator">-</span> p<span class="token punctuation">;</span><span class="token comment">//如果要读取的偏移值超出剩余的空间，则读取到最后位置</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>mem<span class="token operator">+</span>p<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//将mem 中的值写入buf，并传递到用户空间</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"buf[%d] is %c\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将mem 中的值打印出来</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mem is %s,p is %llu,count is %d\n"</span><span class="token punctuation">,</span>mem<span class="token operator">+</span>p<span class="token punctuation">,</span>p<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>off <span class="token operator">=</span> <span class="token operator">*</span>off <span class="token operator">+</span> count<span class="token punctuation">;</span><span class="token comment">//更新偏移值</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>相较于之前的read 接口函数，在第7 行和第10 行分别加入了对偏移值p 和读取数量进行判定，在第13 行通过偏移值p 进行内核空间和用户空间数据的传递，最后在第21 行对偏移值进行更新。</p>
<p><strong>write 接口函数完善</strong>：<br>write 接口函数的完善和read 接口函数相似，填充完成的write 接口函数如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">loff_t</span> p <span class="token operator">=</span> <span class="token operator">*</span>off<span class="token punctuation">;</span><span class="token comment">//将写入数据的偏移量赋值给loff_t 类型变量p</span>
    <span class="token class-name">size_t</span> count <span class="token operator">=</span> size<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">&gt;</span> BUFSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果当前偏移值比最大偏移量大则返回错误</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;</span> BUFSIZE <span class="token operator">-</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
        count <span class="token operator">=</span> BUFSIZE <span class="token operator">-</span> p<span class="token punctuation">;</span><span class="token comment">//如果要写入的偏移值超出剩余的空间，则写入到最后位置</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>mem<span class="token operator">+</span>p<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//将buf 中的值，从用户空间传递到内核空间</span>
        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mem is %s,p is %llu\n"</span><span class="token punctuation">,</span>mem<span class="token operator">+</span>p<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印写入的值</span>
    <span class="token operator">*</span>off <span class="token operator">=</span> <span class="token operator">*</span>off <span class="token operator">+</span> count<span class="token punctuation">;</span><span class="token comment">//更新偏移值</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>相较于之前的write 接口函数，在第7 行和第10 行分别加入了对偏移值p 和读取数量进行判定，在第13 行通过偏移值p 进行内核空间和用户空间数据的传递，最后在第18 行对偏移值进行更新。</p>
<p>至此，关于定位设备相关的API 接口函数就都填充完成了，将在下一小节进行定位设备驱动实验代码的编写。</p>
<h3 id="33-2-实验程序编写"><a href="#33-2-实验程序编写" class="headerlink" title="33.2 实验程序编写"></a>33.2 实验程序编写</h3><h4 id="33-2-1-编写测试APP"><a href="#33-2-1-编写测试APP" class="headerlink" title="33.2.1 编写测试APP"></a>33.2.1 编写测试APP</h4><p>本实验对应的应用程序网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\26\app</code>。<br>首先来编写应用测试代码llseek.c，编写好的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//定义int类型文件描述符</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> off<span class="token punctuation">;</span><span class="token comment">//定义读写偏移位置</span>
	<span class="token keyword">char</span> readbuf<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义读取缓冲区readbuf</span>
	<span class="token keyword">char</span> readbuf1<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义读取缓冲区readbuf1</span>

	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">,</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打开/dev/test设备</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"hello world"</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向fd写入数据hello world</span>
	off <span class="token operator">=</span> <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取当前位置的偏移量</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"off is %d\n"</span><span class="token punctuation">,</span>off<span class="token punctuation">)</span><span class="token punctuation">;</span>

    off <span class="token operator">=</span> <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将偏移量设置为0</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"off is %d\n"</span><span class="token punctuation">,</span>off<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>readbuf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>readbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将写入的数据读取到readbuf缓冲区</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read is %s\n"</span><span class="token punctuation">,</span>readbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>

    off <span class="token operator">=</span> <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取当前位置的偏移量</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"off is %d\n"</span><span class="token punctuation">,</span>off<span class="token punctuation">)</span><span class="token punctuation">;</span>

	off <span class="token operator">=</span> <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将当前位置的偏移量向前挪动一位</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"off is %d\n"</span><span class="token punctuation">,</span>off<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"Linux"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向fd写入数据Linux</span>
    off <span class="token operator">=</span> <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取当前位置的偏移量</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"off is %d\n"</span><span class="token punctuation">,</span>off<span class="token punctuation">)</span><span class="token punctuation">;</span>

    off <span class="token operator">=</span> <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将偏移量设置为0</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"off is %d\n"</span><span class="token punctuation">,</span>off<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>readbuf1<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>readbuf1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将写入的数据读取到readbuf1缓冲区</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read is %s\n"</span><span class="token punctuation">,</span>readbuf1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    off <span class="token operator">=</span> <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取当前位置的偏移量</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"off is %d\n"</span><span class="token punctuation">,</span>off<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="33-2-2-驱动程序编写"><a href="#33-2-2-驱动程序编写" class="headerlink" title="33.2.2 驱动程序编写"></a>33.2.2 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\26\module</code>。<br>编写好的驱动程序llseek.c 如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/atomic.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFSIZE</span> <span class="token expression"><span class="token number">1024</span></span><span class="token comment">//设置最大偏移量为1024</span></span>
<span class="token keyword">static</span> <span class="token keyword">char</span> mem<span class="token punctuation">[</span>BUFSIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//设置数据存储数组mem</span>
<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
    <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span><span class="token comment">//设置私有数据</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">/*从设备读取数据*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token class-name">loff_t</span> p <span class="token operator">=</span> <span class="token operator">*</span>off<span class="token punctuation">;</span><span class="token comment">//将读取数据的偏移量赋值给loff_t类型变量p</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> count <span class="token operator">=</span> size<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">&gt;</span> BUFSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;</span> BUFSIZE <span class="token operator">-</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
		count  <span class="token operator">=</span> BUFSIZE <span class="token operator">-</span> p<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>mem<span class="token operator">+</span>p<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//将mem中的值写入buf，并传递到用户空间</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"buf[%d] is %c\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将mem中的值打印出来</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mem is %s,p is %llu,count is %ld\n"</span><span class="token punctuation">,</span>mem<span class="token operator">+</span>p<span class="token punctuation">,</span>p<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span>off <span class="token operator">=</span> <span class="token operator">*</span>off <span class="token operator">+</span> count<span class="token punctuation">;</span><span class="token comment">//更新偏移值</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*向设备写入数据函数*/</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">cdev_test_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    <span class="token class-name">loff_t</span> p <span class="token operator">=</span> <span class="token operator">*</span>off<span class="token punctuation">;</span><span class="token comment">//将读取数据的偏移量赋值给loff_t类型变量p</span>
    <span class="token class-name">size_t</span> count <span class="token operator">=</span> size<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">&gt;</span> BUFSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;</span> BUFSIZE <span class="token operator">-</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
        count  <span class="token operator">=</span> BUFSIZE <span class="token operator">-</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>mem<span class="token operator">+</span>p<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//将buf中的值，从用户空间传递到内核空间</span>
 		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mem is %s,p is %llu\n"</span><span class="token punctuation">,</span>mem<span class="token operator">+</span>p<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印写入的值</span>
	<span class="token operator">*</span>off <span class="token operator">=</span> <span class="token operator">*</span>off <span class="token operator">+</span> count<span class="token punctuation">;</span><span class="token comment">//更新偏移值</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token class-name">loff_t</span> <span class="token function">cdev_test_llseek</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token class-name">loff_t</span> new_offset<span class="token punctuation">;</span><span class="token comment">//定义loff_t类型的新的偏移值</span>
	<span class="token keyword">switch</span><span class="token punctuation">(</span>whence<span class="token punctuation">)</span><span class="token comment">//对lseek函数传递的whence参数进行判断</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">case</span> <span class="token constant">SEEK_SET</span><span class="token operator">:</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>offset <span class="token operator">&gt;</span> BUFSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>	
			<span class="token punctuation">}</span>
			new_offset <span class="token operator">=</span> offset<span class="token punctuation">;</span><span class="token comment">//如果whence参数为SEEK_SET，则新偏移值为offset</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">case</span> <span class="token constant">SEEK_CUR</span><span class="token operator">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_pos <span class="token operator">+</span> offset <span class="token operator">&gt;</span> BUFSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_pos <span class="token operator">+</span> offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            new_offset <span class="token operator">=</span> file<span class="token operator">-&gt;</span>f_pos <span class="token operator">+</span> offset<span class="token punctuation">;</span><span class="token comment">//如果whence参数为SEEK_CUR，则新偏移值为file-&gt;f_pos + offset，file-&gt;f_pos为当前的偏移值</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>			
		<span class="token keyword">case</span> <span class="token constant">SEEK_END</span><span class="token operator">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_pos <span class="token operator">+</span> offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            new_offset <span class="token operator">=</span> BUFSIZE <span class="token operator">+</span> offset<span class="token punctuation">;</span><span class="token comment">//如果whence参数为SEEK_END，则新偏移值为BUFSIZE + offset，BUFSIZE为最大偏移量</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">default</span><span class="token operator">:</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	file<span class="token operator">-&gt;</span>f_pos <span class="token operator">=</span> new_offset<span class="token punctuation">;</span><span class="token comment">//更新file-&gt;f_pos偏移值</span>
	<span class="token keyword">return</span> new_offset<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_open(...)函数</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> cdev_test_read<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_read(...)函数</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> cdev_test_write<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_write(...)函数</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span> <span class="token comment">//将open字段指向chrdev_release(...)函数</span>
	<span class="token punctuation">.</span>llseek <span class="token operator">=</span> cdev_test_llseek<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">timer_dev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
    dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*5  创建设备*/</span>
  	dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
err_class_create<span class="token operator">:</span>
       <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">timer_dev_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>timer_dev_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>timer_dev_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="33-3-运行测试"><a href="#33-3-运行测试" class="headerlink" title="33.3 运行测试"></a>33.3 运行测试</h3><h4 id="33-3-1-编译驱动程序"><a href="#33-3-1-编译驱动程序" class="headerlink" title="33.3.1 编译驱动程序"></a>33.3.1 编译驱动程序</h4><p>在上一小节中的llseek.c 代码同一目录下创建Makefile 文件，Makefile 文件内容如下所示：然后使用命令“make”进行驱动的编译，编译完生成llseek.ko 目标文件，至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h4 id="33-3-2-编译应用程序"><a href="#33-3-2-编译应用程序" class="headerlink" title="33.3.2 编译应用程序"></a>33.3.2 编译应用程序</h4><p>来到存放应用程序llseek.c 的文件夹下，使用以下命令对llseek.c 进行交叉编译，编译完成如下图（图33-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> <span class="token builtin class-name">read</span> read.c <span class="token parameter variable">-static</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191018273.png" alt="image-20240819101825187"></p>
<p>生成的llseek 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="33-3-3-运行测试"><a href="#33-3-3-运行测试" class="headerlink" title="33.3.3 运行测试"></a>33.3.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图33-5）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod llseek.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191018624.png" alt="image-20240819101849539"></p>
<p>然后使用以下命令运行可执行文件llseek，运行结果如下图（图33-6）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./llseek<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191019973.png" alt="image-20240819101904866"></p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191019063.png" alt="image-20240819101910954"></p>
<p>然后使用以下命令卸载对应的驱动，如下图（图33-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod timer_dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191022209.png" alt="image-20240819102225130"></p>
<h2 id="第34-章IOCTL-驱动传参实验"><a href="#第34-章IOCTL-驱动传参实验" class="headerlink" title="第34 章IOCTL 驱动传参实验"></a>第34 章IOCTL 驱动传参实验</h2><p>用户如果要对外设进行操作，对应的设备驱动不仅要具备读写的能力，还需要对硬件进行控制。以点亮LED 灯驱动实验为例，应用程序通过向内核空间写入1 和0 从而控制LED 灯的亮灭，但是读写操作主要是数据流对数据进行操作，而一些复杂的控制通常需要非数据操作，这时本章节要学习的ioctl 函数就闪耀登场了。</p>
<h3 id="34-1-ioctl-基础"><a href="#34-1-ioctl-基础" class="headerlink" title="34.1 ioctl 基础"></a>34.1 ioctl 基础</h3><p>ioctl 是设备驱动程序中用来控制设备的接口函数，一个字符设备驱动通常需要实现设备的打开、关闭、读取、写入等功能，而在一些需要细分的情况下，就需要扩展新的功能，通常以增设<code>ioctl()</code>命令的方式来实现。</p>
<p>下面将从应用层和驱动函数两个方面来对ioctl 函数进行学习。</p>
<p><strong>应用层</strong>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">函数原型：
    int ioctl<span class="token punctuation">(</span>int fd, unsigned int cmd, unsigned long args<span class="token punctuation">)</span><span class="token punctuation">;</span>
头文件：
    <span class="token comment">#include &lt;sys/ioctl.h&gt;</span>
函数作用：
    用于向设备发送控制和配置命令。
参数含义：
    fd ：是用户程序打开设备时返回的文件描述符
    cmd ：是用户程序对设备的控制命令，
    args：应用程序向驱动程序下发的参数，如果传递的参数为指针类型，则可以接收驱动向
用户空间传递的数据（在下面的实验中会进行使用）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述三个参数中，最重要的是第二个cmd 参数，为unsigned int 类型，为了高效的使用cmd 参数传递更多的控制信息，一个<code>unsigned int cmd</code> 被拆分为了4 段，每一段都有各自的意义，unsigned int cmd 位域拆分如下：</p>
<pre class="line-numbers language-none"><code class="language-none">cmd[31:30]—数据（args）的传输方向（读写）
cmd[29:16]—数据（args）的大小
cmd[15:8]—&gt;命令的类型，可以理解成命令的密钥，一般为ASCII 码（0-255 的一个字符，有部分字符已经被占用，每个字符的序号段可能部分被占用）
cmd[7:0] —&gt;命令的序号，是一个8bits 的数字（序号，0-255 之间）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>cmd 参数由ioctl 合成宏定义得到，四个合成宏定义如下所示：<br>定义一个命令，但是不需要参数：</p>
<pre class="line-numbers language-none"><code class="language-none">#define _IO(type,nr) _IOC(_IOC_NONE,(type),(nr),0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>定义一个命令，应用程序从驱动程序读参数：</p>
<pre class="line-numbers language-none"><code class="language-none">#define _IOR(type,nr,size) _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>定义一个命令，应用程序向驱动程序写参数：</p>
<pre class="line-numbers language-none"><code class="language-none">#define _IOW(type,nr,size) _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>定义一个命令，参数是双向传递的：</p>
<pre class="line-numbers language-none"><code class="language-none">#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>宏定义参数说明如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">type：命令的类型，一般为一个ASCII 码值，一个驱动程序一般使用一个type
nr：该命令下序号。一个驱动有多个命令，一般他们的type，序号不同
size：args 的类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>例如可以使用以下代码定义不需要参数、向驱动程序写参数、向驱动程序读参数三个宏：</p>
<pre class="line-numbers language-none"><code class="language-none">#define CMD_TEST0 _IO('L',0)
#define CMD_TEST1 _IOW('L',1,int)
#define CMD_TEST2 _IOR('L',2,int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>至此，关于应用程序的<code>ioctl</code> 相关知识就讲解完成了。</p>
<p><strong>驱动函数</strong>：</p>
<p>应用程序中ioctl 函数会调用file_operation 结构体中的unlocked_ioctl 接口，接口定义如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlocked_ioctl<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file <span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数说明如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">file：文件描述符。
cmd：与应用程序的cmd 参数对应，在驱动程序中对传递来的cmd 参数进行判断从而做出不同的动作。
arg：与应用程序的arg 参数对应，从而实现内核空间和用户空间参数的传递。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>至此，关于驱动函数中的ioctl 相关知识就讲解完成了。在下一小节中将进行ioctl 驱动传参实验。</p>
<h3 id="34-2-实验程序编写"><a href="#34-2-实验程序编写" class="headerlink" title="34.2 实验程序编写"></a>34.2 实验程序编写</h3><h4 id="34-2-1-编写测试APP"><a href="#34-2-1-编写测试APP" class="headerlink" title="34.2.1 编写测试APP"></a>34.2.1 编写测试APP</h4><p>本实验对应的应用程序网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\27\app。</p>
<p>首先来编写应用测试代码ioctl.c，在此代码中使用非阻塞的方式打开设备，编写好的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_TEST0</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_TEST1</span> <span class="token expression"><span class="token function">_IOW</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_TEST2</span> <span class="token expression"><span class="token function">_IOR</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

	<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//定义int类型的文件描述符fd</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span><span class="token comment">//定义int类型的传递参数val</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打开test设备节点</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"write"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>CMD_TEST1<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果第二个参数为write，向内核空间写入1</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"read"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>CMD_TEST2<span class="token punctuation">,</span><span class="token operator">&amp;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果第二个参数为read，则读取内核空间传递向用户空间传递的值</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"val is %d\n"</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="34-2-2-驱动程序编写"><a href="#34-2-2-驱动程序编写" class="headerlink" title="34.2.2 驱动程序编写"></a>34.2.2 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\27\module</code>。</p>
<p>编写好的驱动程序ioctl.c 如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_TEST0</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_TEST1</span> <span class="token expression"><span class="token function">_IOW</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_TEST2</span> <span class="token expression"><span class="token function">_IOR</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>

    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
     <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>


<span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">cdev_test_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span><span class="token comment">//定义int类型向应用空间传递的变量val</span>
	<span class="token keyword">switch</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">case</span> CMD_TEST0<span class="token operator">:</span>
            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"this is CMD_TEST0\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>		
        <span class="token keyword">case</span> CMD_TEST1<span class="token operator">:</span>
            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"this is CMD_TEST1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"arg is %ld\n"</span><span class="token punctuation">,</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印应用空间传递来的arg参数</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> CMD_TEST2<span class="token operator">:</span>
			val <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//将要传递的变量val赋值为1</span>
            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"this is CMD_TEST2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">,</span><span class="token operator">&amp;</span>val<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//通过copy_to_user向用户空间传递数据</span>
				<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_to_user error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
			<span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>			
	<span class="token keyword">default</span><span class="token operator">:</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	<span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> cdev_test_ioctl<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">timer_dev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
    dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*5  创建设备*/</span>
  	dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
err_class_create<span class="token operator">:</span>
       <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">timer_dev_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>timer_dev_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>timer_dev_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="34-3-运行测试"><a href="#34-3-运行测试" class="headerlink" title="34.3 运行测试"></a>34.3 运行测试</h3><h4 id="34-3-1-编译驱动程序"><a href="#34-3-1-编译驱动程序" class="headerlink" title="34.3.1 编译驱动程序"></a>34.3.1 编译驱动程序</h4><p>在上一小节中的ioctl.c 代码同一目录下创建Makefile 文件，Makefile 文件内容与之前一致：然后使用命令“make”进行驱动的编译，编译完生成ioctl.ko 目标文件，至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h4 id="34-3-2-编译应用程序"><a href="#34-3-2-编译应用程序" class="headerlink" title="34.3.2 编译应用程序"></a>34.3.2 编译应用程序</h4><p>来到存放应用程序ioctl.c 的文件夹下，使用以下命令对ioctl.c 进行交叉编译，编译完成如下图（图34-5）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> ioctl ioctl.c <span class="token parameter variable">-static</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191045133.png" alt="image-20240819104518038"></p>
<p>生成的ioctl 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="34-3-3-运行测试"><a href="#34-3-3-运行测试" class="headerlink" title="34.3.3 运行测试"></a>34.3.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图34-6）所示：</p>
<pre class="line-numbers language-none"><code class="language-none">insmod ioctl.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191045792.png" alt="image-20240819104551699"></p>
<p>然后使用以下命令通过ioctl 向内核空间传递arg 参数，传递成功如下图（图34-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./ioctl <span class="token function">write</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191046152.png" alt="image-20240819104614063"></p>
<p>然后使用以下命令通过ioctl 读取内核空间向用户空间传递的val 值，读取成功如下图（图34-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./ioctl <span class="token builtin class-name">read</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191046531.png" alt="image-20240819104636444"></p>
<p>至此关于iocto 驱动传参实验就测试完成了，可以使用以下命令卸载对应的驱动，如下图（图34-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod ioctl.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191046570.png" alt="image-20240819104654483"></p>
<h2 id="第35-章IOCTL-地址传参实验"><a href="#第35-章IOCTL-地址传参实验" class="headerlink" title="第35 章IOCTL 地址传参实验"></a>第35 章IOCTL 地址传参实验</h2><p>在上一章节中对ioctl 基础知识进行了学习，并通过ioctl 进行了驱动传参实验，在本章节将以传递结构体为例，进行地址传参实验，从而加深大家对ioctl 的认识。</p>
<h3 id="35-1-实验程序编写"><a href="#35-1-实验程序编写" class="headerlink" title="35.1 实验程序编写"></a>35.1 实验程序编写</h3><h4 id="35-1-1-编写测试APP"><a href="#35-1-1-编写测试APP" class="headerlink" title="35.1.1 编写测试APP"></a>35.1.1 编写测试APP</h4><p>本实验对应的应用程序网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\28\app。<br>首先编写应用程序ioctl.c，用来向设备文件写入数据，编写好的应用程序如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_TEST0</span> <span class="token expression"><span class="token function">_IOW</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">struct</span> <span class="token class-name">args</span><span class="token punctuation">{</span><span class="token comment">//定义要传递的结构体</span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	<span class="token keyword">int</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">//定义int类型文件描述符</span>
	<span class="token keyword">struct</span> <span class="token class-name">args</span> test<span class="token punctuation">;</span><span class="token comment">//定义args类型的结构体变量test</span>
	test<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	test<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	test<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">,</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打开/dev/test设备</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>CMD_TEST0<span class="token punctuation">,</span><span class="token operator">&amp;</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用ioctl函数传递结构体变量test地址</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="35-1-1-驱动程序编写"><a href="#35-1-1-驱动程序编写" class="headerlink" title="35.1.1 驱动程序编写"></a>35.1.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\28\module</code>。<br>编写好的驱动程序ioctl.c 如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_TEST0</span> <span class="token expression"><span class="token function">_IOW</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">struct</span> <span class="token class-name">args</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	<span class="token keyword">int</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>

    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
     <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
    <span class="token keyword">char</span> kbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">cdev_test_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">args</span> test<span class="token punctuation">;</span>  
	<span class="token keyword">switch</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">case</span> CMD_TEST0<span class="token operator">:</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span>test<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  			<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"b = %d\n"</span><span class="token punctuation">,</span>test<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	  		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"c = %d\n"</span><span class="token punctuation">,</span>test<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>			
	<span class="token keyword">default</span><span class="token operator">:</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	<span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> cdev_test_ioctl<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">timer_dev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
    dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
  dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*5  创建设备*/</span>
  	dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
err_class_create<span class="token operator">:</span>
       <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">timer_dev_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>timer_dev_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>timer_dev_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="35-2-运行测试"><a href="#35-2-运行测试" class="headerlink" title="35.2 运行测试"></a>35.2 运行测试</h3><h4 id="35-2-1-编译驱动程序"><a href="#35-2-1-编译驱动程序" class="headerlink" title="35.2.1 编译驱动程序"></a>35.2.1 编译驱动程序</h4><p>在上一小节中的ioctl.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成wq.ko 目标文件，至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h4 id="35-2-2-编译应用程序"><a href="#35-2-2-编译应用程序" class="headerlink" title="35.2.2 编译应用程序"></a>35.2.2 编译应用程序</h4><p>来到存放应用程序ioctl.c 的文件夹下，使用以下命令对ioctl.c 进行交叉编译，编译完成如下图（图35-4）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">aarch64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">-</span>gcc <span class="token operator">-</span>o ioctl ioctl<span class="token punctuation">.</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>生成的ioctl 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="35-2-3-运行测试"><a href="#35-2-3-运行测试" class="headerlink" title="35.2.3 运行测试"></a>35.2.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图35-5）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod ioctl.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191059744.png" alt="image-20240819105924647"></p>
<p>然后使用以下命令运行可执行程序，运行成功如下图（图35-6）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./ioctl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191059461.png" alt="image-20240819105938370"></p>
<p>可以看到结构体类型变量test 已经成功传递到了内核空间，a、b、c 的值都被正确打印了出来，我们的ioctl 地址传参实验就完成了。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191059141.png" alt="image-20240819105950047"></p>
<h2 id="第36-章封装驱动API-接口实验"><a href="#第36-章封装驱动API-接口实验" class="headerlink" title="第36 章封装驱动API 接口实验"></a>第36 章封装驱动API 接口实验</h2><p>相信经过前面两个章节的学习已经能够熟练的使用ioctl 函数了，在本章节会进行两个实验，每个实验的要完成的任务如下所示：</p>
<ul>
<li>实验一：通过ioctl 对定时器进行控制，分别实现打开定时器、关闭定时器和设置定时时间的功能。</li>
<li>实验二：对实验一的应用程序进行封装，从而让应用编程人员更好的对设备进行编程。</li>
</ul>
<h3 id="36-1-ioctl-控制定时器实验"><a href="#36-1-ioctl-控制定时器实验" class="headerlink" title="36.1 ioctl 控制定时器实验"></a>36.1 ioctl 控制定时器实验</h3><p>首先进行ioctl 控制定时器实验，通过该实验可以综合ioctl 函数和定时器相关知识，从而进一步加深对ioctl 的理解。</p>
<h4 id="36-1-1-编写测试APP"><a href="#36-1-1-编写测试APP" class="headerlink" title="36.1.1 编写测试APP"></a>36.1.1 编写测试APP</h4><p>本实验对应的应用程序网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568 开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\29\app1</code>。<br>首先来编写应用测试代码ioctl.c，编写好的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_OPEN</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_CLOSE</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_SET</span> <span class="token expression"><span class="token function">_IOW</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">,</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_SET<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_SET<span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第8-10 行通过合成宏定义了三个ioctl 命令，分别代表定时器打开、定时器关闭、定时时间设置。<br>第18 行和第21 行将定时时间分别设置为1 秒和3 秒。<br>第19 行打开定时器。<br>第23 行关闭定时器。</p>
<h4 id="36-1-2-驱动程序编写"><a href="#36-1-2-驱动程序编写" class="headerlink" title="36.1.2 驱动程序编写"></a>36.1.2 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\29\module</code>。<br>编写好的驱动程序ioctl_timer.c 如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kdev_t.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/timer.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_OPEN</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_CLOSE</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_SET</span> <span class="token expression"><span class="token function">_IOW</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">device_test</span><span class="token punctuation">{</span>
    <span class="token class-name">dev_t</span> dev_num<span class="token punctuation">;</span>  <span class="token comment">//设备号</span>
    <span class="token keyword">int</span> major <span class="token punctuation">;</span>  <span class="token comment">//主设备号</span>
    <span class="token keyword">int</span> minor <span class="token punctuation">;</span>  <span class="token comment">//次设备号</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev_test<span class="token punctuation">;</span> <span class="token comment">// cdev</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>   <span class="token comment">//类</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备</span>
	<span class="token keyword">int</span> counter<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">device_test</span> dev1<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fnction_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义function_test定时功能函数</span>
<span class="token function">DEFINE_TIMER</span><span class="token punctuation">(</span>timer_test<span class="token punctuation">,</span>fnction_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义一个定时器</span>

<span class="token keyword">void</span> <span class="token function">fnction_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">timer_list</span> <span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"this is fnction_test\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mod_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_test<span class="token punctuation">,</span>jiffies_64 <span class="token operator">+</span> <span class="token function">msecs_to_jiffies</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用mod_timer函数重新设置定时时间</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span><span class="token comment">//设置私有数据</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cdev_test_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>private_data<span class="token operator">=</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">;</span><span class="token comment">//设置私有数据</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">cdev_test_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span>test_dev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_test</span> <span class="token operator">*</span><span class="token punctuation">)</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span><span class="token comment">//设置私有数据</span>
	<span class="token keyword">switch</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">case</span> TIMER_OPEN<span class="token operator">:</span>
			<span class="token function">add_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//添加一个定时器</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> TIMER_CLOSE<span class="token operator">:</span>
			<span class="token function">del_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除一个定时器</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> TIMER_SET<span class="token operator">:</span>
			test_dev<span class="token operator">-&gt;</span>counter <span class="token operator">=</span> arg<span class="token punctuation">;</span>
			timer_test<span class="token punctuation">.</span>expires <span class="token operator">=</span> jiffies_64 <span class="token operator">+</span> <span class="token function">msecs_to_jiffies</span><span class="token punctuation">(</span>test_dev<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置定时时间</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

	<span class="token keyword">default</span><span class="token operator">:</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设备操作函数*/</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> cdev_test_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span> <span class="token comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span>
	<span class="token punctuation">.</span>open <span class="token operator">=</span> cdev_test_open<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>release <span class="token operator">=</span> cdev_test_release<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> cdev_test_ioctl<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">timer_dev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动入口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注册字符设备驱动*/</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token comment">/*1 创建设备号*/</span>
    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"alloc_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//动态分配设备号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">goto</span> err_chrdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc_chrdev_region is ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dev1<span class="token punctuation">.</span>major <span class="token operator">=</span> <span class="token function">MAJOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取主设备号</span>
    dev1<span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token function">MINOR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取次设备号</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"major is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印主设备号</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"minor is %d \r\n"</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印次设备号</span>
     <span class="token comment">/*2 初始化cdev*/</span>
    dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cdev_test_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span>
   ret <span class="token operator">=</span>  <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">goto</span>  err_chr_add<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*4 创建类*/</span>
 dev1<span class="token punctuation">.</span> class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_class_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*5  创建设备*/</span>
  	dev1<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret<span class="token operator">=</span><span class="token function">PTR_ERR</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> err_device_create<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

err_device_create<span class="token operator">:</span>
        <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
err_class_create<span class="token operator">:</span>
       <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
err_chr_add<span class="token operator">:</span>
        <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
err_chrdev<span class="token operator">:</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">timer_dev_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//驱动出口函数</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*注销字符设备*/</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销设备号</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev1<span class="token punctuation">.</span>cdev_test<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除cdev</span>
    <span class="token function">device_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">,</span> dev1<span class="token punctuation">.</span>dev_num<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//删除设备</span>
    <span class="token function">class_destroy</span><span class="token punctuation">(</span>dev1<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//删除类</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>timer_dev_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>timer_dev_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="36-2-运行测试"><a href="#36-2-运行测试" class="headerlink" title="36.2 运行测试"></a>36.2 运行测试</h3><h4 id="36-2-1-编译驱动程序"><a href="#36-2-1-编译驱动程序" class="headerlink" title="36.2.1 编译驱动程序"></a>36.2.1 编译驱动程序</h4><p>在上一小节中的ioctl_timer.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成ioctl_timer.ko 目标文件，至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h4 id="36-2-2-编译应用程序"><a href="#36-2-2-编译应用程序" class="headerlink" title="36.2.2 编译应用程序"></a>36.2.2 编译应用程序</h4><p>来到存放应用程序ioctl.c 的文件夹下，使用以下命令对ioctl.c 进行交叉编译，编译完成如下图（图36-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> ioctl ioctl.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>生成的ioctl 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h4 id="36-2-3-运行测试"><a href="#36-2-3-运行测试" class="headerlink" title="36.2.3 运行测试"></a>36.2.3 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图36-5）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod ioctl_timer.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191107461.png" alt="image-20240819110728360"></p>
<p>输入以下命令运行可执行文件,运行成功如下图（图36-6）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191107660.png" alt="image-20240819110749562"></p>
<p>可以看到前面三个打印信息间隔为1 秒钟，后面三个打印信息间隔为3 秒钟，至此，实验一就结束了，然后使用以下命令卸载驱动模块，如下图（图36-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod ioctl_timer.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="36-3-封装驱动API-接口"><a href="#36-3-封装驱动API-接口" class="headerlink" title="36.3 封装驱动API 接口"></a>36.3 封装驱动API 接口</h3><p>至此，随着ioctl 练习的结束，字符设备驱动框架相关的知识也就完结了，相信细心的小伙伴在上一小节应用程序的编写中会发现问题，应用程序是从驱动的角度进行编写的，具体内容如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_OPEN</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_CLOSE</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_SET</span> <span class="token expression"><span class="token function">_IOW</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">,</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_SET<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_SET<span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>作为驱动工程师的我们当然可以理解每一行代码所要完成的功能，而一般情况下，应用都是由专业的应用工程师来进行编写的，上述代码编写方式很不利于应用工程师的理解和程序的移植，所以对于应用程序API 的封装是一件必然的事情。</p>
<p>封装好的应用程序网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\29\app2</code>。<br>首先来编写整体库文件timerlib.h，编写好的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_TIMELIB_H_</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_TIMELIB_H_</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_OPEN</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_CLOSE</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMER_SET</span> <span class="token expression"><span class="token function">_IOW</span><span class="token punctuation">(</span></span><span class="token char">'L'</span><span class="token expression"><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">int</span> <span class="token function">dev_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">timer_open</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">timer_close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">timer_set</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在9-11 行使用合成宏定义了三个ioctl 命令，分别代表定时器打开、定时器关闭、定时时间设置。<br>在第12-15 行定义了四个功能函数，所代表的功能分别为设备打开、定时器打开、定时器关闭、定时时间设置。<br>接下来将创建每个功能函数的c 文件，最后编译为单独的库，首先编写<code>dev_open.c</code> 文件，<br>编写好的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"timerlib.h"</span></span>
<span class="token keyword">int</span> <span class="token function">dev_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/test"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">,</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"file open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> fd<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后编写定时器打开函数<code>timeropen.c</code> 文件，编写好的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"timerlib.h"</span></span>
<span class="token keyword">int</span> <span class="token function">timer_open</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ioctl open error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编写定时器打开函数timerclose.c 文件，编写好的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"timerlib.h"</span></span>
<span class="token keyword">int</span> <span class="token function">timer_close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ioctl  close error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编写定时器打开函数timerset.c 文件，编写好的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"timerlib.h"</span></span>
<span class="token keyword">int</span> <span class="token function">timer_set</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>TIMER_SET<span class="token punctuation">,</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ioctl error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后编写测试要用到的应用程序ioctl.c 文件，编写好的代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"timerlib.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span>
	fd <span class="token operator">=</span> <span class="token function">dev_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">timer_set</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">timer_open</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">timer_set</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">timer_close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>至此，要用到的文件就都编写完成了，会在下一小节进行库的制作，以及应用程序的编译。</p>
<h3 id="36-4-运行测试"><a href="#36-4-运行测试" class="headerlink" title="36.4 运行测试"></a>36.4 运行测试</h3><h4 id="36-4-1-编译应用程序"><a href="#36-4-1-编译应用程序" class="headerlink" title="36.4.1 编译应用程序"></a>36.4.1 编译应用程序</h4><p>首先使用以下命令将存放功能函数的c 文件编译成.o 文件，编译完成如下图（图36-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-c</span> dev_open.c
aarch64-linux-gnu-gcc <span class="token parameter variable">-c</span> timer*.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191113494.png" alt="image-20240819111351385"></p>
<p>然后使用以下命令将相应的.o 文件编译成.a 静态库（这里要注意库的名称都以lib 开头），编译完成如下图（图36-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-ar rcs libtime.a timer*.o
aarch64-linux-gnu-ar rcs libopen.a dev_open.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191114505.png" alt="image-20240819111445392"></p>
<p>最后使用以下命令对ioctl.c 进行交叉编译，编译完成如下图（图36-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aarch64-linux-gnu-gcc <span class="token parameter variable">-o</span> ioctl ioctl.c -L./ <span class="token parameter variable">-ltime</span> <span class="token parameter variable">-lopen</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191115792.png" alt="image-20240819111510682"></p>
<p>生成的ioctl 文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。<br>36.4.2 运行测试<br>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图36-10）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod ioctl_timer.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191115035.png" alt="image-20240819111540927"></p>
<p>输入以下命令运行可执行文件,运行成功如下图（图36-11）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191115159.png" alt="image-20240819111550053"></p>
<p>可以看到前面三个打印信息间隔为1 秒钟，后面三个打印信息间隔为3 秒钟，至此，实验一就结束了，然后使用以下命令卸载驱动模块，如下图（图36-12）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod ioctl_timer.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191116724.png" alt="image-20240819111608613"></p>
<h2 id="第37-章优化驱动稳定性和效率实验"><a href="#第37-章优化驱动稳定性和效率实验" class="headerlink" title="第37 章优化驱动稳定性和效率实验"></a>第37 章优化驱动稳定性和效率实验</h2><p>在Linux 中应用程序运行在用户空间，应用程序错误之后，并不会影响其他程序的运行，而驱动工作在内核层，是内核代码的一部分，当驱动出现问题之后，可能会导致整个系统的崩溃。所以在驱动中，需要对各种判断、预处理等进行排查等，在本小节将对如何优化驱动稳定性和提高驱动效率进行学习。</p>
<h3 id="37-1-方法一：检测ioctl-命令"><a href="#37-1-方法一：检测ioctl-命令" class="headerlink" title="37.1 方法一：检测ioctl 命令"></a>37.1 方法一：检测ioctl 命令</h3><p>ioctl 的cmd 命令是由合成宏合成得到的，也有相应的分解宏得到各个参数，四个分解宏如下所示：<br>分解cmd 命令，得到命令的类型：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">_IOC_TYPE</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>分解cmd 命令，得到数据（args）的传输方向：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">_IOC_DIR</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>分解cmd 命令，得到命令的序号：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">_IOC_NR</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>分解cmd 命令，得到数据（args）的大小：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">_IOC_SIZE</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以在驱动中通过上述分解宏对传入的ioctl 命令类型等参数进行判断，从而得到判断传入的参数是否正确，以此优化驱动的稳定性。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">_IOC_TYPE</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'L'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"cmd type error \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>例如可以通过上述代码对传入参数的类型进行判断，如果传入的参数类型不为“L”,就返回错误，其他参数的检测方法相同。</p>
<h3 id="37-2-方法二：检测传递地址是否合理"><a href="#37-2-方法二：检测传递地址是否合理" class="headerlink" title="37.2 方法二：检测传递地址是否合理"></a>37.2 方法二：检测传递地址是否合理</h3><p><strong><code>access_ok()</code>函数</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token function">access_ok</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
函数作用：
    检查用户空间内存块是否可用
参数含义：
    addr <span class="token operator">:</span> 用户空间的指针变量，其指向一个要检查的内存块开始处。
    size <span class="token operator">:</span> 要检查内存块的大小。
返回值：
    成功返回<span class="token number">1</span>，失败返回<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以第35 章的ioctl 地址传参实验为例，对传入的<code>args</code> 地址进行判断，具体代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">args</span> test<span class="token punctuation">;</span>
<span class="token keyword">int</span> len<span class="token punctuation">;</span>
<span class="token keyword">switch</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">case</span> CMD_TEST0<span class="token operator">:</span>
        len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">args</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">access_ok</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在第6 行对传入的args 参数地址进行判断，如果不合法则返回-1，从而保证了驱动运行的稳定性。</p>
<h3 id="37-3-方法三：分支预测优化"><a href="#37-3-方法三：分支预测优化" class="headerlink" title="37.3 方法三：分支预测优化"></a>37.3 方法三：分支预测优化</h3><p>现在的CPU 都有ICache 和流水线机制。即运行当前指令时，ICache 会预读取后面的指令，从而提升效率。但是如果条件分支的结果是跳转到了其他指令，那预取下一条指令就浪费时间了。而本章节要用到的likely 和unlikely 宏，会让编译器总是将大概率执行的代码放在靠前的位置，从而提高驱动的效率。</p>
<p><code>likely</code> 和<code>unlikely</code> 宏定义在“<code>内核源码/include/linux/compiler.h</code>”文件中，具体定义如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">likely</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">__builtin_expect</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">unlikely</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">__builtin_expect</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>__builtin_expect 的作用是告知编译器预期表达式exp 等于c 的可能性更大，编译器可以根据该因素更好的对代码进行优化，所以likely 与unlikely 的作用就是表达性x 为真的可能性更大（likely）和更小（unlikely）。</p>
<p>这里以上一小节添加传递地址检测内容后的代码为例，对copy_from_user 函数添加分支预测优化函数，添加完成如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">args</span> test<span class="token punctuation">;</span>
<span class="token keyword">int</span> len<span class="token punctuation">;</span>
<span class="token keyword">switch</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">case</span> CMD_TEST0<span class="token operator">:</span>
        len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">args</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">access_ok</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"copy_from_user error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>传递地址检测成功之后才会使用执行<code>copy_from_user</code> 函数，<strong>在传递地址正确的前提下<code>copy_from_user</code> 函数运行失败为小概率事件</strong>，所以这里<strong>使用unlikely 函数进行驱动效率的优化</strong>。至此，关于分支预测优化相关的知识就讲解完成了。</p>
<h2 id="第38-章驱动调试方法实验"><a href="#第38-章驱动调试方法实验" class="headerlink" title="第38 章驱动调试方法实验"></a>第38 章驱动调试方法实验</h2><p>在之前编写的驱动程序中，通常都使用printk 函数打印相应的提示信息从而对驱动进行调试，那有没有其他的方式来调试驱动呢，答案是肯定的，在本章节中将对不同驱动调试方法进行学习。</p>
<h3 id="38-1-方法1：dump-stack-函数"><a href="#38-1-方法1：dump-stack-函数" class="headerlink" title="38.1 方法1：dump_stack 函数"></a>38.1 方法1：dump_stack 函数</h3><p>作用:<strong>打印内核调用堆栈，并打印函数的调用关系。</strong><br>这里以最简单的helloworld 驱动为例进行dump_stack 函数演示，实验代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">helloworld_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_init\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dump_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">helloworld_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_exit\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>helloworld_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>helloworld_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和原helloworld 驱动程序相比，在第6 行添加了dump_stack()，驱动加载之后打印信息如下（图38-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191122046.png" alt="image-20240819112218913"></p>
<p>可以看到helloworld_init 函数的调用关系就都打印了出来。  至此关于dump_stack 函数的测试就完成了。</p>
<h3 id="38-2-方法2：WARN-ON-condition-函数"><a href="#38-2-方法2：WARN-ON-condition-函数" class="headerlink" title="38.2 方法2：WARN_ON(condition)函数"></a>38.2 方法2：<code>WARN_ON(condition)</code>函数</h3><p>WARN_ON (condition)函数作用:在括号中的条件成立时，内核会抛出栈回溯，打印函数的调用关系。通常用于内核抛出一个警告，暗示某种不太合理的事情发生了。</p>
<p>WARN_ON 实际上也是调用dump_stack，只是多了参数condition 判断条件是否成立，例如WARN_ON (1)则条件判断成功，函数会成功执行。</p>
<p>这里仍然以最简单的helloworld 驱动为例进行WARN_ON 函数演示，实验代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">helloworld_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_init\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">WARN_ON</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">helloworld_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_exit\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>helloworld_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>helloworld_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和原helloworld 驱动程序相比，在第6 行添加了WARN_ON(1)，驱动加载之后打印信息如下（图38-2）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191123617.png" alt="image-20240819112326430"></p>
<p>可以看到helloworld_init 函数的调用关系以及寄存器值就都打印了出来。  至此关于WARN_ON 函数的测试就完成了。</p>
<h3 id="38-3-方法3：BUG-ON-condition-函数"><a href="#38-3-方法3：BUG-ON-condition-函数" class="headerlink" title="38.3 方法3：BUG_ON (condition)函数"></a>38.3 方法3：<code>BUG_ON (condition)</code>函数</h3><p>内核中有许多地方调用类似BUG_ON()的语句，它非常像一个内核运行时的断言，意味着本来不该执行到BUG_ON()这条语句，一旦BUG_ON()执行内核就会立刻抛出oops，导致栈的回溯和错误信息的打印。大部分体系结构把BUG()和BUG_ON()定义成某种非法操作，这样自然会产生需要的oops。参数condition 判断条件是否成立，例如BUG_ON (1)则条件判断成功，函数会成功执行。</p>
<p>这里仍然以最简单的helloworld 驱动为例进行BUGON 函数演示，实验代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">helloworld_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_init\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">BUGON</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">helloworld_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_exit\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>helloworld_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>helloworld_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和原helloworld 驱动程序相比，在第6 行添加了BUGON(1)，驱动加载之后打印信息如下（图38-3）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191124011.png" alt="image-20240819112450829"></p>
<p>可以看到helloworld_init 函数的调用关系以及寄存器值就都打印了出来。至此关于<code>BUGON(1)</code>函数的测试就完成了。</p>
<h3 id="38-4-方法4：panic-fmt-函数"><a href="#38-4-方法4：panic-fmt-函数" class="headerlink" title="38.4 方法4：panic (fmt...)函数"></a>38.4 方法4：<code>panic (fmt...)</code>函数</h3><p><code>panic (fmt...)</code>函数:输出打印会造成系统死机并将函数的调用关系以及寄存器值就都打印了出来。</p>
<p>这里仍然以最简单的helloworld 驱动为例进行panic 函数的演示，实验代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">helloworld_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_init\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">helloworld_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">"helloworld_exit\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>helloworld_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>helloworld_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL v2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和原helloworld 驱动程序相比，在第6 行添加了<code>panic("!!!!!!!!!!!!!!!!!!!!!!!!!!!!")</code>，驱动加载之后打印信息如下（图38-4）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191126855.png" alt="image-20240819112614704"></p>
<p>可以看到helloworld_init 函数的调用关系以及寄存器值就都打印了出来，信息打印完成之后会发现系统已经崩溃了，终端已经无法再进行输入。<br>至此关于panic 函数的测试就完成了。</p>
<h1 id="第五篇中断"><a href="#第五篇中断" class="headerlink" title="第五篇中断"></a>第五篇中断</h1><h2 id="第39-章中断实验"><a href="#第39-章中断实验" class="headerlink" title="第39 章中断实验"></a>第39 章中断实验</h2><p>在前面的课程中，我们深入学习了高级字符设备的进阶知识，包括IO 模型、定时器原理、llseek 设备定位和通过ioctl 传递参数等。通过这些课程，我们对高级字符设备有了深入的理解，并掌握了一些实用的技术和编程方法。从今天开始，我们就进入中断课程的学习了。中断是操作系统中至关重要的机制，它能够显著提高系统的响应性能和并发处理能力。</p>
<h3 id="39-1-什么是中断？"><a href="#39-1-什么是中断？" class="headerlink" title="39.1 什么是中断？"></a>39.1 什么是中断？</h3><h4 id="39-1-1-中断的概念"><a href="#39-1-1-中断的概念" class="headerlink" title="39.1.1 中断的概念"></a>39.1.1 中断的概念</h4><p>中断是指在CPU 正常运行期间，由外部或内部事件引起的一种机制。当中断发生时，CPU会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU 会返回到中断发生的地方，继续执行被中断的程序。中断机制允许CPU 在实时响应外部或内部事件的同时，保持对其他任务的处理能力。</p>
<p>可以想象这样一幅画面，你正在烹饪一顿美味的晚餐，准备了各种食材，点燃了炉灶，开始了幸福的烹饪过程，突然，你的手机响起，有人打来了一个紧急电话，打破了你正常的烹饪流程，这时候你需要立刻停止手中的工作，迅速接起电话，与对方进行交流，在接完电话之后，再回到厨房继续之前的烹饪流程。这就是一个在实际生活中的中断案例，中断的概念流程图如下（39-1）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191127011.png" alt="image-20240819112729887" style="zoom:50%;">

<h4 id="39-1-2-中断的重要性"><a href="#39-1-2-中断的重要性" class="headerlink" title="39.1.2 中断的重要性"></a>39.1.2 中断的重要性</h4><p>在上面的场景中，作为唯一具有处理能力的主体，我们一次只能专注于一个任务，可以等待水烧开、看电视等等。然而，当我们专心致志地完成一项任务时，常常会有紧迫或不紧迫的其他事情突然出现，需要我们关注和处理。有些情况甚至要求我们立即停下手头的工作来应对。只有在处理完这些中断事件之后，我们才能回到先前的任务。</p>
<p>中断机制赋予了我们处理意外情况的能力，而且如果我们能充分利用这个机制，就能够同时完成多个任务。回到烧水的例子，无论我们是否在厨房，煤气灶都会将水烧开。我们只需要在水烧开后及时关掉煤气。为了避免在厨房等待的时间，而水烧开时产生的声音就是中断信号，提醒我们炉子上的水已经烧开。这样，我们就可以在等待的时间里做其他事情，比如看电视。当水壶烧开发出声音之后，它会打断当前的任务，提醒水已经烧开，这时只需要前往厨房关掉煤气即可。</p>
<p>中断机制使我们能够有条不紊地同时处理多个任务，从而提高了并发处理能力。类似地，计算机系统中也使用中断机制来应对各种外部事件。例如，在键盘输入时，会发送一个中断信号给CPU，以便及时响应用户的操作。这样，CPU 就不必一直轮询键盘的状态，而可以专注于其他任务。中断机制还可以用于处理硬盘读写完成、网络数据包接收等事件，提高了系统的资源利用率和并发处理能力。</p>
<h4 id="39-1-3-中断的上下半部"><a href="#39-1-3-中断的上下半部" class="headerlink" title="39.1.3 中断的上下半部"></a>39.1.3 中断的上下半部</h4><p>中断的执行需要快速响应，但并不是所有中断都能迅速完成。此外，Linux 中的中断不支持嵌套，意味着在正式处理中断之前会屏蔽其他中断，直到中断处理完成后再重新允许接收中断，如果中断处理时间过长，将会引发问题。</p>
<p>这里仍旧以烹饪的过程中接电话进行举例：当你正在烹饪一顿美味的晚餐时，所有的食材都准备好了，炉灶上的火焰跳跃着，你正享受着烹饪的乐趣。突然，你的手机响起，发出紧急电话的铃声，打破了你正常的烹饪流程，接电话的时间很短并不会对烹饪产生很大的影响，而接电话的时候可能就有问题了，水烧开之后可能会煮干、错过了最好的添加调味料的时间等等。</p>
<p>而为了让系统可以更好地处理中断事件，提高实时性和响应能力，将中断服务程序划分为<strong>上下文两部分</strong>：</p>
<p>中断上文是中断服务程序的第一部分，它主要处理一些紧急且需要快速响应的任务。中断上文的特点是执行时间较短，旨在尽快完成对中断的处理。这些任务可能包括保存寄存器状态、更新计数器等，以便在中断处理完成后能够正确地返回到中断前的执行位置。</p>
<p>中断下文是中断服务程序的第二部分，它主要处理一些相对耗时的任务。由于中断上文需要尽快完成，因此中断下文负责处理那些不能立即完成的、需要更多时间的任务。这些任务可能包括复杂的计算、访问外部设备或进行长时间的数据处理等。</p>
<h3 id="39-2-中断子系统框架"><a href="#39-2-中断子系统框架" class="headerlink" title="39.2 中断子系统框架"></a>39.2 中断子系统框架</h3><p>一个完整的中断子系统框架可以分为四个层次，由上到下分别为用户层、通用层、硬件相关层和硬件层，每个层相关的介绍如下（图39-2）所示：</p>
<ul>
<li><strong>用户层</strong>：用户层是中断的使用者，主要包括各类设备驱动。这些驱动程序通过中断相关的接口进行中断的申请和注册。当外设触发中断时，用户层驱动程序会进行相应的回调处理，执行特定的操作。</li>
<li><strong>通用层</strong>：通用层也可称为框架层，它是硬件无关的层次。通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。通用层提供了统一的接口和功能，用于管理和处理中断，使得驱动程序能够在不同的硬件平台上复用。</li>
<li><strong>硬件相关层</strong>：硬件相关层包含两部分代码。一部分是与特定处理器架构相关的代码，比如ARM64 处理器的中断处理相关代码。这些代码负责处理特定架构的中断机制，包括中断向量表、中断处理程序等。另一部分是中断控制器的驱动代码，用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。</li>
<li><strong>硬件层</strong>：硬件层位于最底层，与具体的硬件连接相关。它包括外设与SoC（系统片上芯片）的物理连接部分。中断信号从外设传递到中断控制器，由中断控制器统一管理和路由到处理器。硬件层的设计和实现决定了中断信号的传递方式和硬件的中断处理能力。</li>
</ul>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191134017.png" alt="image-20240819113451875"></p>
<p>本小节的重点会聚集在硬件层各部分的详细讲解以及用户层编写驱动程序所用到的接口函数。</p>
<h4 id="39-2-1-中断控制器GIC"><a href="#39-2-1-中断控制器GIC" class="headerlink" title="39.2.1 中断控制器GIC"></a>39.2.1 中断控制器GIC</h4><p><strong>中断控制器GIC（Generic Interrupt Controller）</strong>是中断子系统框架硬件层中的一个关键组件，用于管理和控制中断。它接收来自各种中断源的中断请求，并根据预先配置的中断优先级、屏蔽和路由规则，将中断请求分发给适当的处理器核心或中断服务例程。</p>
<p>GIC 是由ARM 公司提出设计规范，当前有四个版本，GIC V1-v4。设计规范中最常用的，有3 个版本V2.0、V3.1、V4.1，GICv3 版本设计主要运行在Armv8-A, Armv9-A 等架构上。ARM 公司并给出一个实际的控制器设计参考，比如GIC-400(支持GIC v2 架构)、gic500(支持GIC v3 架构)、GIC-600(支持GIC v3 和GIC v4 架构)。最终芯片厂商可以自己实现GIC 或者直接购买ARM提供的设计。</p>
<p>每个GIC 版本及相应特性如下表（表39-3）所示：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>关键特性</th>
<th>常用核心</th>
</tr>
</thead>
<tbody><tr>
<td>GICv1</td>
<td>支持最多八个处理器核心（PE）<br>支持最多1020 个中断ID</td>
<td>ARM Cortex-A5 MPCore<br>ARM Cortex-A9 MPCore<br>ARM Cortex-R7 MPCore</td>
</tr>
<tr>
<td>GICv2</td>
<td>GICv1 的所有关键特性<br>支持虚拟化</td>
<td>ARM Cortex-A7 MPCore<br>ARM Cortex-A15 MPCore<br>ARM Cortex-A53 MPCore<br>ARM Cortex-A57 MPCore</td>
</tr>
<tr>
<td>GICv3</td>
<td>GICv2 的所有关键特性<br>支持超过8 个处理器核心<br>支持基于消息的中断<br>支持超过1020 个中断ID<br>CPU 接口寄存器的系统寄存器访问<br>增强的安全模型，分离安全和非安全的Group 1 中断</td>
<td>ARM Cortex-A53MPCore<br>ARM Cortex-A57MPCore<br>ARM Cortex-A72 MPCore</td>
</tr>
<tr>
<td>GICv4</td>
<td>GICv3 的所有关键特性<br>虚拟中断的直接注入</td>
<td>ARM Cortex-A53 MPCore<br>ARMCortex-A57MPCore<br>ARM Cortex-A72 MPCore</td>
</tr>
</tbody></table>
<p>在RK3568 上使用的GIC 版本为GICv3，相应的中断控制器模型如下（图39-4）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191141587.png" alt="image-20240819114128421"></p>
<p>GIC 中断控制器可以分为Distributor 接口、Redistributor 接口和CPU 接口，下面是每个部分的说明：</p>
<p><strong>Distributor 中断仲裁器：</strong></p>
<p>包含影响所有处理器核心中断的全局设置。包含以下编程接口：</p>
<ul>
<li>●启用和禁用SPI。</li>
<li>●设置每个SPI 的优先级级别。</li>
<li>●每个SPI 的路由信息。</li>
<li>●将每个SPI 设置为电平触发或边沿触发。</li>
<li>●生成基于消息的SPI。</li>
<li>●控制SPI 的活动和挂起状态。</li>
<li>●用于确定在每个安全状态中使用的程序员模型的控制（亲和性路由或遗留模型）。</li>
</ul>
<p><strong>Redistributor 重新分配器：</strong></p>
<p>对于每个连接的处理器核心（PE），都有一个重新分配器（Redistributor）。重新分配器提供以下编程接口：</p>
<ul>
<li>●启用和禁用SGI（软件生成的中断）和PPI（处理器专用中断）。</li>
<li>●设置SGI 和PPI 的优先级级别。</li>
<li>●将每个PPI 设置为电平触发或边沿触发。</li>
<li>●将每个SGI 和PPI 分配给一个中断组。</li>
<li>●控制SGI 和PPI 的状态。</li>
<li>●对支持关联 LP（I 低功耗中断）的中断属性和挂起状态的内存中的数据结构进行基址控制。</li>
<li>●支持与连接的处理器核心的电源管理。</li>
</ul>
<p><strong>CPU 接口：</strong></p>
<p>每个重新分配器都连接到一个CPU 接口。CPU 接口提供以下编程接口：</p>
<ul>
<li>●通用控制和配置，用于启用中断处理。</li>
<li>●确认中断。</li>
<li>●执行中断的优先级降低和停用。</li>
<li>●为处理器核心设置中断优先级屏蔽。</li>
<li>●定义处理器核心的抢占策略。</li>
<li>●确定处理器核心最高优先级的挂起中断。</li>
</ul>
<h4 id="39-2-2-中断类型"><a href="#39-2-2-中断类型" class="headerlink" title="39.2.2 中断类型"></a>39.2.2 中断类型</h4><p>GIC-V3 支持四种类型的中断，分别是SGI、PPI、SPI 和LPI，每个中断类型的介绍如下：</p>
<ul>
<li>SGI（Software Generated Interrupt，软件生成中断）：SGI 是通过向GIC 中的SGI 寄存器写入来生成的中断。它通常用于处理器之间的通信，允许一个PE 发送中断给一个或多个指定的PE，中断号ID0 - ID15 用于SGI。</li>
<li>PPI（Private Peripheral Interrupt，私有外设中断）：针对特定PE 的外设中断。不与其他PE共享，中断号ID16 - ID31 用于PPI。</li>
<li>SPI（Shared Peripheral Interrupt，共享外设中断）：全局外设中断，可以路由到指定的处理器核心（PE）或一组PE，它允许多个PE 接收同一个中断。中断号ID32 - ID1019 用于SPI，</li>
<li>LPI（Locality-specific Peripheral Interrupt，特定局部外设中断）：LPI 是GICv3 中引入的一种中断类型，与其他类型的中断有几个不同之处。LPI 总是基于消息的中断，其配置存储在内存表中，而不是寄存器中。</li>
</ul>
<table>
<thead>
<tr>
<th>INTID 范围</th>
<th>中断类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0 - 15</td>
<td>SGI（软件生成中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td>16 - 31</td>
<td>PPI（私有外设中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td>32 - 1019</td>
<td>SPI（共享外设中断）</td>
<td></td>
</tr>
<tr>
<td>1020 - 1023</td>
<td>特殊中断号</td>
<td>用于表示特殊情况</td>
</tr>
<tr>
<td>1024 - 8191</td>
<td>保留</td>
<td></td>
</tr>
<tr>
<td>8192 及更大</td>
<td>LPI（特定局部外设中断）</td>
<td>上限由实现定义</td>
</tr>
</tbody></table>
<p>中断处理的状态机如下图（图39-6）所示：</p>
<p> <img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191146719.png" alt="image-20240819114654563"></p>
<ul>
<li>Inactive（非活动状态）：中断源当前未被触发。</li>
<li>Pending（等待状态）：中断源已被触发，但尚未被处理器核心确认。</li>
<li>Active（活动状态）：中断源已被触发，并且已被处理器核心确认。</li>
<li>Active and Pending（活动且等待状态）：已确认一个中断实例，同时另一个中断实例正在等待处理。</li>
</ul>
<p>每个外设中断可以是以下两种类型之一：</p>
<ul>
<li><strong>边沿触发（Edge-triggered）：</strong><ul>
<li>这是一种在检测到中断信号上升沿时触发的中断，然后无论信号状态如何，都保持触发状态，直到满足本规范定义的条件来清除中断。</li>
</ul>
</li>
<li><strong>电平触发（Level-sensitive）：</strong><ul>
<li>这是一种在中断信号电平处于活动状态时触发的中断，并且在电平不处于活动状态时取消触发。</li>
</ul>
</li>
</ul>
<h4 id="39-2-3-中断号"><a href="#39-2-3-中断号" class="headerlink" title="39.2.3 中断号"></a>39.2.3 中断号</h4><p>在linux 内核中，我们使用IRQ number 和HW interrupt ID 两个ID 来标识一个来自外设的中断：</p>
<ul>
<li><strong>IRQ number</strong>：CPU 需要为每一个外设中断编号，我们称之IRQ Number。这个IRQ number是一个虚拟的interrupt ID，和硬件无关，仅仅是被CPU 用来标识一个外设中断。</li>
<li><strong>HW interrupt ID</strong>：对于GIC 中断控制器而言，它收集了多个外设的interrupt request line 并向上传递，因此，GIC 中断控制器需要对外设中断进行编码。GIC 中断控制器用HW interrupt ID来标识外设的中断。如果只有一个GIC 中断控制器，那IRQ number 和HW interrupt ID 是可以一一对应的，如下图（图39-7）所示：</li>
</ul>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191149452.png" alt="image-20240819114919339" style="zoom:80%;">

<p>但如果是在GIC 中断控制器级联的情况下，仅仅用HW interrupt ID 就不能唯一标识一个外设中断，还需要知道该HW interrupt ID 所属的GIC 中断控制器（<strong>HW interrupt ID 在不同的Interrupt controller 上是会重复编码的</strong>）。</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191150492.png" alt="image-20240819115015377" style="zoom:80%;">

<p>这样，CPU 和中断控制器在标识中断上就有了一些不同的概念，但是，对于驱动工程师而言，我们和CPU 视角是一样的，我们只希望得到一个IRQ number，而不关系具体是那个GIC中断控制器上的那个HW interrupt ID。这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。因此，linux kernel 中的中断子系统需要提供一个将HW interrupt ID 映射到IRQ number 上来的机制，也就是irq domain。</p>
<h4 id="39-2-4-中断申请函数"><a href="#39-2-4-中断申请函数" class="headerlink" title="39.2.4 中断申请函数"></a>39.2.4 中断申请函数</h4><p><strong>（1）request_irq</strong></p>
<p><code>request_irq</code> 函数是在Linux 内核中用于注册中断处理程序的函数。它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来。下面是对request_irq 函数的详细介绍：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">int</span> <span class="token function">request_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token class-name">irq_handler_t</span> handler<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
头文件：
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
函数作用：
    request_irq 函数的主要功能是请求一个中断号，并将一个中断处理程序与该中断号关联起来。当中断事件发生时，与该中断号关联的中断处理程序会被调用执行。
    
参数含义：
    irq：要请求的中断号（IRQ number）。
    handler：指向中断处理程序的函数指针。
    flags：标志位，用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。
    name：中断的名称，用于标识该中断。
    dev：指向设备或数据结构的指针，可以在中断处理程序中使用。
返回值：
    成功：<span class="token number">0</span> 或正数，表示中断请求成功。
    失败：负数，表示中断请求失败，返回的负数值表示错误代码。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>irq 参数用来指定要请求的中断号，中断号需要通过gpio_to_irq 函数映射GPIO 引脚来获得（gpio_to_irq 函数接下来会进行介绍）。</p>
<p>irq_handler_t handler 参数是一个函数指针，指向了中断处理程序的函数。中断处理程序是在中断事件发生时调用的函数，用于处理中断事件（关于中断处理程序会在下个小节进行详细的讲解）。</p>
<p>unsigned long flags：中断处理程序的标志位</p>
<p>这个参数用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。可以使用不同的标志位进行位运算来组合多个属性。常用的标志位包括：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">IRQF_TRIGGER_NONE：		<span class="token comment">//无触发方式，表示中断不会被触发。</span>
IRQF_TRIGGER_RISING：	<span class="token comment">//上升沿触发方式，表示中断在信号上升沿时触发。</span>
IRQF_TRIGGER_FALLING：	<span class="token comment">//下降沿触发方式，表示中断在信号下降沿时触发。</span>
IRQF_TRIGGER_HIGH：		<span class="token comment">//高电平触发方式，表示中断在信号为高电平时触发。</span>
IRQF_TRIGGER_LOW：		<span class="token comment">//低电平触发方式，表示中断在信号为低电平时触发。</span>
IRQF_SHARED：			<span class="token comment">//中断共享方式，表示中断可以被多个设备共享使用。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>（2）gpio_to_irq</strong></p>
<p>gpio_to_irq 函数用于将GPIO 引脚的编号（GPIO pin number）转换为对应的中断请求号（interrupt request number）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
头文件：
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/gpio.h&gt;</span></span>
函数功能：
    gpio_to_irq 是一个用于将GPIO 引脚映射到对应中断号的函数。它的作用是根据给定的GPIO 引脚号，获取与之关联的中断号。
    
参数说明：
    gpio：要映射的GPIO 引脚号。
返回值：
    成功：返回值为该GPIO 引脚所对应的中断号。
    失败：返回值为负数，表示映射失败或无效的GPIO 引脚号。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>（3）free_irq</strong></p>
<p>free_irq 函数用于释放之前通过request_irq 函数注册的中断处理程序。它的作用是取消对中断的注册并释放相关的系统资源。下面是关于该函数的详细解释：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">void</span> <span class="token function">free_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
头文件：
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
函数功能：
    free_irq 函数用于释放之前通过request_irq 函数注册的中断处理程序。它会取消对中断的注册并释放相关的系统资源，包括中断号、中断处理程序和设备标识等。
    
参数说明：
    irq：要释放的中断号。
    dev_id：设备标识，用于区分不同的中断请求。它通常是在request_irq 函数中传递的设备特定数据指针。
返回值：
    free_irq 函数没有返回值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="39-2-5-中断服务函数"><a href="#39-2-5-中断服务函数" class="headerlink" title="39.2.5 中断服务函数"></a>39.2.5 中断服务函数</h4><p>中断处理程序是在中断事件发生时自动调用的函数。它负责处理与中断相关的操作，例如读取数据、清除中断标志、更新状态等。<br><code>irqreturn_t handler(int irq, void *dev_id)</code> 是一个典型的中断服务函数的函数原型。下面对该函数原型及其参数进行详细解释：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token class-name">irqreturn_t</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
函数功能：
    handler 函数是一个中断服务函数，用于处理特定中断事件。它在中断事件发生时被操作系统或硬件调用，执行必要的操作来响应和处理中断请求。
    
参数说明：
    irq：表示中断号或中断源的标识符。它指示引发中断的硬件设备或中断控制器。
    dev_id：是一个<span class="token keyword">void</span> 类型的指针，用于传递设备特定的数据或标识符。它通常用于在中断处理程序中区分不同的设备或资源。
    
返回值：
    <span class="token class-name">irqreturn_t</span> 是一个特定类型的枚举值，用于表示中断服务函数的返回状态。它可以有以下几种取值：
        IRQ_NONE：表示中断服务函数未处理该中断，中断控制器可以继续处理其他中断请求。
        IRQ_HANDLED：表示中断服务函数已成功处理该中断，中断控制器无需进一步处理。
        IRQ_WAKE_THREAD：表示中断服务函数已处理该中断，并且请求唤醒一个内核线程来继续执行进一步的处理。这在一些需要长时间处理的中断情况下使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在处理程序中，通常需要注意以下几个方面：<br>（1）处理程序应该尽可能地快速执行，以避免中断丢失或过多占用CPU 时间。<br>（2）如果中断源是共享的，处理程序需要处理多个设备共享同一个中断的情况。<br>（3）处理程序可能需要与其他部分的代码进行同步，例如访问共享数据结构或使用同步机制来保护临界区域。<br>（4）处理程序可能需要与其他线程或进程进行通信，例如唤醒等待的线程或发送信号给其他进程。</p>
<h3 id="39-3-实验程序编写"><a href="#39-3-实验程序编写" class="headerlink" title="39.3 实验程序编写"></a>39.3 实验程序编写</h3><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\30_interrupt\03_中断驱动例程</code>。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD 显示屏就会触发中断服务函数，在中断服务函数中会打印申请的GPIO 号和This is irq_handler。</p>
<p>iTOP-RK3568 有5 组GPIO bank：GPIO0<del>GPIO4，每组又以A0</del>A7, B0<del>B7, C0</del>C7, D0~D7 作为编号区分,常用以下公式计算引脚：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIO pin 脚计算公式：pin <span class="token operator">=</span> bank <span class="token operator">*</span> <span class="token number">32</span> <span class="token operator">+</span> number 	<span class="token comment">//bank 为组号，number 为小组编号</span>
GPIO 小组编号计算公式：number <span class="token operator">=</span> group <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">+</span> X<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>LCD 触摸屏对应的中断引脚标号为<code>TP_INT_L_GPIO3_A5</code>，对应的计算过程如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bank <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> 		<span class="token comment">//GPIO3_A5=&gt; 3, bank ∈ [0,4]</span>
group <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 		<span class="token comment">//GPIO3_A5 =&gt; 0, group ∈ {(A=0), (B=1), (C=2), (D=3)}</span>
X <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> 			<span class="token comment">//GPIO3_A5 =&gt; 5, X ∈ [0,7]</span>
number <span class="token operator">=</span> group <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">+</span> X <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">=</span><span class="token number">5</span>
pin <span class="token operator">=</span> bank<span class="token operator">*</span><span class="token number">32</span> <span class="token operator">+</span> number<span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">32</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>得到中断引脚的引脚标号后，下面开始编写对应的驱动程序，编写完成的interrupt.c 如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/gpio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GPIO_PIN</span> <span class="token expression"><span class="token number">101</span></span></span>

<span class="token comment">// 中断处理函数</span>
<span class="token keyword">static</span> <span class="token class-name">irqreturn_t</span> <span class="token function">gpio_irq_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"Interrupt occurred on GPIO %d\n"</span><span class="token punctuation">,</span> GPIO_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"This is irq_handler\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> IRQ_HANDLED<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">interrupt_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> irq_num<span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"Initializing GPIO Interrupt Driver\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 将GPIO引脚映射到中断号</span>
    irq_num <span class="token operator">=</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span>GPIO_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"GPIO %d mapped to IRQ %d\n"</span><span class="token punctuation">,</span> GPIO_PIN<span class="token punctuation">,</span> irq_num<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 请求中断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">request_irq</span><span class="token punctuation">(</span>irq_num<span class="token punctuation">,</span> gpio_irq_handler<span class="token punctuation">,</span> IRQF_TRIGGER_RISING<span class="token punctuation">,</span> <span class="token string">"irq_test"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"Failed to request IRQ %d\n"</span><span class="token punctuation">,</span> irq_num<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 请求中断失败，释放GPIO引脚</span>
        <span class="token function">gpio_free</span><span class="token punctuation">(</span>GPIO_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>ENODEV<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">interrupt_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> irq_num <span class="token operator">=</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span>GPIO_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 释放中断</span>
    <span class="token function">free_irq</span><span class="token punctuation">(</span>irq_num<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"GPIO Interrupt Driver exited successfully\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>interrupt_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>interrupt_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="39-4-运行测试"><a href="#39-4-运行测试" class="headerlink" title="39.4 运行测试"></a>39.4 运行测试</h3><h4 id="39-4-1-编译驱动程序"><a href="#39-4-1-编译驱动程序" class="headerlink" title="39.4.1 编译驱动程序"></a>39.4.1 编译驱动程序</h4><p>在上一小节中的timer_mod.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成interrupt.ko 目标文件，至此驱动模块就编译成功了。</p>
<h4 id="39-4-2-运行测试"><a href="#39-4-2-运行测试" class="headerlink" title="39.4.2 运行测试"></a>39.4.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图39-12）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod interrupt.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191204956.png" alt="image-20240819120402829"></p>
<p>可以看到驱动加载之后，打印了“Initializing GPIO Interrupt Driver”表示程序加载成功了，在后面又打印了gpio 映射后的中断请求号为113，然后触摸LCD 屏，触发中断服务程序，打印如下图（图39-13）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191204283.png" alt="image-20240819120415152"></p>
<p>成功打印了GPIO 的引脚编号以及“This is irq_handler”，证明编写的驱动程序没有问题，最后使用以下命令卸载相应的驱动，如下图（图39-14）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod interrupt.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408191204363.png" alt="image-20240819120435241"></p>
<h2 id="第40-章中断申请流程"><a href="#第40-章中断申请流程" class="headerlink" title="第40 章中断申请流程"></a>第40 章中断申请流程</h2><p>在上一章中，我们简单的认识了一下中断以及中断子系统框架，最后编写了中断申请和中断服务函数的实验，大家会发现虽然前面讲解的只是点很多，但实际用起来只需要两三个函数就可以了，但中断的具体申请流程是怎样的呢，大家就不是很清楚了，在本章节将带领大家研究中断的申请流程。</p>
<h3 id="40-1-request-irq-函数"><a href="#40-1-request-irq-函数" class="headerlink" title="40.1 request_irq 函数"></a>40.1 <code>request_irq</code> 函数</h3><p>中断申请使用的是<code>request_irq</code> 函数，它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来，它定义在<code>内核源码的“/include/linux/interrupt.h”</code>目录下，具体定义如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">request_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token class-name">irq_handler_t</span> handler<span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">request_threaded_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> name<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>从上面的内容可以得到<code>request_irq()</code>函数实际上是调用了<code>request_threaded_irq()</code>函数来完成中断申请的过程。<code>request_threaded_irq()</code>函数提供了线程化的中断处理方式，可以在中断上下文中执行中断处理函数。</p>
<h3 id="40-2-request-threaded-irq-函数"><a href="#40-2-request-threaded-irq-函数" class="headerlink" title="40.2 request_threaded_irq 函数"></a>40.2 request_threaded_irq 函数</h3><p><code>request_threaded_irq</code> 函数是Linux 内核提供的一个功能强大的函数，用于请求分配一个中断，并将中断处理程序与该中断关联起来。该函数的主要作用是在系统中注册中断处理函数，以响应对应中断的发生。以下是request_threaded_irq 函数的功能和作用的详细介绍：</p>
<ul>
<li>（1）中断请求：request_threaded_irq 函数用于请求一个中断。它会向内核注册对应中断号的中断处理函数，并为该中断分配必要的资源。中断号是标识特定硬件中断的唯一标识符。</li>
<li>（2）中断处理函数关联：通过handler 参数，将中断处理函数与中断号关联起来。中断处理函数是一个预定义的函数，用于处理中断事件。当中断发生时，内核将调用该函数来处理中断事件。</li>
<li>（3）线程化中断处理：request_threaded_irq 函数还支持使用线程化中断处理函数。通过指定thread_fn 参数，可以在一个内核线程上下文中异步执行较长时间的中断处理或延迟敏感的工作。这有助于避免在中断上下文中阻塞时间过长。</li>
<li>（4）中断属性设置：通过irqflags 参数，可以设置中断处理的各种属性和标志。例如，可以指定中断触发方式（上升沿、下降沿、边沿触发等）、中断类型（边沿触发中断、电平触发中断等）以及其他特定的中断行为。</li>
<li>（5）设备标识关联：通过dev_id 参数，可以将中断处理与特定设备关联起来。这样可以在中断处理函数中访问与设备相关的数据。设备标识符可以是指向设备结构体或其他与设备相关的数据的指针。</li>
<li>（6）错误处理：request_threaded_irq 函数会返回一个整数值，用于指示中断请求的结果。如果中断请求成功，返回值为0；如果中断请求失败，则返回一个负数错误代码，表示失败的原因。</li>
</ul>
<p>request_threaded_irq 函数定义在内核源码目录下的“/kernel/irq/manage.c”文件中，具体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">request_threaded_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token class-name">irq_handler_t</span> handler<span class="token punctuation">,</span><span class="token class-name">irq_handler_t</span> thread_fn<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> irqflags<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>devname<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>action<span class="token punctuation">;</span> <span class="token comment">// 中断动作结构体指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token operator">*</span>desc<span class="token punctuation">;</span> <span class="token comment">// 中断描述符指针</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">;</span> <span class="token comment">// 返回值</span>
    <span class="token comment">// 检查中断号是否为未连接状态</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>irq <span class="token operator">==</span> IRQ_NOTCONNECTED<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>ENOTCONN<span class="token punctuation">;</span>
    
    <span class="token comment">// 检查中断标志的有效性</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_SHARED<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>dev_id<span class="token punctuation">)</span> 
            <span class="token operator">||</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_SHARED<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_COND_SUSPEND<span class="token punctuation">)</span><span class="token punctuation">)</span> 
            <span class="token operator">||</span><span class="token punctuation">(</span><span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_NO_SUSPEND<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_COND_SUSPEND<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    
    <span class="token comment">// 根据中断号获取中断描述符</span>
    desc <span class="token operator">=</span> <span class="token function">irq_to_desc</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>desc<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    
    <span class="token comment">// 检查中断设置是否可以进行中断请求，以及是否为每个CPU 分配唯一设备ID</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">irq_settings_can_request</span><span class="token punctuation">(</span>desc<span class="token punctuation">)</span> <span class="token operator">||</span><span class="token function">WARN_ON</span><span class="token punctuation">(</span><span class="token function">irq_settings_is_per_cpu_devid</span><span class="token punctuation">(</span>desc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    
    <span class="token comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>thread_fn<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
        handler <span class="token operator">=</span> irq_default_primary_handler<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 分配并初始化中断动作数据结构</span>
    action <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irqaction</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>action<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
    
    action<span class="token operator">-&gt;</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span> <span class="token comment">// 中断处理函数</span>
    action<span class="token operator">-&gt;</span>thread_fn <span class="token operator">=</span> thread_fn<span class="token punctuation">;</span> <span class="token comment">// 线程处理函数</span>
    action<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> irqflags<span class="token punctuation">;</span> <span class="token comment">// 中断标志</span>
    action<span class="token operator">-&gt;</span>name <span class="token operator">=</span> devname<span class="token punctuation">;</span> <span class="token comment">// 设备名称</span>
    action<span class="token operator">-&gt;</span>dev_id <span class="token operator">=</span> dev_id<span class="token punctuation">;</span> <span class="token comment">// 设备ID</span>
    
    <span class="token comment">// 获取中断的电源管理引用计数</span>
    retval <span class="token operator">=</span> <span class="token function">irq_chip_pm_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>desc<span class="token operator">-&gt;</span>irq_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">kfree</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 设置中断并将中断动作与中断描述符关联</span>
    retval <span class="token operator">=</span> <span class="token function">__setup_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 处理中断设置失败的情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">irq_chip_pm_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>desc<span class="token operator">-&gt;</span>irq_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kfree</span><span class="token punctuation">(</span>action<span class="token operator">-&gt;</span>secondary<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kfree</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_SHIRQ_FIXME</span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>retval <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_SHARED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
        <span class="token function">disable_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">handler</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">enable_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">return</span> retval<span class="token punctuation">;</span> <span class="token comment">// 返回设置中断的结果</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>（1）声明变量和初始化：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>action<span class="token punctuation">;</span> <span class="token comment">// 中断动作结构体指针</span>
<span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token operator">*</span>desc<span class="token punctuation">;</span> <span class="token comment">// 中断描述符指针</span>
<span class="token keyword">int</span> retval<span class="token punctuation">;</span> <span class="token comment">// 返回值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>第5 行：用于存储中断动作结构体的指针（会在下面的小节进行详细的讲解）。<br>第6 行：用于存储中断描述符的指针（会在下面的小节进行详细的讲解）。<br>第7 行：用于存储函数的返回值。</p>
<p><strong>（2）参数检查：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 检查中断号是否为未连接状态</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>irq <span class="token operator">==</span> IRQ_NOTCONNECTED<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">-</span>ENOTCONN<span class="token punctuation">;</span>

<span class="token comment">// 检查中断标志的有效性</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_SHARED<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>dev_id<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_SHARED<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_COND_SUSPEND<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_NO_SUSPEND<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_COND_SUSPEND<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第10 行：检查中断号是否为未连接状态（<code>IRQ_NOTCONNECTED</code>）。<br>第14-17 行：检查中断标志的有效性，包括共享标志与设备ID 的关联性，条件挂起标志的有效性，以及无挂起标志与条件挂起标志的关联性。</p>
<p><strong>（3）获取中断描述符：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 根据中断号获取中断描述符</span>
desc <span class="token operator">=</span> <span class="token function">irq_to_desc</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>desc<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>第20 行：根据中断号调用irq_to_desc 函数获取对应的中断描述符。<br>第21 行：如果获取中断描述符失败，则返回-EINVAL 表示无效的参数。</p>
<p><strong>（4）检查中断设置：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 检查中断设置是否可以进行中断请求，以及是否为每个CPU 分配唯一设备ID</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">irq_settings_can_request</span><span class="token punctuation">(</span>desc<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token function">WARN_ON</span><span class="token punctuation">(</span><span class="token function">irq_settings_is_per_cpu_devid</span><span class="token punctuation">(</span>desc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>第25-26 行：检查中断设置是否可以进行中断请求，以及是否为每个CPU 分配唯一设备ID。如果中断设置不满足要求，则返回-EINVAL 表示无效的参数。<br><strong>（5）处理中断处理函数和线程处理函数：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>thread_fn<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    handler <span class="token operator">=</span> irq_default_primary_handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果未指定中断处理函数，则将默认的主处理函数（<code>irq_default_primary_handler</code>）赋值给<code>handler</code>。</p>
<p><strong>（6）分配并初始化中断动作数据结构：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 分配并初始化中断动作数据结构</span>
action <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irqaction</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>action<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
action<span class="token operator">-&gt;</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span> <span class="token comment">// 中断处理函数</span>
action<span class="token operator">-&gt;</span>thread_fn <span class="token operator">=</span> thread_fn<span class="token punctuation">;</span> <span class="token comment">// 线程处理函数</span>
action<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> irqflags<span class="token punctuation">;</span> <span class="token comment">// 中断标志</span>
action<span class="token operator">-&gt;</span>name <span class="token operator">=</span> devname<span class="token punctuation">;</span> <span class="token comment">// 设备名称</span>
action<span class="token operator">-&gt;</span>dev_id <span class="token operator">=</span> dev_id<span class="token punctuation">;</span> <span class="token comment">// 设备ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第37 行：调用kzalloc 函数分配内存空间，大小为sizeof(struct irqaction)。<br>第38 行：如果分配内存失败，则返回-ENOMEM 表示内存不足。<br>第41 行-第45 行：将中断处理函数、线程处理函数、中断标志、设备名称和设备ID 赋值给相应的字段。</p>
<p><strong>（7）获取中断的电源管理引用计数：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 获取中断的电源管理引用计数</span>
retval <span class="token operator">=</span> <span class="token function">irq_chip_pm_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>desc<span class="token operator">-&gt;</span>irq_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">kfree</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第48 行：调用irq_chip_pm_get 函数获取中断的电源管理引用计数。<br>第49 行：如果获取失败，则释放先前分配的内存空间，并返回获取失败的结果。</p>
<p><strong>（8）设置中断并关联中断动作：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 设置中断并将中断动作与中断描述符关联</span>
retval <span class="token operator">=</span> <span class="token function">__setup_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>第55 行：调用__setup_irq 函数设置中断并将中断动作与中断描述符关联。</p>
<p><strong>（9）处理设置中断失败的情况：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 处理中断设置失败的情况</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">irq_chip_pm_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>desc<span class="token operator">-&gt;</span>irq_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">kfree</span><span class="token punctuation">(</span>action<span class="token operator">-&gt;</span>secondary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">kfree</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第59 行：调用irq_chip_pm_put 函数释放中断的电源管理引用计数。<br>第60 行：释放次要中断动作的内存空间。<br>第61 行：释放中断动作的内存空间。</p>
<p><strong>（10）可选的共享中断处理：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DEBUG_SHIRQ_FIXME</span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>retval <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>irqflags <span class="token operator">&amp;</span> IRQF_SHARED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
        
        <span class="token function">disable_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token function">handler</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">enable_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第65 行：如果设置中断成功且中断标志中包含共享标志（IRQF_SHARED），则执行以下操作：<br>第68 行：禁用中断。<br>第69 行：保存当前中断状态并禁用本地中断。<br>第70 行：调用主处理函数处理中断。<br>第73 行：恢复中断状态。<br>第74 行）：重新使能中断。</p>
<h3 id="40-3-irq-desc-结构体"><a href="#40-3-irq-desc-结构体" class="headerlink" title="40.3 irq_desc 结构体"></a>40.3 irq_desc 结构体</h3><p>irq_desc 结构体是Linux 内核中用于描述中断的数据结构之一。每个硬件中断都有一个对应的irq_desc 实例，它用于记录与该中断相关的各种信息和状态。该结构体的主要功能是管理中断处理函数、中断行为以及与中断处理相关的其他数据。</p>
<p>以下是irq_desc 结构体的主要作用和功能：</p>
<ul>
<li>（1）<strong>中断处理函数管理</strong>：irq_desc 结构体中的handle_irq 字段保存中断处理函数的指针。当硬件触发中断时，内核会调用该函数来处理中断事件。</li>
<li>（2）<strong>中断行为管理</strong>：irq_desc 结构体中的action 字段是一个指向中断行为列表的指针。中断行为是一组回调函数，用于注册、注销和处理与中断相关的事件。</li>
<li>（3）<strong>中断统计信息</strong>：irq_desc 结构体中的kstat_irqs 字段是一个指向中断统计信息的指针。该信息用于记录中断事件的发生次数和处理情况，可以帮助分析中断的性能和行为。</li>
<li>（4）<strong>中断数据管理</strong>：irq_desc 结构体中的irq_data 字段保存了与中断相关的数据，如中断号、中断类型等。这些数据用于识别和管理中断。</li>
<li>（5）<strong>通用中断数据管理</strong>：irq_desc 结构体中的irq_common_data 字段保存了与中断处理相关的通用数据，如中断控制器、中断屏蔽等。这些数据用于处理和控制中断的行为。</li>
<li>（6）<strong>中断状态管理</strong>：irq_desc 结构体中的其他字段用于管理中断的状态，如嵌套中断禁用计数、唤醒使能计数等。这些状态信息帮助内核跟踪和管理中断的状态变化。</li>
</ul>
<p>通过使用irq_desc 结构体，内核可以有效地管理和处理系统中的硬件中断。它提供了一个统一的接口，用于注册和处理中断处理函数、管理中断行为，并提供了必要的信息和数据结构来监视和控制中断的行为和状态。</p>
<p>irq_desc 结构体定义在内核源码目录的“<code>include/linux/irqdesc.h</code>”文件，具体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">irq_common_data</span> irq_common_data<span class="token punctuation">;</span> 				<span class="token comment">/* 通用中断数据*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">irq_data</span> irq_data<span class="token punctuation">;</span> 								<span class="token comment">/* 中断数据*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __percpu <span class="token operator">*</span>kstat_irqs<span class="token punctuation">;</span> 						<span class="token comment">/* 中断统计信息*/</span>
    <span class="token class-name">irq_flow_handler_t</span> handle_irq<span class="token punctuation">;</span> 							<span class="token comment">/* 中断处理函数*/</span>
    
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_IRQ_PREFLOW_FASTEOI</span></span>
    	<span class="token class-name">irq_preflow_handler_t</span> preflow_handler<span class="token punctuation">;</span> 				<span class="token comment">/* 预处理中断处理函数*/</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>action<span class="token punctuation">;</span> 								<span class="token comment">/* IRQ action list */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> status_use_accessors<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> core_internal_state__do_not_mess_with_it<span class="token punctuation">;</span> 	  <span class="token comment">/* 内核内部状态标志位，请勿修改*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> depth<span class="token punctuation">;</span> 									<span class="token comment">/* 嵌套中断禁用计数*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> wake_depth<span class="token punctuation">;</span> <span class="token comment">/* 嵌套唤醒使能计数*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> tot_count<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq_count<span class="token punctuation">;</span> <span class="token comment">/* 用于检测损坏的IRQ 计数*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> last_unhandled<span class="token punctuation">;</span> <span class="token comment">/* 未处理计数的老化计时器*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> irqs_unhandled<span class="token punctuation">;</span> <span class="token comment">/* 未处理的中断计数*/</span>
    <span class="token class-name">atomic_t</span> threads_handled<span class="token punctuation">;</span> <span class="token comment">/* 处理中断的线程计数*/</span>
    <span class="token keyword">int</span> threads_handled_last<span class="token punctuation">;</span>
    <span class="token class-name">raw_spinlock_t</span> lock<span class="token punctuation">;</span> <span class="token comment">/* 自旋锁*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">cpumask</span> <span class="token operator">*</span>percpu_enabled<span class="token punctuation">;</span> <span class="token comment">/* 指向每个CPU 的使能掩码*/</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cpumask</span> <span class="token operator">*</span>percpu_affinity<span class="token punctuation">;</span> <span class="token comment">/* 指向每个CPU 亲和性掩码*/</span>
    
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SMP</span></span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cpumask</span> <span class="token operator">*</span>affinity_hint<span class="token punctuation">;</span> <span class="token comment">/* CPU 亲和性提示*/</span>
        <span class="token keyword">struct</span> <span class="token class-name">irq_affinity_notify</span> <span class="token operator">*</span>affinity_notify<span class="token punctuation">;</span> <span class="token comment">/* CPU 亲和性变化通知*/</span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_GENERIC_PENDING_IRQ</span></span>
            <span class="token class-name">cpumask_var_t</span> pending_mask<span class="token punctuation">;</span> <span class="token comment">/* 等待处理的中断掩码*/</span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> threads_oneshot<span class="token punctuation">;</span>
    <span class="token class-name">atomic_t</span> threads_active<span class="token punctuation">;</span> <span class="token comment">/* 活动中的线程计数*/</span>
    <span class="token class-name">wait_queue_head_t</span> wait_for_threads<span class="token punctuation">;</span> <span class="token comment">/* 等待线程的等待队列头*/</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_PM_SLEEP</span></span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_actions<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> no_suspend_depth<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cond_suspend_depth<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> force_resume_depth<span class="token punctuation">;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_PROC_FS</span></span>
        <span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span> <span class="token operator">*</span>dir<span class="token punctuation">;</span> <span class="token comment">/* proc 文件系统目录项*/</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_GENERIC_IRQ_DEBUGFS</span></span>
        <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>debugfs_file<span class="token punctuation">;</span> <span class="token comment">/* 调试文件系统文件*/</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev_name<span class="token punctuation">;</span> <span class="token comment">/* 设备名称*/</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SPARSE_IRQ</span></span>
        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">kobject</span> kobj<span class="token punctuation">;</span> <span class="token comment">/* 内核对象*/</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">mutex</span> request_mutex<span class="token punctuation">;</span> <span class="token comment">/* 请求互斥锁*/</span>
    <span class="token keyword">int</span> parent_irq<span class="token punctuation">;</span> <span class="token comment">/* 父中断号*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span> <span class="token comment">/* 模块拥有者*/</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">/* 中断名称*/</span>
<span class="token punctuation">}</span> ____cacheline_internodealigned_in_smp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在irq_desc 结构体中最重要的就是action 字段，会在下个小节对action 字段进行详细的讲解。</p>
<h3 id="40-4-irqaction-结构体"><a href="#40-4-irqaction-结构体" class="headerlink" title="40.4 irqaction 结构体"></a>40.4 irqaction 结构体</h3><p>irqaction 结构体是Linux 内核中用于描述中断行为的数据结构之一。它用于定义中断处理过程中的回调函数和相关属性。irqaction 结构体的主要功能是管理与特定中断相关的行为和处理函数。</p>
<p>以下是irqaction 结构体的主要作用和功能：</p>
<ul>
<li>（1）<strong>中断处理函数管理</strong>：irqaction 结构体中的handler 字段保存中断处理函数的指针。该函数在中断发生时被调用，用于处理中断事件。</li>
<li>（2）<strong>中断处理标志管理</strong>：irqaction 结构体中的flags 字段用于指定中断处理的各种属性和标志。这些标志控制中断处理的行为，例如触发方式、中断类型等。</li>
<li>（3）<strong>设备标识符管理</strong>：irqaction 结构体中的dev_id 字段用于保存与中断处理相关的设备标识符。它可以是指向设备结构体或其他与设备相关的数据的指针，用于将中断处理与特定设备关联起来。</li>
<li>（4）<strong>中断行为链表管理</strong>：irqaction 结构体中的next 字段是一个指向下一个irqaction 结构体的指针，用于构建中断行为的链表。这样可以将多个中断处理函数链接在一起，以便在中断发生时按顺序调用它们。</li>
</ul>
<p>通过使用irqaction 结构体，内核可以灵活地定义和管理与特定中断相关的行为和处理函数。它提供了一个统一的接口，用于注册和注销中断处理函数，并提供了必要的属性和数据结构来控制中断处理的行为和顺序。</p>
<p>irqaction 体定义在内核源码的“<code>include/linux/interrupt.h</code>”文件中如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token punctuation">{</span>
    <span class="token class-name">irq_handler_t</span> handler<span class="token punctuation">;</span> <span class="token comment">// 中断处理函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">;</span> <span class="token comment">// 设备ID</span>
    <span class="token keyword">void</span> __percpu <span class="token operator">*</span>percpu_dev_id<span class="token punctuation">;</span> <span class="token comment">// 每个CPU 的设备ID</span>
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 下一个中断动作结构体</span>
    <span class="token class-name">irq_handler_t</span> thread_fn<span class="token punctuation">;</span> <span class="token comment">// 线程处理函数</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>thread<span class="token punctuation">;</span> <span class="token comment">// 线程结构体指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>secondary<span class="token punctuation">;</span> <span class="token comment">// 次要中断动作结构体</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">;</span> <span class="token comment">// 中断号</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">;</span> <span class="token comment">// 中断标志</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> thread_flags<span class="token punctuation">;</span> <span class="token comment">// 线程标志</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> thread_mask<span class="token punctuation">;</span> <span class="token comment">// 线程掩码</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">// 设备名称</span>
    <span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span> <span class="token operator">*</span>dir<span class="token punctuation">;</span> <span class="token comment">// proc 文件系统目录项指针</span>
<span class="token punctuation">}</span> ____cacheline_internodealigned_in_smp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="第41-章中断下文tasklet-实验"><a href="#第41-章中断下文tasklet-实验" class="headerlink" title="第41 章中断下文tasklet 实验"></a>第41 章中断下文tasklet 实验</h2><p>在上一个章节中，我们申请GPIO 中断，使用的是request_irq,但是request_irq 绑定的中断服务程序指的是中断上文。在之前的中断视频中讲解了：中断分为俩个部分——中断上文和中断下文。本章节我们来学习中断下文的一种实现方式——<code>tasklet</code>。</p>
<h3 id="41-1-什么是tasklet"><a href="#41-1-什么是tasklet" class="headerlink" title="41.1 什么是tasklet"></a>41.1 什么是tasklet</h3><p>在Linux 内核中，**<code>tasklet</code> 是一种特殊的软中断机制，被广泛用于处理中断下文相关的任务。<strong>它是一种常见且有效的方法，在多核处理系统上可以避免并发问题。</strong><code>Tasklet</code> 绑定的函数在同一时间只能在一个CPU 上运行，因此不会出现并发冲突<strong>。然而，需要注意的是，</strong><code>tasklet</code> 绑定的函数中不能调用可能导致休眠的函数，否则可能引起内核异常。**</p>
<p>在Linux 内核中，tasklet 结构体的定义位于<code>include/linux/interrupt.h</code> 头文件中。其原型如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> state<span class="token punctuation">;</span>
    <span class="token class-name">atomic_t</span> count<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token class-name">tasklet_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>tasklet_struct</code> 结构体包含以下成员：</p>
<ul>
<li>next:指向下一个tasklet 的指针，用于形成链表结构，以便内核中可以同时管理多个tasklet。</li>
<li>state:表示tasklet 的当前状态。</li>
<li>count:用于引用计数，用于确保tasklet 在多个地方调度或取消调度时的正确处理。</li>
<li>func:指向tasklet 绑定的函数的指针，该函数将在tasklet 执行时被调用。</li>
<li>data:传递给tasklet 绑定函数的参数</li>
</ul>
<p>此外，为了方便，还定义了<code>tasklet_t</code> 类型作为<code>struct tasklet_struct</code> 的别名。这样我们可以使用<code>tasklet_t</code> 来声明<code>tasklet</code> 变量，而不是直接使用<code>struct tasklet_struct</code>。</p>
<h3 id="41-2-tasklet-相关接口函数"><a href="#41-2-tasklet-相关接口函数" class="headerlink" title="41.2 tasklet 相关接口函数"></a>41.2 tasklet 相关接口函数</h3><h4 id="41-2-1-静态初始化函数"><a href="#41-2-1-静态初始化函数" class="headerlink" title="41.2.1 静态初始化函数"></a>41.2.1 静态初始化函数</h4><p>在Linux 内核中，有一个用于静态初始化<code>tasklet</code> 的宏函数：<code>DECLARE_TASKLET</code>。这个宏函数可以帮助我们更方便地进行tasklet 的静态初始化。<br>宏函数的原型如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DECLARE_TASKLET</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span>func<span class="token punctuation">,</span>data<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> name <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>func<span class="token punctuation">,</span>data<span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>其中，name 是tasklet 的名称，func 是tasklet 的处理函数，data 是传递给处理函数的参数。初始化状态为使能状态。</p>
<p>如果tasklet 初始化函数为非使能状态，使用以下宏定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DECLARE_TASKLET_DISABLED</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span>func<span class="token punctuation">,</span>data<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> name <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>func<span class="token punctuation">,</span>data<span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>其中，name 是tasklet 的名称，func 是tasklet 的处理函数，data 是传递给处理函数的参数。初始化状态为非使能状态。<br>下面是一个示例，展示了如何使用<code>DECLARE_TASKLET</code> 宏函数进行tasklet 的静态初始化：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token comment">// 定义tasklet 处理函数</span>
<span class="token keyword">void</span> <span class="token function">my_tasklet_handler</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Tasklet 处理逻辑</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 静态初始化tasklet</span>
<span class="token function">DECLARE_TASKLET</span><span class="token punctuation">(</span>my_tasklet<span class="token punctuation">,</span> my_tasklet_handler<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 驱动程序的其他代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述示例中，<code>my_tasklet</code> 是<code>tasklet</code> 的名称，<code>my_tasklet_handler</code> 是<code>tasklet</code> 的处理函数，0是传递给处理函数的参数。但是需要注意的是，使用DECLARE_TASKLET 静态初始化的tasklet无法在运行时动态销毁，因此在不需要tasklet 时，应该避免使用此方法。如果需要在运行时销毁tasklet，应使用<code>tasklet_init</code> 和<code>tasklet_kill</code> 函数进行动态初始化和销毁，接下来我们来学习动态初始化函数。</p>
<h4 id="41-2-2-动态初始化函数tasklet-init"><a href="#41-2-2-动态初始化函数tasklet-init" class="headerlink" title="41.2.2 动态初始化函数tasklet_init"></a>41.2.2 动态初始化函数<code>tasklet_init</code></h4><p>在Linux 内核中，可以使用tasklet_init 函数对tasklet 进行动态初始化。该函数原型为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tasklet_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中，t 是指向tasklet 结构体的指针，func 是tasklet 的处理函数，data 是传递给处理函数的参数</p>
<p>以下是一个示例，tasklet_init 函数进行动态初始化如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token comment">// 定义tasklet 处理函数</span>
<span class="token keyword">void</span> <span class="token function">my_tasklet_handler</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Tasklet 处理逻辑</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 声明tasklet 结构体</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> my_tasklet<span class="token punctuation">;</span>

<span class="token comment">// 初始化tasklet</span>
<span class="token function">tasklet_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_tasklet<span class="token punctuation">,</span> my_tasklet_handler<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 驱动程序的其他代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在示例中，我们首先定义了<code>my_tasklet_handler</code> 作为<code>tasklet</code> 的处理函数。然后，声明了一个名为<code>my_tasklet</code> 的<code>tasklet</code> 结构体。接下来，通过调用<code>tasklet_init</code> 函数，进行动态初始化。</p>
<p>通过使用<code>tasklet_init</code> 函数，我们可以在运行时动态创建和初始化tasklet。这样，我们可以根据需要灵活地管理和控制tasklet 的生命周期。在不再需要tasklet 时，可以使用<code>tasklet_kill</code>函数进行销毁，以释放相关资源。</p>
<h4 id="41-2-3-关闭函数tasklet-disabled"><a href="#41-2-3-关闭函数tasklet-disabled" class="headerlink" title="41.2.3 关闭函数tasklet_disabled"></a>41.2.3 关闭函数<code>tasklet_disabled</code></h4><p>在Linux 内核中，可以使用tasklet_disabled 函数来关闭一个已经初始化的tasklet。该函数的原型如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tasklet_disable</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中，t 是指向tasklet 结构体的指针。<br>以下是一个示例，使用<code>tasklet_disable</code> 函数来关闭tasklet。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token comment">// 定义tasklet 处理函数</span>
<span class="token keyword">void</span> <span class="token function">my_tasklet_handler</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Tasklet 处理逻辑</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token comment">// 声明tasklet 结构体</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> my_tasklet<span class="token punctuation">;</span>

<span class="token comment">// 初始化tasklet</span>
<span class="token function">tasklet_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_tasklet<span class="token punctuation">,</span> my_tasklet_handler<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 关闭tasklet</span>
<span class="token function">tasklet_disable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_tasklet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 驱动程序的其他代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述示例中，我们首先定义了my_tasklet_handler 作为tasklet 的处理函数。然后，声明了一个名为my_tasklet 的tasklet 结构体，并使用tasklet_init 函数对其进行初始化。最后，通过调用<code>tasklet_disable</code> 函数，我们关闭了my_tasklet。</p>
<p>关闭tasklet 后，即使调用<code>tasklet_schedule</code> 函数触发tasklet，tasklet 的处理函数也不会再被执行。这可以用于临时暂停或停止tasklet 的执行，直到再次启用（通过调用<code>tasklet_enable</code>函数）。</p>
<p>需要注意的是， <strong>关闭<code>tasklet</code> 并不会销毁<code>tasklet</code> 结构体， 因此可以随时通过调用<code>tasklet_enable</code> 函数重新启用<code>tasklet</code>，或者调用<code>tasklet_kill</code> 函数来销毁<code>tasklet</code>。</strong></p>
<h4 id="41-2-4-使能函数"><a href="#41-2-4-使能函数" class="headerlink" title="41.2.4 使能函数"></a>41.2.4 使能函数</h4><p>在Linux 内核中，可以使用<code>tasklet_enable</code> 函数来使能（启用）一个已经初始化的tasklet。该函数的原型如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tasklet_enable</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中，t 是指向tasklet 结构体的指针。<br>以下是一个示例，展示如何使用tasklet_enable 函数来使能tasklet：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token comment">// 定义tasklet 处理函数</span>
<span class="token keyword">void</span> <span class="token function">my_tasklet_handler</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token comment">// Tasklet 处理逻辑</span>
<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token comment">// 声明tasklet 结构体</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> my_tasklet<span class="token punctuation">;</span>
<span class="token comment">// 初始化tasklet</span>
<span class="token function">tasklet_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_tasklet<span class="token punctuation">,</span> my_tasklet_handler<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使能tasklet</span>
<span class="token function">tasklet_enable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_tasklet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 驱动程序的其他代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述示例中，我们首先定义了<code>my_tasklet_handler</code> 作为tasklet 的处理函数。然后，声明了一个名为my_tasklet 的tasklet 结构体，并使用tasklet_init 函数对其进行初始化。最后，通过调用tasklet_enable 函数，我们使能（启用）了my_tasklet。</p>
<p>使能tasklet 后，如果调用tasklet_schedule 函数触发tasklet，则tasklet 的处理函数将会被执行。这样，tasklet 将开始按计划执行其处理逻辑。</p>
<p>需要注意的是，<strong>使能tasklet 并不会自动触发tasklet 的执行，而是通过调用tasklet_schedule函数来触发</strong>。同时，可以使用<code>tasklet_disable</code> 函数来临时暂停或停止tasklet 的执行。<strong>如果需要永久停止tasklet 的执行并释放相关资源，则应调用<code>tasklet_kill</code> 函数来销毁tasklet。</strong></p>
<h4 id="41-2-5-调度函数tasklet-schedule"><a href="#41-2-5-调度函数tasklet-schedule" class="headerlink" title="41.2.5 调度函数tasklet_schedule"></a>41.2.5 调度函数<code>tasklet_schedule</code></h4><p>在Linux 内核中，可以使用<code>tasklet_schedule</code> 函数来调度（触发）一个已经初始化的tasklet执行。该函数的原型如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tasklet_schedule</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中，t 是指向tasklet 结构体的指针。<br>以下是一个示例，展示如何使用<code>tasklet_schedule</code> 函数来调度tasklet 执行：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token comment">// 定义tasklet 处理函数</span>
<span class="token keyword">void</span> <span class="token function">my_tasklet_handler</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Tasklet 处理逻辑</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token comment">// 声明tasklet 结构体</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> my_tasklet<span class="token punctuation">;</span>

<span class="token comment">// 初始化tasklet</span>
<span class="token function">tasklet_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_tasklet<span class="token punctuation">,</span> my_tasklet_handler<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 调度tasklet 执行</span>
<span class="token function">tasklet_schedule</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_tasklet<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 驱动程序的其他代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述示例中，我们首先定义了my_tasklet_handler 作为tasklet 的处理函数。然后，声明了一个名为my_tasklet 的tasklet 结构体，并使用tasklet_init 函数对其进行初始化。最后，通过调用<code>tasklet_schedule</code> 函数，我们调度（触发）了my_tasklet 的执行。<br>需要注意的是，调度tasklet 只是将tasklet 标记为需要执行，并不会立即执行tasklet 的处理函数。实际的执行时间取决于内核的调度和处理机制。</p>
<h4 id="41-2-6-销毁函数tasklet-kill"><a href="#41-2-6-销毁函数tasklet-kill" class="headerlink" title="41.2.6 销毁函数tasklet_kill"></a>41.2.6 销毁函数<code>tasklet_kill</code></h4><p>在Linux 内核中，可以使用tasklet_kill 函数来销毁一个已经初始化的tasklet，释放相关资源。该函数的原型如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tasklet_kill</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中，t 是指向tasklet 结构体的指针。<br>以下是一个示例，展示如何使用tasklet_kill 函数来销毁tasklet：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token comment">// 定义tasklet 处理函数</span>
<span class="token keyword">void</span> <span class="token function">my_tasklet_handler</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Tasklet 处理逻辑</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token comment">// 声明tasklet 结构体</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> my_tasklet<span class="token punctuation">;</span>

<span class="token comment">// 初始化tasklet</span>
<span class="token function">tasklet_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_tasklet<span class="token punctuation">,</span> my_tasklet_handler<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">tasklet_disable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_tasklet<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 销毁tasklet</span>
<span class="token function">tasklet_kill</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_tasklet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 驱动程序的其他代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述示例中，我们首先定义了my_tasklet_handler 作为tasklet 的处理函数。然后，声明了一个名为my_tasklet 的tasklet 结构体，并使用tasklet_init 函数对其进行初始化。最后，通过调用tasklet_kill 函数，我们销毁了my_tasklet。</p>
<p>调用tasklet_kill 函数会释放tasklet 所占用的资源，并将tasklet 标记为无效。因此，销毁后的tasklet 不能再被使用。</p>
<p>需要注意的是， 在销毁tasklet 之前， 应该确保该tasklet 已经被停止（ 通过调用tasklet_disable 函数）。否则，销毁一个正在执行的tasklet 可能导致内核崩溃或其他错误。</p>
<p>一旦销毁了tasklet，如果需要再次使用tasklet，需要重新进行初始化（通过调用tasklet_init函数）。在下一小节中我们将使用上述tasklet 函数相关接口函数进行相应的实验。</p>
<h3 id="41-3-实验程序的编写"><a href="#41-3-实验程序的编写" class="headerlink" title="41.3 实验程序的编写"></a>41.3 实验程序的编写</h3><h4 id="41-3-1-驱动程序编写"><a href="#41-3-1-驱动程序编写" class="headerlink" title="41.3.1 驱动程序编写"></a>41.3.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\32_tasklet\module</code>。<br>本实验将实现注册显示屏触摸中断，每按当触摸LCD 显示屏就会触发中断服务函数，在中断服务函数中调度中断下文tasklet 处理函数，打印“<code>This id test_interrupt</code>”和“<code>data is 1</code>”。</p>
<p>在驱动程序中的模块初始化函数中，我们将<code>GPIO</code> 转换为中断号，并使用<code>request_irq</code> 函数请求中断，然后对tasklet 进行初始化。在中断处理函数中，我们调度tasklet 执行，使得当中断触发时，tasklet 会被调度执行。在模块退出函数中，我们释放中断资源，并使能tasklet 销毁tasklet。</p>
<p>编写完成的interrupt.c 代码如下所示，添加的代码已加粗表示。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/gpio.h&gt;</span></span>
<span class="token comment">// #include &lt;linux/delay.h&gt;</span>

<span class="token keyword">int</span> irq<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> mytasklet<span class="token punctuation">;</span>

<span class="token comment">// 定义tasklet处理函数</span>
<span class="token keyword">void</span> <span class="token function">mytasklet_func</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"data is %ld\n"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// msleep(3000);</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中断处理函数</span>
<span class="token class-name">irqreturn_t</span> <span class="token function">test_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_interrupt\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">tasklet_schedule</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mytasklet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调度tasklet执行</span>
  <span class="token keyword">return</span> <span class="token function">IRQ_RETVAL</span><span class="token punctuation">(</span>IRQ_HANDLED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 模块初始化函数</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">interrupt_irq_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
  irq <span class="token operator">=</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将GPIO转换为中断号</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"irq is %d\n"</span><span class="token punctuation">,</span> irq<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 请求中断</span>
  ret <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> test_interrupt<span class="token punctuation">,</span> IRQF_TRIGGER_RISING<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"request_irq is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 初始化tasklet</span>
  <span class="token function">tasklet_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mytasklet<span class="token punctuation">,</span> mytasklet_func<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 模块退出函数</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">interrupt_irq_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">free_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">tasklet_enable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mytasklet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使能tasklet（可选）</span>
  <span class="token function">tasklet_kill</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mytasklet<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 销毁tasklet</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"bye bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>interrupt_irq_init<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指定模块的初始化函数</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>interrupt_irq_exit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指定模块的退出函数</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 模块使用的许可证</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模块的作者</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="41-4-运行测试"><a href="#41-4-运行测试" class="headerlink" title="41.4 运行测试"></a>41.4 运行测试</h3><h4 id="41-4-1-编译驱动程序"><a href="#41-4-1-编译驱动程序" class="headerlink" title="41.4.1 编译驱动程序"></a>41.4.1 编译驱动程序</h4><p>在上一小节中的interrupt.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成interrupt.ko 目标文件，至此驱动模块就编译成功了。</p>
<h4 id="41-4-2-运行测试"><a href="#41-4-2-运行测试" class="headerlink" title="41.4.2 运行测试"></a>41.4.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图41-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod interrupt.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201402523.png" alt="image-20240820140224352"></p>
<p>看到驱动加载之后，可以看到申请的中断号（113）被打印了出来，然后用手触摸连接的LVDS 7 寸屏幕，触发中断服务程序，打印如下图（41-5）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201402537.png" alt="image-20240820140244384" style="zoom: 67%;">

<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和tasklet 处理函数中添加的打印“data is 1”，说明成功执行了中断下文tasklet 处理函数。<br>最后可以使用以下命令进行驱动的卸载，如下图（图图41-6）所示：</p>
<pre class="line-numbers language-none"><code class="language-none">rmmod interrupt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201403000.png" alt="image-20240820140326878" style="zoom:67%;">

<p>之前的理论章节我们强调说tasklet 函数中不能调用休眠的函数，在此我们在上述驱动实验的基础上实验一下，驱动文件中添加休眠函数，如下（图41-7）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201403726.png" alt="image-20240820140347597"></p>
<p>同理，进行编译驱动模块，卸载掉之前的驱动模块后，加载新编译的驱动模块，如下图（图41-8）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201404061.png" alt="image-20240820140400935"></p>
<p>然后用手触摸连接的LVDS 7 寸屏幕，打印如下图（41-9）所示，内核会崩溃。</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201404570.png" alt="image-20240820140428385" style="zoom:80%;">

<p>至此，中断下文tasklet 实验就完成了。</p>
<h2 id="第42-章软中断实验"><a href="#第42-章软中断实验" class="headerlink" title="第42 章软中断实验"></a>第42 章软中断实验</h2><p>在上个章节我们学习了中断下文的一种实验方式——tasklet，本章节我们来学习中断下文的另一种实现方式——软中断。软中断的资料有限，对应的中断号不多，一般用在网络设备驱动，块设备驱动当中。这时本章节要学习的软中断就闪耀登场了。</p>
<h3 id="42-1-什么是软中断"><a href="#42-1-什么是软中断" class="headerlink" title="42.1 什么是软中断"></a>42.1 什么是软中断</h3><p>打开<code>Linux 源码linux_sdk/kernel/include/linux/interrupt.h</code> 文件，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span>
<span class="token punctuation">{</span>
    HI_SOFTIRQ<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>
    TIMER_SOFTIRQ<span class="token punctuation">,</span>
    NET_TX_SOFTIRQ<span class="token punctuation">,</span>
    NET_RX_SOFTIRQ<span class="token punctuation">,</span>
    BLOCK_SOFTIRQ<span class="token punctuation">,</span>
    IRQ_POLL_SOFTIRQ<span class="token punctuation">,</span>
    TASKLET_SOFTIRQ<span class="token punctuation">,</span>
    SCHED_SOFTIRQ<span class="token punctuation">,</span>
    HRTIMER_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* Unused, but kept as tools rely on the numbering. Sigh! */</span>
    RCU_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* Preferable RCU should always be the last softirq */</span>
    NR_SOFTIRQS
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上代码定义了一个枚举类型，用于标识软中断的不同类型或优先级。每个枚举常量对应一个特定的软中断类型。<br>以下是每个枚举常量的含义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">HI_SOFTIRQ：高优先级软中断
TIMER_SOFTIRQ：定时器软中断
NET_TX_SOFTIRQ：网络传输发送软中断
NET_RX_SOFTIRQ：网络传输接收软中断
BLOCK_SOFTIRQ：块设备软中断
IRQ_POLL_SOFTIRQ：中断轮询软中断
TASKLET_SOFTIRQ：任务软中断
SCHED_SOFTIRQ：调度软中断
HRTIMER_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* Unused, but kept as tools rely on the numbering. Sigh! */</span>
RCU_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* Preferable RCU should always be the last softirq */</span>
NR_SOFTIRQS：表示软中断的总数，用于指示软中断类型的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>中断号的优先级越小，代表优先级越高。在驱动代码中，我们可以使用Linux 驱动代码中上述的软中断，当然我们也可以自己添加软中断。我们添加一个自定义的软中断，如下所示，TEST_SOFTIRQ 为自定义添加的软中断。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span>
<span class="token punctuation">{</span>
HI_SOFTIRQ<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>
TIMER_SOFTIRQ<span class="token punctuation">,</span>
NET_TX_SOFTIRQ<span class="token punctuation">,</span>
NET_RX_SOFTIRQ<span class="token punctuation">,</span>
BLOCK_SOFTIRQ<span class="token punctuation">,</span>
IRQ_POLL_SOFTIRQ<span class="token punctuation">,</span>
TASKLET_SOFTIRQ<span class="token punctuation">,</span>
SCHED_SOFTIRQ<span class="token punctuation">,</span>
HRTIMER_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* Unused, but kept as tools rely on the
numbering. Sigh! */</span>
RCU_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* Preferable RCU should always be the last softirq */</span>
TEST_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">//添加的自定义软中断</span>
NR_SOFTIRQS
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里要注意：<strong>尽管我们添加一个自定义的软中断非常简单，但是Linux 内核的开发者并不希望我们这样去做，如果我们要用软中断，建议使用tasklet</strong>。虽然Linux 内核开发者不建议自定义软中断，但是我们抱着学习的态度，了解学习下软中断还是很有必要的。<strong>上述修改之后，重新编译内核源码</strong>，接下来我们来学习下软中断的使用方法。</p>
<h3 id="42-2-软中断接口函数"><a href="#42-2-软中断接口函数" class="headerlink" title="42.2 软中断接口函数"></a>42.2 软中断接口函数</h3><p>软中断的接口函数非常简单，介绍如下所示：</p>
<p><strong>1 注册软中断，使用open_softirq 函数，函数原型如下所示：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">open_softirq</span><span class="token punctuation">(</span><span class="token keyword">int</span> nr<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>action<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>函数的参数如下所示：<br>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。<br>action: 指向一个函数的指针，这个函数将作为软中断的处理程序。该函数接受一个structsoftirq_action 类型的参数。</p>
<p><strong>2 触发软中断，使用raise_softirq 函数，函数原型如下所示：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">raise_softirq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>函数的参数如下所示：<br>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p><strong>3 在禁用硬件中断的情况下，触发软中断使用raise_softirq_irqoff 函数，函数原型如下所示：</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">raise_softirq_irqoff</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>函数的参数如下所示：<br>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>在下一小节中将使用上述软中断API 进行相应的实验。</p>
<h3 id="42-3-实验程序的编写"><a href="#42-3-实验程序的编写" class="headerlink" title="42.3 实验程序的编写"></a>42.3 实验程序的编写</h3><h4 id="42-3-1-驱动程序编写"><a href="#42-3-1-驱动程序编写" class="headerlink" title="42.3.1 驱动程序编写"></a>42.3.1 驱动程序编写</h4><p>本实验对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\33_softirq\module。<br>本实验将实现注册显示屏触摸中断，每按当触摸LCD 显示屏就会触发中断服务函数，在中断服务函数中触发软中断，打印“This id test_interrupt”和“This is testsoft_func”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO 转换为中断号，并使用request_irq 函数请求中断，然后注册软中断函数。在中断处理函数中，我们触发软中断，使得当中断触发时，软中断处理函数会被调度执行。</p>
<p>接下来我们编写驱动代码，使用软中断来实现中断的下半部分。编写完成的interrupt.c 代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/gpio.h&gt;</span></span>
<span class="token comment">// #include &lt;linux/delay.h&gt;</span>

<span class="token keyword">int</span> irq<span class="token punctuation">;</span>

<span class="token comment">// 软中断处理程序</span>
<span class="token keyword">void</span> <span class="token function">testsoft_func</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> <span class="token operator">*</span>softirq_action<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is testsoft_func\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">irqreturn_t</span> <span class="token function">test_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_interrupt\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">raise_softirq</span><span class="token punctuation">(</span>TEST_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 触发软中断</span>
  <span class="token keyword">return</span> <span class="token function">IRQ_RETVAL</span><span class="token punctuation">(</span>IRQ_HANDLED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">interrupt_irq_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
  irq <span class="token operator">=</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将GPIO映射为中断号</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"irq is %d\n"</span><span class="token punctuation">,</span> irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 请求中断</span>
  ret <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> test_interrupt<span class="token punctuation">,</span> IRQF_TRIGGER_RISING<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"request_irq is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 注册软中断处理函数</span>
  <span class="token function">open_softirq</span><span class="token punctuation">(</span>TEST_SOFTIRQ<span class="token punctuation">,</span> testsoft_func<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">interrupt_irq_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">free_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放中断</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"bye bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>interrupt_irq_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>interrupt_irq_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="42-4-运行测试"><a href="#42-4-运行测试" class="headerlink" title="42.4 运行测试"></a>42.4 运行测试</h3><h4 id="42-4-1-编译驱动程序"><a href="#42-4-1-编译驱动程序" class="headerlink" title="42.4.1 编译驱动程序"></a>42.4.1 编译驱动程序</h4><p>在上一小节中的interrupt.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201413592.png" alt="image-20240820141313458"></p>
<p>上图中提示<code>open_softirq</code> 和<code>raise_softirq</code> 没有被定义，但是为什么还会提示这样的错误呢？<br>这是因为Linux 内核开发者不希望驱动工程师擅自在枚举类型中添加软中断。我们将这俩个函数导出到符号表，修改linux_sdk/kernel/kernel/softirq.c，修改内容如下（图42-3）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201413627.png" alt="image-20240820141344490"></p>
<p>修改完成后，重新编译内核源码，编译源码通过后，再次编译驱动模块，如下图（图42-4）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201414671.png" alt="image-20240820141400543"></p>
<p>编译完生成interrupt.ko 目标文件，如下图（图42-5）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201414177.png" alt="image-20240820141415053"></p>
<h4 id="42-4-2-运行测试"><a href="#42-4-2-运行测试" class="headerlink" title="42.4.2 运行测试"></a>42.4.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图42-6）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod interrupt.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201414293.png" alt="image-20240820141443168"></p>
<p>驱动加载成功之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，触发中断服务程序，打印如下图（42-7）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201414029.png" alt="image-20240820141455888"></p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和软中断处理函数中添加的打印“This is testsoft_func”<br>最后可以使用以下命令进行驱动的卸载，如下图（图42-8）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod interrupt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201415968.png" alt="image-20240820141519847"></p>
<p>至此，软中断实验就完成了。</p>
<h2 id="第43-章特殊的软中断tasklet-分析实验"><a href="#第43-章特殊的软中断tasklet-分析实验" class="headerlink" title="第43 章特殊的软中断tasklet 分析实验"></a>第43 章特殊的软中断tasklet 分析实验</h2><p>Tasklet 是Linux 内核中的一种软中断机制，它可以被看作是一种轻量级的延迟处理机制。它是通过软中断控制结构来实现的，因此也被称为软中断。本章节我们来从代码层面分析一下为什么tasklet 是一个特殊的软中断呢？</p>
<p>软中断处理函数的定义内核源码kernel/kernel/softirq.c 文件中，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __init <span class="token function">softirq_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> cpu<span class="token punctuation">;</span>
    <span class="token comment">// 初始化每个可能的CPU 的tasklet_vec 和tasklet_hi_vec</span>
    <span class="token comment">// 将tail 指针设置为对应的head 指针的初始位置</span>
    <span class="token function">for_each_possible_cpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">per_cpu</span><span class="token punctuation">(</span>tasklet_vec<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">.</span>tail <span class="token operator">=</span><span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>tasklet_vec<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
        <span class="token function">per_cpu</span><span class="token punctuation">(</span>tasklet_hi_vec<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">.</span>tail <span class="token operator">=</span><span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>tasklet_hi_vec<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 注册TASKLET_SOFTIRQ 软中断，并指定对应的处理函数为tasklet_action</span>
    <span class="token function">open_softirq</span><span class="token punctuation">(</span>TASKLET_SOFTIRQ<span class="token punctuation">,</span> tasklet_action<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 注册HI_SOFTIRQ 软中断，并指定对应的处理函数为tasklet_hi_action</span>
    <span class="token function">open_softirq</span><span class="token punctuation">(</span>HI_SOFTIRQ<span class="token punctuation">,</span> tasklet_hi_action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面开始对上述代码详细解释：</p>
<ul>
<li><code>for_each_possible_cpu(cpu)</code>：遍历每个可能的CPU。在多核系统中，此循环用于初始化每个CPU 的<code>tasklet_vec</code> 和<code>tasklet_hi_vec</code>。</li>
<li><code>per_cpu(tasklet_vec, cpu).tail = &amp;per_cpu(tasklet_vec, cpu).head;</code>：将每个CPU 的<code>tasklet_vec</code>的<code>tail</code> 指针设置为对应的<code>head</code> 指针的初始位置。这样做是为了确保<code>tasklet_vec</code> 的初始状态是空的。</li>
<li><code>per_cpu(tasklet_hi_vec, cpu).tail = &amp;per_cpu(tasklet_hi_vec, cpu).head;</code> ： 将每个CPU 的<code>tasklet_hi_vec</code> 的tail 指针设置为对应的head 指针的初始位置。这样做是为了确保<code>tasklet_hi_vec</code> 的初始状态是空的。</li>
<li><code>open_softirq(TASKLET_SOFTIRQ, tasklet_action);</code>：注册<code>TASKLET_SOFTIRQ</code> 软中断，并指定对应的处理函数为<code>tasklet_action</code>。这样，在<code>TASKLET_SOFTIRQ</code> 被触发时，将会调用<code>tasklet_action</code>函数来处理相应的任务。</li>
<li><code>open_softirq(HI_SOFTIRQ, tasklet_hi_action);</code>：注册<code>HI_SOFTIRQ</code> 软中断，并指定对应的处理函数为<code>tasklet_hi_action</code>。这样，在<code>HI_SOFTIRQ</code> 被触发时，将会调用<code>tasklet_hi_action</code> 函数来处理相应的任务。</li>
</ul>
<p>在执行__init <code>softirq_init</code> 函数时，会触发<code>TASKLET_SOFTIRQ</code>，然后会调用<code>tasklet_action</code> 函数，<code>tasklet_action</code> 函数如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __latent_entropy <span class="token keyword">void</span> <span class="token function">tasklet_action</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> <span class="token operator">*</span>a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">tasklet_action_common</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token function">this_cpu_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tasklet_vec<span class="token punctuation">)</span><span class="token punctuation">,</span> TASKLET_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述函数中调用了<code>tasklet_action_common</code> 函数，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __latent_entropy <span class="token keyword">void</span> <span class="token function">tasklet_action</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> <span class="token operator">*</span>a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">tasklet_action_common</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token function">this_cpu_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tasklet_vec<span class="token punctuation">)</span><span class="token punctuation">,</span> TASKLET_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>tasklet_action_common</code> 函数，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tasklet_action_common</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> <span class="token operator">*</span>a<span class="token punctuation">,</span>
                                    <span class="token keyword">struct</span> <span class="token class-name">tasklet_head</span> <span class="token operator">*</span>tl_head<span class="token punctuation">,</span>
                                    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> softirq_nr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token operator">*</span>list<span class="token punctuation">;</span>
    <span class="token comment">// 禁用本地中断</span>
    <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取tasklet_head 中的任务链表</span>
    list <span class="token operator">=</span> tl_head<span class="token operator">-&gt;</span>head<span class="token punctuation">;</span>
    <span class="token comment">// 清空tasklet_head 中的任务链表</span>
    tl_head<span class="token operator">-&gt;</span>head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">// 将tail 指针重新指向head 指针的位置</span>
    tl_head<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> <span class="token operator">&amp;</span>tl_head<span class="token operator">-&gt;</span>head<span class="token punctuation">;</span>
    <span class="token comment">// 启用本地中断</span>
    <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 遍历任务链表，处理每一个tasklet</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token operator">*</span>t <span class="token operator">=</span> list<span class="token punctuation">;</span>
        <span class="token comment">// 获取下一个tasklet，并更新链表</span>
        list <span class="token operator">=</span> list<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tasklet_trylock</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 尝试获取tasklet 的锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">atomic_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 检查count 计数器是否为0</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">test_and_clear_bit</span><span class="token punctuation">(</span>TASKLET_STATE_SCHED<span class="token punctuation">,</span><span class="token operator">&amp;</span>t<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token function">BUG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果state 标志位不正确，则发生错误</span>
                t<span class="token operator">-&gt;</span><span class="token function">func</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行tasklet 的处理函数</span>
                <span class="token function">tasklet_unlock</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁tasklet</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">tasklet_unlock</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁tasklet</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 禁用本地中断</span>
        <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将当前tasklet 添加到tasklet_head 的尾部</span>
        t<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>tl_head<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> t<span class="token punctuation">;</span>
        <span class="token comment">// 更新tail 指针</span>
        tl_head<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> <span class="token operator">&amp;</span>t<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token comment">// 触发软中断</span>
        <span class="token function">__raise_softirq_irqoff</span><span class="token punctuation">(</span>softirq_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 启用本地中断</span>
        <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的代码中，<code>tasklet_action_common()</code>函数对任务链表中的每个tasklet 进行处理。它首先禁用本地中断，获取任务链表头指针，清空任务链表，并重新设置尾指针。然后它循环遍历任务链表，对每个tasklet 进行处理。如果tasklet 的锁获取成功，并且计数器为0，它将执行tasklet 的处理函数，并清除状态标志位。如果锁获取失败或计数不为0，它将tasklet 添加到任务链表的尾部，并触发指定的软中断。最后，它启用本地中断，完成任务处理过程。</p>
<p>那么tasklet 在什么时候加到链表里面的呢？tasklet 是通过<code>__tasklet_schedule_common()</code>函数加入到链表中的。如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__tasklet_schedule_common</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tasklet_struct</span> <span class="token operator">*</span>t<span class="token punctuation">,</span>
                                        <span class="token keyword">struct</span> <span class="token class-name">tasklet_head</span> __percpu <span class="token operator">*</span>headp<span class="token punctuation">,</span>
                                        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> softirq_nr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tasklet_head</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token comment">// 保存当前中断状态，并禁用本地中断</span>
    <span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取当前CPU 的tasklet_head 指针</span>
    head <span class="token operator">=</span> <span class="token function">this_cpu_ptr</span><span class="token punctuation">(</span>headp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将当前tasklet 添加到tasklet_head 的尾部</span>
    t<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>head<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token comment">// 更新tasklet_head 的尾指针</span>
    head<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 触发指定的软中断</span>
    <span class="token function">raise_softirq_irqoff</span><span class="token punctuation">(</span>softirq_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 恢复中断状态</span>
    <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上述代码，<code>__tasklet_schedule_common()</code>函数将<code>tasklet</code> 成功添加到链表的末尾。当软中断被触发时，系统会遍历链表并处理每个tasklet。因此，在添加到链表后，tasklet将在适当的时机被系统调度和执行。</p>
<p>经过上述分析，所以说**<code>tasklet</code> 是一个特殊的软中断。**</p>
<p>内核开发者不希望我们去添加软中断的软中断号，更希望我们使用tasklet。那么tasklet相比自己添加软中断有哪些优点和缺点呢？</p>
<p><strong>使用Tasklet 相比自己添加软中断有一些优点和缺点</strong>。以下是它们的比较：</p>
<p>优点：</p>
<ol>
<li>简化的接口和编程模型：Tasklet 提供了一个简单的接口和编程模型，使得在内核中处理延迟工作变得更加容易。相比自己添加软中断，Tasklet 提供了更高级的抽象。</li>
<li>低延迟：Tasklet 在软中断上下文中执行，避免了内核线程的上下文切换开销，因此具有较低的延迟。这对于需要快速响应的延迟敏感任务非常重要。</li>
<li>自适应调度：Tasklet 具有自适应调度的特性，当多个Tasklet 处于等待状态时，内核会合并它们以减少不必要的上下文切换。这种调度机制可以提高系统的效率。</li>
</ol>
<p>缺点：</p>
<ol>
<li>无法处理长时间运行的任务：Tasklet 适用于短时间运行的延迟工作，如果需要处理长时间运行的任务，可能会阻塞其他任务的执行。对于较长的操作，可能需要使用工作队列或内核线程来处理。</li>
<li>缺乏灵活性：Tasklet 的执行受限于软中断的上下文，不适用于所有类型的延迟工作。某些情况下，可能需要更灵活的调度和执行机制，这时自定义软中断可能更加适合。</li>
<li>资源限制：Tasklet 的数量是有限的，系统中可用的Tasklet 数量取决于架构和内核配置。如果需要大量的延迟工作处理，可能会受到Tasklet 数量的限制。</li>
</ol>
<p>综上所述，**<code>Tasklet</code> 提供了一种简单且低延迟的延迟工作处理机制，适用于短时间运行的任务和对响应时间敏感的场景**。然而，对于长时间运行的任务和需要更灵活调度的情况，自定义软中断可能更合适。在选择使用Tasklet 还是自定义软中断时，需要根据具体的需求和系统特性进行权衡和决策。</p>
<h2 id="第44-章共享工作队列实验"><a href="#第44-章共享工作队列实验" class="headerlink" title="第44 章共享工作队列实验"></a>第44 章共享工作队列实验</h2><p>在上个章节我们学习了中断下文的一种实验方式——软中断，本章节我们来学习中断下文的另一种实现方式——工作队列。工作队列是操作系统中管理和调度异步任务执行的一种机制，接下来开始学习工作队列吧。</p>
<h3 id="44-1-什么是工作队列"><a href="#44-1-什么是工作队列" class="headerlink" title="44.1 什么是工作队列"></a>44.1 什么是工作队列</h3><p><strong>工作队列是实现中断下半部分的机制之一，是一种用于管理任务的数据结构或机制</strong>。它通常用于多线程，多进程或分布式系统中，<strong>用于协调和分配待处理的任务给可用的工作线程或工作进程</strong>。</p>
<p>工作队列的基本原理是将需要执行的任务按顺序排列在队列中，并提供一组工作线程或者工作进程来处理队列中的任务。当有新的任务到达时，它们会被添加到队列的末尾，工作线程或工作进程从队列的头部获取任务，并执行相应的处理操作。</p>
<p><strong>工作队列和之前学习的tasklet 有什么不同呢</strong>？tasklet 也是实现中断下半部分的机制之一。<strong>他们最主要的区别是tasklet 不能休眠，而工作队列是可以休眠的，所以tasklet 可以用来处理比较耗时间的事情，而工作队列可以处理更耗时间的事情。</strong></p>
<p>工作队列将工作推后以后，会交给内核线程去执行。Linux 在启动过程中会创建一个工作者内核线程，这个线程创建以后处于sleep 状态。当有工作需要处理的时候，会唤醒这个线程去处理工作。</p>
<p>在内核中，工作队列包括共享工作队列和自定义工作队列这俩种类型。这两种类型的工作队列具有不同的特点和用途。</p>
<ol>
<li>共享队列是由内核管理的全局工作队列，用于处理内核中一些系统级任务。共享工作队列是内核中一个默认工作队列，可以由多个内核组件和驱动程序共享使用。</li>
<li>自定义工作队列是由内核或驱动程序创建的特定工作队列，用于处理特定的任务。自定义工作队列通常与特定的内核模块或驱动程序相关联，用于执行该模块或驱动程序相关的任务。</li>
</ol>
<p>本章节我们先来学习共享工作队列相关的知识。<br>在Linux 内核中，使用work_struct 结构体表示一个工作项，这些工作组织成工作队列，工作队列使用workqueue_struct 结构体表示，如下图所示，流水线相当于工作队列，流水线上一个个等待处理的物料相当于一个个工作。机器相当于内核线程或进程。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201432143.png" alt="image-20240820143242999"></p>
<p><code>work_struct</code> 结构体表示一个工作项，定义在<code>include/linux/workqueue.h</code> 中，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token punctuation">{</span>
    <span class="token class-name">atomic_long_t</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> entry<span class="token punctuation">;</span>
    <span class="token class-name">work_func_t</span> func<span class="token punctuation">;</span> <span class="token comment">/* 工作队列处理函数*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">work_func_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//工作函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="44-2-工作队列相关接口函数"><a href="#44-2-工作队列相关接口函数" class="headerlink" title="44.2 工作队列相关接口函数"></a>44.2 工作队列相关接口函数</h3><h4 id="44-2-1-初始化函数"><a href="#44-2-1-初始化函数" class="headerlink" title="44.2.1 初始化函数"></a>44.2.1 初始化函数</h4><p>在实际的驱动开发中，我们只需要<strong>定义工作项(<code>work_struct</code>)即可</strong>，关于工作队列和工作者线程我们基本不用去管。简单创建工作很简单，直接定义一个<code>work_struct</code> 结构体变量即可，然后使用<code>INIT_WORK</code> 宏来初始化工作，<code>INIT_WORK</code> 宏定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">INIT_WORK</span><span class="token expression"><span class="token punctuation">(</span>_work<span class="token punctuation">,</span>_func<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>INIT_WORK 宏接受两个参数：<code>_work</code> 和<code>_func</code>，分别表示要初始化的工作项和工作项的处理函数。<br>也可以使用<code>DECLARE_WORK</code> 宏一次性完成工作的创建和初始化，宏定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DECLARE_WORK</span><span class="token expression"><span class="token punctuation">(</span>n<span class="token punctuation">,</span> f<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数n 表示定义的工作(<code>work_struct</code>)，f 表示工作对应的处理函数。</p>
<h4 id="44-2-2-调度-x2F-取消调度工作队列函数"><a href="#44-2-2-调度-x2F-取消调度工作队列函数" class="headerlink" title="44.2.2 调度/取消调度工作队列函数"></a>44.2.2 调度/取消调度工作队列函数</h4><p>和tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为schedule_work，函数原型如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> bool <span class="token function">schedule_work</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数是指向工作项的指针。这个函数作用是将工作项提交到工作队列中，并请求调度器在合适的时机执行工作项。该函数会返回一个布尔值，表示工作项是否成功被提交到工作队列。</p>
<p>如果想要取消该工作项的调度，使用以下函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">cancel_work_sync</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数是指向工作项的指针。这个函数的作用是取消该工作项的调度。如果工作项已经在工作队列中，它将被从队列中移除。如果工作项已经在工作队列中，它将被从队列中移除，并等待工作项执行完成。函数返回一个布尔值，表示工作项是否成功取消。</p>
<h3 id="44-3-实验程序的编写"><a href="#44-3-实验程序的编写" class="headerlink" title="44.3 实验程序的编写"></a>44.3 实验程序的编写</h3><h4 id="44-3-1-驱动程序编写"><a href="#44-3-1-驱动程序编写" class="headerlink" title="44.3.1 驱动程序编写"></a>44.3.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\34_workqueue\module</code>。<br>本实验将实现注册显示屏触摸中断，每按当触摸LCD 显示屏就会触发中断服务函数，在中断服务函数中提交工作项到共享工作队列中，打印“This id test_interrupt”和“This istest_work”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO 转换为中断号，并使用request_irq 函数请求中断，然后初始化工作项。当中断被触发时，中断处理函数被调用，并将工作项提交到共享工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c 代码如下所示，添加的代码已加粗表示。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/gpio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/workqueue.h&gt;</span></span>

<span class="token keyword">int</span> irq<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">work_struct</span> test_workqueue<span class="token punctuation">;</span>
<span class="token comment">// 工作项处理函数</span>
<span class="token keyword">void</span> <span class="token function">test_work</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">msleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_work\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中断处理函数</span>
<span class="token class-name">irqreturn_t</span> <span class="token function">test_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_interrupt\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 提交工作项到工作队列</span>
  <span class="token function">schedule_work</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_workqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">IRQ_RETVAL</span><span class="token punctuation">(</span>IRQ_HANDLED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">interrupt_irq_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
  irq <span class="token operator">=</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将GPIO映射为中断号</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"irq is %d\n"</span><span class="token punctuation">,</span> irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 请求中断</span>
  ret <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> test_interrupt<span class="token punctuation">,</span> IRQF_TRIGGER_RISING<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"request_irq is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 初始化工作项</span>
  <span class="token function">INIT_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_workqueue<span class="token punctuation">,</span> test_work<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">interrupt_irq_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">free_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放中断</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"bye bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>interrupt_irq_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>interrupt_irq_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="44-4-运行测试"><a href="#44-4-运行测试" class="headerlink" title="44.4 运行测试"></a>44.4 运行测试</h3><h4 id="44-4-1-编译驱动程序"><a href="#44-4-1-编译驱动程序" class="headerlink" title="44.4.1 编译驱动程序"></a>44.4.1 编译驱动程序</h4><p>在上一小节中的interrupt.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成interrupt.ko 目标文件，至此驱动模块就编译成功了，接下来进行测试。</p>
<h4 id="44-4-2-运行测试"><a href="#44-4-2-运行测试" class="headerlink" title="44.4.2 运行测试"></a>44.4.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图44-5）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod interrupt.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201438920.png" alt="image-20240820143808787"></p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7 寸屏幕，<br>打印如下图（44-6）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201438387.png" alt="image-20240820143820241"></p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被多次打印，说明触发了好几次中断上文，那么中断上文会多次调度中断下文，所以也会打印工作项处理函数中添加的打印“This is test_work”。但是为什么只会打印俩次“This is test_work”呢？这是因为在中断上文调度工作项处理函数之后，内核没有来得及去执行工作项处理函数，没有执行相当于无效操作，有效的执行则打印了俩次“This is test_work”。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图44-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod interrupt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201439215.png" alt="image-20240820143906078"></p>
<p>至此，共享工作队列实验就完成了。</p>
<h2 id="第45-章自定义工作队列实验"><a href="#第45-章自定义工作队列实验" class="headerlink" title="第45 章自定义工作队列实验"></a>第45 章自定义工作队列实验</h2><p>在上一章节中对工作队列以及共享工作队列知识进行了学习，并使用共享队列进行了实验。<strong>共享队列是由内核管理的全局工作队列</strong>，<strong>自定义工作队列是由内核或驱动程序创建的特定工作队列</strong>，用于处理特定的任务。下面就让我们一起来进行自定义工作队列的学习吧。</p>
<h3 id="45-1-工作队列相关结构体"><a href="#45-1-工作队列相关结构体" class="headerlink" title="45.1 工作队列相关结构体"></a>45.1 工作队列相关结构体</h3><p>在Linux 内核中，结构体struct work_struct 描述的是要延迟执行的工作项，定义在<code>include/linux/workqueue.h</code> 当中，如下所示</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token punctuation">{</span>
    <span class="token class-name">atomic_long_t</span> data<span class="token punctuation">;</span> <span class="token comment">// 工作项的数据字段</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> entry<span class="token punctuation">;</span> <span class="token comment">// 工作项在工作队列中的链表节点</span>
    <span class="token class-name">work_func_t</span> func<span class="token punctuation">;</span> <span class="token comment">// 工作项的处理函数</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_LOCKDEP</span></span>
        <span class="token keyword">struct</span> <span class="token class-name">lockdep_map</span> lockdep_map<span class="token punctuation">;</span> <span class="token comment">// 锁依赖性映射</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这些工作组织成工作队列，内核使用<code>struct workqueue_struct</code> 结构体描述一个工作队列，定义在<code>include/linux/workqueue.h</code> 当中，如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> pwqs<span class="token punctuation">;</span> <span class="token comment">// 工作队列上的挂起工作项列表</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> delayed_works<span class="token punctuation">;</span> <span class="token comment">// 延迟执行的工作项列表</span>
    <span class="token keyword">struct</span> <span class="token class-name">delayed_work_timer</span> dwork_timer<span class="token punctuation">;</span> <span class="token comment">// 延迟工作项的定时器</span>
    <span class="token keyword">struct</span> <span class="token class-name">workqueue_attrs</span> <span class="token operator">*</span>unbound_attrs<span class="token punctuation">;</span> <span class="token comment">// 无绑定工作队列的属性</span>
    <span class="token keyword">struct</span> <span class="token class-name">pool_workqueue</span> <span class="token operator">*</span>dfl_pwq<span class="token punctuation">;</span> <span class="token comment">// 默认的池化工作队列</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="45-2-工作队列相关接口函数"><a href="#45-2-工作队列相关接口函数" class="headerlink" title="45.2 工作队列相关接口函数"></a>45.2 工作队列相关接口函数</h3><p>在Linux 内核中，create_workqueue 函数用于创建一个工作队列，函数原型如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span><span class="token function">create_workqueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数name 是创建的工作队列的名字。使用这个函数可以给每个CPU 都创建一个CPU 相关的工作队列。创建成功返回一个struct workqueue_struct 类型指针，创建失败返回NULL。</p>
<p>如果只给一个CPU 创建一个CPU 相关的工作队列，使用以下函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">create_singlethread_workqueue</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">)</span> \ <span class="token function">alloc_workqueue</span><span class="token punctuation">(</span></span><span class="token string">"%s"</span><span class="token expression"><span class="token punctuation">,</span> WQ_SINGLE_THREAD<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数name 是创建的工作队列的名字。使用这个函数只会给一个CPU 创建一个CPU 相关的工作队列。创建成功之后返回一个struct workqueue_struct 类型指针，创建失败返回NULL。</p>
<p>当工作队列创建好之后，需要将要延迟执行的工作项放在工作队列上，调度工作队列，使用queue_work_on 函数，函数原型如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">queue_work_on</span><span class="token punctuation">(</span><span class="token keyword">int</span> cpu<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span>wq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>该函数有三个参数， 第一个参数是一个整数cpu ， 第二个参数是一个指向<code>struct workqueue_struct</code> 的指针wq，第三个参数是一个指向<code>struct work_struct</code> 的指针work。<br>该函数的返回类型是布尔值，表示是否成功调度工作队列。<code>queue_work_on</code> 函数还有其他变种，比如<code>queue_work</code> 函数，这里略过，其实思路是一致的，用于将定义好的工作项立即添加到工作队列中，并在工作队列可用时立即执行。</p>
<p>如果要取消一个已经调度的工作，使用函数<code>bool cancel_work_sync</code>，函数原型如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">cancel_work_sync</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>函数的作用是取消一个已经调度的工作，如果被取消的工作已经正在执行，则会等待他执行完成再返回。</p>
<p>在Linux 内核中，使用<code>flush_workqueue</code> 函数将刷新该工作队列中所有已提交但未执行的工作项。函数原型如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">flush_workqueue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>该函数参数是一个指向<code>struct workqueue_struct</code> 类型的指针<code>wq</code>。函数的作用是刷新工作队列，告诉内核尽快处理工作队列上的工作。</p>
<p>如果要删除自定义的工作队列，使用<code>destroy_workqueue</code> 函数，函数原型如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">destroy_workqueue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>该函数参数是一个指向<code>struct workqueue_struct</code> 类型的指针<code>wq</code>。</p>
<p>在下一小节中将使用上述工作队列API 函数进行相应的实验。</p>
<h3 id="45-3-实验程序的编写"><a href="#45-3-实验程序的编写" class="headerlink" title="45.3 实验程序的编写"></a>45.3 实验程序的编写</h3><h4 id="45-3-1-驱动程序编写"><a href="#45-3-1-驱动程序编写" class="headerlink" title="45.3.1 驱动程序编写"></a>45.3.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\35_workqueue_share\module</code>。<br>本实验将实现注册显示屏触摸中断，每按当触摸LCD 显示屏就会触发中断服务函数，在中断服务函数中提交工作项到工作队列中，打印“This id test_interrupt”和“This istest_work”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO 转换为中断号，并使用request_irq 函数请求中断，然后创建自定义工作队列，初始化工作项。当中断被触发时，中断处理函数被调用，并将工作项提交到自定义工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c 代码如下所示，添加的代码已加粗表示。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/gpio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/workqueue.h&gt;</span></span>

<span class="token keyword">int</span> irq<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span>test_workqueue<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">work_struct</span> test_workqueue_work<span class="token punctuation">;</span>

<span class="token comment">// 工作项处理函数</span>
<span class="token keyword">void</span> <span class="token function">test_work</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">msleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_work\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中断处理函数</span>
<span class="token class-name">irqreturn_t</span> <span class="token function">test_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_interrupt\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">queue_work</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 提交工作项到工作队列</span>
  <span class="token keyword">return</span> <span class="token function">IRQ_RETVAL</span><span class="token punctuation">(</span>IRQ_HANDLED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">interrupt_irq_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
  irq <span class="token operator">=</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将GPIO映射为中断号</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"irq is %d\n"</span><span class="token punctuation">,</span> irq<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 请求中断</span>
  ret <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> test_interrupt<span class="token punctuation">,</span> IRQF_TRIGGER_RISING<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"request_irq is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  test_workqueue <span class="token operator">=</span> <span class="token function">create_workqueue</span><span class="token punctuation">(</span><span class="token string">"test_workqueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建工作队列</span>
  <span class="token function">INIT_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">,</span> test_work<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 初始化工作项</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">interrupt_irq_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">free_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 释放中断</span>
  <span class="token function">cancel_work_sync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取消工作项</span>
  <span class="token function">flush_workqueue</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 刷新工作队列</span>
  <span class="token function">destroy_workqueue</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 销毁工作队列</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"bye bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>interrupt_irq_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>interrupt_irq_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="45-4-运行测试"><a href="#45-4-运行测试" class="headerlink" title="45.4 运行测试"></a>45.4 运行测试</h3><h4 id="45-4-1-编译驱动程序"><a href="#45-4-1-编译驱动程序" class="headerlink" title="45.4.1 编译驱动程序"></a>45.4.1 编译驱动程序</h4><p>在上一小节中的interrupt.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成interrupt.ko 目标文件，至此驱动模块就编译成功了，接下来进行测试。</p>
<h4 id="45-4-2-运行测试"><a href="#45-4-2-运行测试" class="headerlink" title="45.4.2 运行测试"></a>45.4.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图45-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod interrupt.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201517110.png" alt="image-20240820151728963"></p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7 寸屏幕，打印如下图（45-5）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201517354.png" alt="image-20240820151739201"></p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被打印了俩次，说明触发了2 次中断上文，那么中断上文会调度2 次中断下文，所以也会打印2 次工作项处理函数中添加的打印“This is test_work”。<br>在按屏幕之后，立即输入<code>ps -aux|grep test_workqueue</code> 命令可以查看自己创建的工作队列，如下（图45-6）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201518032.png" alt="image-20240820151804887"></p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图45-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod interrupt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201518503.png" alt="image-20240820151827357"></p>
<p>至此，自定义工作队列实验就完成了。</p>
<h2 id="第46-章延迟工作实验"><a href="#第46-章延迟工作实验" class="headerlink" title="第46 章延迟工作实验"></a>第46 章延迟工作实验</h2><p>在之前的章节中，我们学习了共享工作队列和自定义工作队列，为了更形象地理解学习，将流水线比作工作队列，流水线上一个个等待处理的物料比作一个个工作。机器比作内核线程或进程。本章节我们即将学习的延迟工作，可以类比为将物料延迟一定时间，再放到生产线上加工。延迟工作不仅可以在自定义工作队列中实现也可以在共享工作队列上实现。现在，我们对延迟工作有了一个感性的认识，接下来详细的学习下延迟工作吧。</p>
<h3 id="46-1-什么是延迟工作"><a href="#46-1-什么是延迟工作" class="headerlink" title="46.1 什么是延迟工作"></a>46.1 什么是延迟工作</h3><p><strong>延迟工作是一种将工作的执行延迟到稍后时间点进行处理的技术</strong>。通常情况下，<strong>当某个任务需要花费较长时间，不需要立即执行或需要按时执行时，延迟工作就会派上用场</strong>。</p>
<p>延迟工作的基本思想是将任务放入一个队列中，然后由后台的工作进程会任务调度程序来处理队列中的任务。任务可以在指定的延迟时间后执行，也可以根据优先级，任务类型或者其他条件进行排序和处理。</p>
<p>延迟工作在许多应用场景中都非常有用，尤其是在需要处理大量任务，提供系统性能和可靠性的情况下。以下是一些常用的应用场景：</p>
<ol>
<li>延迟工作常用于处理那些需要花费较长时间的任务，比如发送电子邮件，处理图像等。通过将这些任务放入队列中并延迟执行，可以避免阻塞应用程序的主线程，提高系统的响应速度。</li>
<li>延迟工作可以用来执行定时任务，比如定时备份数据库，通过将任务设置为在未来的某个时间点执行，提高系统的可靠性和效率。</li>
</ol>
<p>为了方便大家理解，我们再举个形象点的例子，比如说开发板上的按键，现在我们想通过驱动程序读取按键的状态，那么只需要读取这个按键所连接的GPIO 的状态就可以了。</p>
<p>理想型的按键电压变化过程如图（图46-1）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201521746.png" alt="image-20240820152105572" style="zoom:50%;">

<p>在上图中，按键没有按下的时候按键值为1，当按键在t1 时刻按键被按下以后按键值就变为0，这是最理想的状态。但是实际的按键是机械结构，加上刚按下去的一瞬间人手可能也有抖动，实际的按键电压变化过程如下图（图46-2）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201521264.png" alt="image-20240820152129112" style="zoom:50%;">

<p>在上图中，t1 时刻按键被按下，但是由于抖动的原因，直到t2 时刻才稳定下来，t1 到t2 这段时间就是抖动。一般这段时间就是十几ms 左右，从上图中可以看出在抖动期间会有多次触发，如果不消除这段抖动的话软件就会误判，本来按键就按下了一次，结果软件读取IO值发现电平多次跳变以为按下了多次。所以我们需要跳过这段抖动时间再去读取按键的IO 值，也就是至少要在t2 时刻以后再去读IO 值。在之前的驱动视频中，我们使用了定时器来实现消抖。按键采用中断驱动方式，当按键按下以后触发按键中断，在按键中断中开启一个定时器，定时周期为10ms，当定时时间到了以后就会触发定时器中断，最后在定时器中断处理函数中读取按键的值，如果按键值还是按下状态那就表示这是一次有效的按键。定时器按键消抖如下图（图46-3）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201522793.png" alt="image-20240820152201643" style="zoom:50%;">

<p>在上图中t1<del>t3 这一段时间就是按键抖动，是需要消除的。设置按键为下降沿触发，因此会在t1、t2 和t3 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中断，所以会在t1、t2 和t3 这三个时刻开器定时器中断。但是t1</del>t2 和t2~t3 这两个时间段是小于我们设置的定时器中断周期(也就是消抖时间，比如10ms)，所以虽然t1 开启了定时器，但是定时器定时时间还没到呢t2 时刻就重置了定时器，最终只有t3 时刻开启的定时器能完整的完成整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现按键防抖的原理，Linux 里面的按键驱动用的就是这个原理！</p>
<p>除了使用定时器方式进行消抖，也可以使用本章节讲述的延迟工作。在中断下文中将工作延迟3 秒之后，再去读GPIO 电平状态。</p>
<p>在Linux 内核中，使用struct delayed_work 来描述延迟工作，定义在<code>include/linux/workqueue.h</code> 当中，原型定义如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">delayed_work</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">work_struct</span> work<span class="token punctuation">;</span><span class="token comment">// 延迟工作的基本工作结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">timer_list</span> timer<span class="token punctuation">;</span><span class="token comment">// 定时器，用于延迟执行工作</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>struct delayed_work 结构体包含了两个成员：</p>
<ol>
<li>work：这是一个struct work_struct 类型的成员，用于表示延迟工作的基本工作结构。<code>struct work_struct</code> 是表示工作的常见数据结构，用于定义要执行的工作内容。</li>
<li>timer：这是一个struct timer_list 类型的成员，用于管理延迟工作的定时器。<code>struct timer_list</code>是Linux 内核中的定时器结构，用于设置延迟时间和触发工作执行的时机。</li>
</ol>
<p>使用<code>struct delayed_work</code> 结构体，可以将需要执行的工作封装成一个延迟工作，并使用定时器来控制工作的延迟执行。通过设置定时器的延迟时间，可以指定工作在一定时间后执行。<br>接下来我们学习下延迟工作相关的接口函数吧。</p>
<h3 id="46-2-延迟工作相关接口函数"><a href="#46-2-延迟工作相关接口函数" class="headerlink" title="46.2 延迟工作相关接口函数"></a>46.2 延迟工作相关接口函数</h3><h4 id="46-2-1-初始化延迟工作函数"><a href="#46-2-1-初始化延迟工作函数" class="headerlink" title="46.2.1 初始化延迟工作函数"></a>46.2.1 初始化延迟工作函数</h4><p>静态定义并初始化延迟工作使用宏<code>DECLARE_DELAYED_WORK</code>，函数原型如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DECLARE_DELAYED_WORK</span><span class="token expression"><span class="token punctuation">(</span>n<span class="token punctuation">,</span>f<span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token class-name">delayed_work</span> n <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>work <span class="token operator">=</span> <span class="token function">__WORK_INITIALIZER</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>work<span class="token punctuation">,</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用宏定义后，可以将上述代码简化为<code>#define DECLARE_DELAYED_WORK(n,f)</code>，n 代表延迟工作的变量名，f 是延迟工作的处理函数。</p>
<p>动态定义并初始化延迟工作使用宏<code>INIT_DELAYED_WORK</code>，函数原型如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">INIT_DELAYED_WORK</span><span class="token expression"><span class="token punctuation">(</span>_work<span class="token punctuation">,</span> _func<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">INIT_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>_work<span class="token punctuation">)</span><span class="token operator">-&gt;</span>work<span class="token punctuation">,</span> <span class="token punctuation">(</span>_func<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">(</span>_work<span class="token punctuation">)</span><span class="token operator">-&gt;</span>timer <span class="token operator">=</span> <span class="token function">TIMER_INITIALIZER</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_work<span class="token punctuation">)</span><span class="token operator">-&gt;</span>timer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用宏定义后，可以将上述代码简化为<code>#define INIT_DELAYED_WORK(_work, _func)</code>， n 代表延迟工作的变量名，f 是延迟工作的处理函数。</p>
<h4 id="46-2-2-调度-x2F-取消调度延迟工作函数"><a href="#46-2-2-调度-x2F-取消调度延迟工作函数" class="headerlink" title="46.2.2 调度/取消调度延迟工作函数"></a>46.2.2 调度/取消调度延迟工作函数</h4><p>如果是在共享工作队列上调度延迟工作，使用以下函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> bool <span class="token function">schedule_delayed_work</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">delayed_work</span> <span class="token operator">*</span>dwork<span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> delay <span class="token punctuation">)</span>
该函数是一个内联函数，用于在给定的延迟时间后调度延迟工作执行。
函数参数
	dwork<span class="token operator">:</span>是指向延迟工作的指针，即要被调度的延迟工作。
	delay<span class="token operator">:</span>表示延迟的时间长度，以内核时钟节拍数jiffies 为单位。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果是在自定义工作队列上调度延迟工作，使用以下函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> bool <span class="token function">queue_delayed_work</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span>wq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">delayed_work</span> <span class="token operator">*</span>dwork<span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> delay<span class="token punctuation">)</span>
该函数是一个内联函数，用于将延迟工作加入工作队列后在指定的延迟时间后执行。
函数参数
    wq 是指向工作队列结构的指针，即要将延迟工作加入的目标工作队列。
    dwork<span class="token operator">:</span>指向延迟工作的指针，也就是要被加入工作队列的延迟工作。
    delay<span class="token operator">:</span> 表示延迟的时间长度，以内核时钟节拍数jiffies 为单位。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果要取消调度函数，使用以下函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> bool <span class="token function">cancel_delayed_work_sync</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">delayed_work</span> <span class="token operator">*</span>dwork<span class="token punctuation">)</span><span class="token punctuation">;</span>
该函数是一个外部声明的函数，用于取消延迟工作并等待其完成。dwork 参数是指向延迟工作的指针，也就是要被取消的延迟工作。函数如果返回true，说明成功取消延迟工作并等待其完成。函数如果返回false，说明无法取消延迟工作或等待其完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在下一小节中将在自定义工作队列实验的基础上修改驱动，进行延迟工作实验。</p>
<h3 id="46-3-实验程序的编写"><a href="#46-3-实验程序的编写" class="headerlink" title="46.3 实验程序的编写"></a>46.3 实验程序的编写</h3><h4 id="46-3-1-驱动程序编写"><a href="#46-3-1-驱动程序编写" class="headerlink" title="46.3.1 驱动程序编写"></a>46.3.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\36_workqueue_delay\module</code>。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD 显示屏就会触发中断服务函数，在中断服务函数中提交延迟工作项到工作队列中，打印“<code>This id test_interrupt</code>”，并延迟打印“<code>This is test_work</code>”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO 转换为中断号，并使用<code>request_irq</code> 函数请求中断，然后创建自定义工作队列，初始化延迟工作项。当中断被触发时，中断处理函数被调用，并将延迟工作项提交到自定义工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c 代码如下所示，添加的代码已加粗表示。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/gpio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/workqueue.h&gt;</span></span>

<span class="token keyword">int</span> irq<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span>test_workqueue<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">delayed_work</span> test_workqueue_work<span class="token punctuation">;</span>

<span class="token comment">// 工作项处理函数</span>
<span class="token keyword">void</span> <span class="token function">test_work</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">msleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_work\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中断处理函数</span>
<span class="token class-name">irqreturn_t</span> <span class="token function">test_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_interrupt\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 提交延迟工作项到自定义工作队列</span>
  <span class="token function">queue_delayed_work</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> HZ<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">return</span> <span class="token function">IRQ_RETVAL</span><span class="token punctuation">(</span>IRQ_HANDLED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">interrupt_irq_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
  irq <span class="token operator">=</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将GPIO映射为中断号</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"irq is %d\n"</span><span class="token punctuation">,</span> irq<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 请求中断</span>
  ret <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> test_interrupt<span class="token punctuation">,</span> IRQF_TRIGGER_RISING<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"request_irq is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 创建工作队列</span>
  test_workqueue <span class="token operator">=</span> <span class="token function">create_workqueue</span><span class="token punctuation">(</span><span class="token string">"test_workqueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">// 初始化延迟工作项</span>
  <span class="token function">INIT_DELAYED_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">,</span> test_work<span class="token punctuation">)</span><span class="token punctuation">;</span>  

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">interrupt_irq_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">free_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 释放中断</span>
  <span class="token function">cancel_delayed_work_sync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取消延迟工作项</span>
  <span class="token function">flush_workqueue</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 刷新工作队列</span>
  <span class="token function">destroy_workqueue</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 销毁工作队列</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"bye bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>interrupt_irq_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>interrupt_irq_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="46-4-运行测试"><a href="#46-4-运行测试" class="headerlink" title="46.4 运行测试"></a>46.4 运行测试</h3><h4 id="46-4-1-编译驱动程序"><a href="#46-4-1-编译驱动程序" class="headerlink" title="46.4.1 编译驱动程序"></a>46.4.1 编译驱动程序</h4><p>在上一小节中的interrupt.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成interrupt.ko 目标文件，至此驱动模块就编译成功了，接下来进行测试。</p>
<h4 id="46-4-2-运行测试"><a href="#46-4-2-运行测试" class="headerlink" title="46.4.2 运行测试"></a>46.4.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图46-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod interrupt.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201530114.png" alt="image-20240820153049966"></p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7 寸屏幕，打印如下图（46-8）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201531165.png" alt="image-20240820153113008"></p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被打印了多次，说明触发了多次中断上文，在4 秒之后，打印工作项处理函数中的“This is test_work”。4 秒之后打印“This is test_work”是因为调度延迟工作函数写了延迟3 秒，再加上工作项处理函数中延迟了一秒，所以一共是4 秒。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图46-9）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod interrupt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201532348.png" alt="image-20240820153213198"></p>
<p>至此，延迟工作实验就完成了。</p>
<h2 id="第47-章工作队列传参实验"><a href="#第47-章工作队列传参实验" class="headerlink" title="第47 章工作队列传参实验"></a>第47 章工作队列传参实验</h2><p>在41 章节中，我们使用tasklet 来实现中断下文，并使用tasklet 给中断下文传参，如果我们使用工作队列来实现中断的下半部分，那么如何用工作队列给中断下文传参呢？本章节我们来一探究竟！</p>
<h3 id="47-1-工作队列传参"><a href="#47-1-工作队列传参" class="headerlink" title="47.1 工作队列传参"></a>47.1 工作队列传参</h3><p>在Linux 内核的工作队列中，可以通过使用工作项的方式向工作队列传递参数。工作项是一个抽象的结构，可以用于封装需要执行的工作及其相关的参数。</p>
<p>首先我们定义工作项结构，如下所示，在结构体<code>struct work_data</code> 中定义了需要传递给工作项处理函数的参数a 和b，然后定义一个类型为<code>struct work_data</code> 的变量<code>test_workqueue_work</code>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">work_data</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">work_struct</span> test_work<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">work_data</span> test_workqueue_work<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来在模块初始化函数interrupt_irq_init 中创建了一个工作队列test_workqueue 和一个工作项test_workqueue_work。</p>
<pre class="line-numbers language-none"><code class="language-none">test_workqueue = create_workqueue("test_workqueue"); // 创建工作队列
INIT_WORK(&amp;test_workqueue_work.test_work, test_work); // 初始化工作项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>然后在模块初始化函数中，为工作项的参数a 和b 赋值。</p>
<pre class="line-numbers language-none"><code class="language-none">test_workqueue_work.a = 1;
test_workqueue_work.b = 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当中断触发时，在中断处理函数test_interrupt 中，通过调用queue_work 函数将工作项<code>test_workqueue_work.test_work</code> 提交到工作队列test_workqueue 中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">queue_work</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">.</span>test_work<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后工作项处理函数test_work 定义了一个指针pdata，将工作项转换为<code>struct work_data</code>结构，并通过该结构访问参数a 和b。如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test_work</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">work_data</span> <span class="token operator">*</span>pdata<span class="token punctuation">;</span>
    pdata <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>work<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">work_data</span><span class="token punctuation">,</span> test_work<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"a is %d\n"</span><span class="token punctuation">,</span> pdata<span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"b is %d\n"</span><span class="token punctuation">,</span> pdata<span class="token operator">-&gt;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样，当工作队列被调度执行时，工作项处理函数test_work 将能够访问到传递给工作项的参数a 和b,并在内核日志中打印他们的值。<br>注意，工作项处理函数中的<code>container_of</code> 宏用于从工作项结构的指针获取整个<code>struct work_data</code> 结构的指针。这样可以通过指针偏移来访问工作项结构中的其他字段，例如参数a和b。</p>
<p>详细的驱动代码编写见下一小节。</p>
<h3 id="47-2-实验程序的编写"><a href="#47-2-实验程序的编写" class="headerlink" title="47.2 实验程序的编写"></a>47.2 实验程序的编写</h3><h4 id="47-2-1-驱动程序编写"><a href="#47-2-1-驱动程序编写" class="headerlink" title="47.2.1 驱动程序编写"></a>47.2.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\37_workqueue_data\module</code>。</p>
<p>编写完成的interrupt.c 代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/gpio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/workqueue.h&gt;</span></span>

<span class="token keyword">int</span> irq<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">work_data</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">work_struct</span> test_work<span class="token punctuation">;</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">work_data</span> test_workqueue_work<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span>test_workqueue<span class="token punctuation">;</span>

<span class="token comment">// 工作项处理函数</span>
<span class="token keyword">void</span> <span class="token function">test_work</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">work_data</span> <span class="token operator">*</span>pdata<span class="token punctuation">;</span>
  pdata <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>work<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">work_data</span><span class="token punctuation">,</span> test_work<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"a is %d"</span><span class="token punctuation">,</span> pdata<span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"b is %d"</span><span class="token punctuation">,</span> pdata<span class="token operator">-&gt;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中断处理函数</span>
<span class="token class-name">irqreturn_t</span> <span class="token function">test_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_interrupt\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 提交工作项到工作队列</span>
  <span class="token function">queue_work</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">.</span>test_work<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">IRQ_RETVAL</span><span class="token punctuation">(</span>IRQ_HANDLED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">interrupt_irq_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
  irq <span class="token operator">=</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将GPIO映射为中断号</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"irq is %d\n"</span><span class="token punctuation">,</span> irq<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 请求中断</span>
  ret <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> test_interrupt<span class="token punctuation">,</span> IRQF_TRIGGER_RISING<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"request_irq is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 创建工作队列</span>
  test_workqueue <span class="token operator">=</span> <span class="token function">create_workqueue</span><span class="token punctuation">(</span><span class="token string">"test_workqueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化工作项</span>
  <span class="token function">INIT_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">.</span>test_work<span class="token punctuation">,</span> test_work<span class="token punctuation">)</span><span class="token punctuation">;</span>

  test_workqueue_work<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  test_workqueue_work<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">interrupt_irq_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">free_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">// 释放中断</span>
  <span class="token function">cancel_work_sync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">.</span>test_work<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取消工作项</span>
  <span class="token function">flush_workqueue</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 刷新工作队列</span>
  <span class="token function">destroy_workqueue</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 销毁工作队列</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"bye bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>interrupt_irq_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>interrupt_irq_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="47-3-运行测试"><a href="#47-3-运行测试" class="headerlink" title="47.3 运行测试"></a>47.3 运行测试</h3><h4 id="47-3-1-编译驱动程序"><a href="#47-3-1-编译驱动程序" class="headerlink" title="47.3.1 编译驱动程序"></a>47.3.1 编译驱动程序</h4><p>在上一小节中的interrupt.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成interrupt.ko 目标文件，至此驱动模块就编译成功了，接下来进行测试。</p>
<h4 id="47-3-2-运行测试"><a href="#47-3-2-运行测试" class="headerlink" title="47.3.2 运行测试"></a>47.3.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图47-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod interrupt.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201541652.png" alt="image-20240820154151484"></p>
<p>驱动加载之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7 寸屏幕，打印如下图（47-5）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201542238.png" alt="image-20240820154204072"></p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和传递给工作项的参数a 和b 的值。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图47-6）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod interrupt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201542284.png" alt="image-20240820154226124"></p>
<p>至此，工作队列传参实验就完成了。</p>
<h2 id="第48-章并发管理工作队列实验"><a href="#第48-章并发管理工作队列实验" class="headerlink" title="第48 章并发管理工作队列实验"></a>第48 章并发管理工作队列实验</h2><p>在现代的软件开发中，我们常常面临着需要同时处理多个任务的挑战。这些任务可能是并行的、独立的，或者需要以某种顺序进行处理。为了高效地管理这些并发任务，我们需要一种有效的机制来协调它们的执行。这就是并发管理工作队列发挥作用的地方。本章节我们来学习并发管理工作队列。</p>
<h3 id="48-1-工作队列的实现"><a href="#48-1-工作队列的实现" class="headerlink" title="48.1 工作队列的实现"></a>48.1 工作队列的实现</h3><p>在44 章节和45 章节，我们学习了共享工作队列和自定义工作队列，在使用工作队列时，我们首先定义一个work 结构体，然后将work 添加到workqueue(工作队列)中，最后<code>worker thread</code>执行<code>workqueue</code>。当工作队列中有新work 产生时，工作线程（worker thread）会执行工作队列中每个work。当执行完结束的时候，<code>worker thread</code> 会睡眠，等到新的中断产生，work 再继续添加到工作队列，然后工作线程执行每个工作，周而复始。</p>
<p>在单核线程的系统中，通常会为每个CPU（核心）初始化一个工作线程并关联一个工作队列。这种默认设置确保每个CPU 都有一个专门的线程来处理与其绑定的工作队列上的工作项。如下图（48-1）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201543177.png" alt="image-20240820154331016" style="zoom:50%;">

<p>在多核线程系统中，工作队列的设计与单核线程系统有所不同。在多核线程系统中，通常会存在多个工作队列，每个工作队列与一个工作线程（Worker Thread）绑定。这样可以充分利用多个核心的并行处理能力。如下图（48-2）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201543733.png" alt="image-20240820154349505"></p>
<p>当有新的工作项产生时，系统需要决定将其分配给哪个工作队列。一种常见的策略是使用负载均衡算法，根据工作队列的负载情况来平衡分配工作项，以避免某个工作队列过载而导致性能下降。每个工作队列独立管理自己的工作项。当有新的工作项添加到工作队列时，工作线程会从其关联的工作队列中获取待执行的工作项，并执行相应的处理函数。在多核线程系统中，多个工作线程可以同时执行各自绑定的工作队列中的工作项。这样可以实现并行处理，提高系统的整体性能和响应速度。</p>
<p>了解了工作队列是如何实现的，接下来我们看看传统的工作队列有什么弊端呢？</p>
<h3 id="48-2-workqueue-队列弊端"><a href="#48-2-workqueue-队列弊端" class="headerlink" title="48.2 workqueue 队列弊端"></a>48.2 workqueue 队列弊端</h3><p>假如说有三个work 放到了同一个工作队列上，接下来CPU 会启动工作线程去执行这三个work，如下图（48-3）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201544353.png" alt="image-20240820154423187" style="zoom:50%;">

<p>在上图中，工作项w0、w1、w2 被排队到同一个CPU 上的绑定工作队列上。w0 工作项执行的时候，先工作5 毫秒，然后睡觉10 毫秒，然后再工作CPU 5 毫秒，然后完成。工作项w1 和w2 都是工作5ms，然后睡眠10 ms，然后完成。传统工作队列的弊端如下所示：</p>
<ul>
<li>1 在工作项w0 工作甚至是睡眠时，工作项w1 w2 是排队等待的，在繁忙的系统中，工作队列可能会积累大量的待处理工作项，导致任务调度的延迟，这可能会影响系统的响应性能，并增加工作项的处理时间。</li>
<li>2 在工作队列中，不同的工作项可能具有不同的处理时间和资源需求。如果工作项的处理时间差异很大，一些工作线程可能会一直忙于处理长时间的工作项，而其他工作线程则处于空闲状态，导致资源利用不均衡。</li>
<li>3 在多线程环境下，多个工作线程同时访问和修改工作队列可能会导致竞争条件的发生。为了确保数据的一致性和正确性，需要采用适当的同步机制，如锁或原子操作，来保护共享数据，但这可能会引入额外的同步开销。</li>
<li>4 工作队列通常按照先进先出（FIFO）的方式处理工作项，缺乏对工作项优先级的细粒度控制。在某些场景下，可能需要根据工作项的重要性或紧急程度进行优先级调度，而工作队列本身无法提供这种级别的优先级控制。</li>
<li>5 当工作线程从工作队列中获取工作项并执行时，可能需要频繁地进行上下文切换，将处理器的执行上下文从一个线程切换到另一个线程。这种上下文切换开销可能会影响系统的性能和效率。</li>
</ul>
<h3 id="48-2-什么是并发管理工作队列"><a href="#48-2-什么是并发管理工作队列" class="headerlink" title="48.2 什么是并发管理工作队列"></a>48.2 什么是并发管理工作队列</h3><p>通过上一小节的学习，我们认识到传统的工作队列无论是单核系统还是多核系统上都是有缺陷的。比如无法充分利用多核处理器的计算能力以及对于不同优先级的工作项无法提供公平的调度。为了解决这些问题，Con Kolivas 提出了CMWQ 调度算法。</p>
<p>CMWQ 全称是concurrency Managed Workqueue，意为并发管理工作队列。并发管理工作队列是一种并发编程模式，用于有效地管理和调度待执行的任务或工作项。它通常用于多线程或多进程环境中，以实现并发执行和提高系统的性能。CMWQ 工作实现如下图（48-4）所示：</p>
<img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201545682.png" alt="image-20240820154531509" style="zoom:80%;">

<p>当我们需要在一个系统中同时处理多个任务或工作时，使用并发管理工作队列是一种有效的方式。</p>
<p>想象一下，你是一个餐厅的服务员，有很多顾客同时来到餐厅用餐。为了提高效率，你需要将顾客的点菜请求放到一个队列中，这就是工作队列。然后，你和其他服务员可以从队列中获取顾客的点菜请求，每个服务员独立地为顾客提供服务。通过这种方式，你们可以并发地处理多个顾客的点菜请求，而不需要等待上一个顾客点完菜再去处理下一个顾客的请求。每个服务员可以独立地从队列中获取任务，并根据需要执行相应的服务。这种独立获取任务的过程就是从工作队列中取出任务并执行的过程。</p>
<p>通过并发管理工作队列，你们能够更高效地处理顾客的点菜请求，提高服务的速度和质量。同时，这种方式也能够更好地利用你们的工作能力，因为每个服务员都可以独立处理任务，而不会相互干扰或等待。</p>
<p>总的来说，通过并发管理工作队列，我们可以同时处理多个任务或工作，提高系统的并发性和性能。每个任务独立地从队列中获取并执行，这种解耦使得整个系统更加高效、灵活，并且能够更好地应对多任务的需求。</p>
<h3 id="48-3-并发管理工作队列接口函数"><a href="#48-3-并发管理工作队列接口函数" class="headerlink" title="48.3 并发管理工作队列接口函数"></a>48.3 并发管理工作队列接口函数</h3><p><code>alloc_workqueue</code> 是Linux 内核中的一个函数，用于创建和分配一个工作队列。工作队列是一种用于管理和调度工作项的机制，可用于实现并发处理和异步任务处理。<code>alloc_workqueue</code>函数的原型如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span><span class="token function">alloc_workqueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> max_active<span class="token punctuation">)</span><span class="token punctuation">;</span>
参数说明：
    fmt：指定工作队列的名称格式。
    flags：指定工作队列的标志，可以控制工作队列的行为和属性，如WQ_UNBOUND 表示无绑定的工作队列，WQ_HIGHPRI 表示高优先级的工作队列等。
    max_active：指定工作队列中同时活跃的最大工作项数量。
返回值：
    函数返回一个指向工作队列结构体（<span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span>）的指针，或者返回<span class="token constant">NULL</span> 表示创建失败。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>在下一小节中将使用上述API 进行相应的实验。</p>
<h3 id="48-4-实验程序的编写"><a href="#48-4-实验程序的编写" class="headerlink" title="48.4 实验程序的编写"></a>48.4 实验程序的编写</h3><h4 id="48-4-1-驱动程序编写"><a href="#48-4-1-驱动程序编写" class="headerlink" title="48.4.1 驱动程序编写"></a>48.4.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\38_CMWQ\module</code>。<br>本实验在35 自定义工作队列实验的基础上进行修改，使用<code>alloc_workqueue</code> 函数创建和分配一个工作队列。编写完成的interrupt.c 代码如下所示，添加的代码已加粗表示。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/gpio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/workqueue.h&gt;</span></span>

<span class="token keyword">int</span> irq<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span>test_workqueue<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">work_struct</span> test_workqueue_work<span class="token punctuation">;</span>

<span class="token comment">// 工作项处理函数</span>
<span class="token keyword">void</span> <span class="token function">test_work</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">work_struct</span> <span class="token operator">*</span>work<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">msleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_work\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中断处理函数</span>
<span class="token class-name">irqreturn_t</span> <span class="token function">test_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_interrupt\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">queue_work</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 提交工作项到工作队列</span>
  <span class="token keyword">return</span> <span class="token function">IRQ_RETVAL</span><span class="token punctuation">(</span>IRQ_HANDLED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">interrupt_irq_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
  irq <span class="token operator">=</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将GPIO映射为中断号</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"irq is %d\n"</span><span class="token punctuation">,</span> irq<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 请求中断</span>
  ret <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> test_interrupt<span class="token punctuation">,</span> IRQF_TRIGGER_RISING<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"request_irq is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 用于创建和分配一个工作队列</span>
  test_workqueue <span class="token operator">=</span> <span class="token function">alloc_workqueue</span><span class="token punctuation">(</span><span class="token string">"test_workqueue"</span><span class="token punctuation">,</span> WQ_UNBOUND<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">INIT_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">,</span> test_work<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化工作项</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">interrupt_irq_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">free_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 释放中断</span>
  <span class="token function">cancel_work_sync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_workqueue_work<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取消工作项</span>
  <span class="token function">flush_workqueue</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 刷新工作队列</span>
  <span class="token function">destroy_workqueue</span><span class="token punctuation">(</span>test_workqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 销毁工作队列</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"bye bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>interrupt_irq_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>interrupt_irq_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="48-5-运行测试"><a href="#48-5-运行测试" class="headerlink" title="48.5 运行测试"></a>48.5 运行测试</h3><h4 id="48-5-1-编译驱动程序"><a href="#48-5-1-编译驱动程序" class="headerlink" title="48.5.1 编译驱动程序"></a>48.5.1 编译驱动程序</h4><p>在上一小节中的interrupt.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成interrupt.ko 目标文件，至此驱动模块就编译成功了，接下来进行测试。</p>
<h4 id="48-5-2-运行测试"><a href="#48-5-2-运行测试" class="headerlink" title="48.5.2 运行测试"></a>48.5.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图48-8）所示：</p>
<pre class="line-numbers language-none"><code class="language-none">insmod interrupt.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201549110.png" alt="image-20240820154924953"></p>
<p>驱动加载之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7 寸屏幕，打印如下图（48-9）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201549205.png" alt="image-20240820154935036"></p>
<p>我们按一下屏幕，立即输入“<code>ps -aux | grep test_workqueue</code>”,可以看到工作线程，如下图（48-10）所示，u 代表无绑定的工作队列。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201549571.png" alt="image-20240820154951409"></p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图48-11）所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">rmmod interrupt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201550767.png" alt="image-20240820155010610"></p>
<p>至此，并发管理工作队列实验就完成了。</p>
<h2 id="第49-章中断线程化实验"><a href="#第49-章中断线程化实验" class="headerlink" title="第49 章中断线程化实验"></a>第49 章中断线程化实验</h2><p>中断线程化是实时Linux 项目开发的一个新特性，目的是降低中断处理对系统实时延迟的影响。本章节我们来一项新技术——中断线程化。</p>
<h3 id="49-1-什么是中断线程化"><a href="#49-1-什么是中断线程化" class="headerlink" title="49.1 什么是中断线程化"></a>49.1 什么是中断线程化</h3><p>中断线程化是一种优化技术，用于提高多线程程序的性能。</p>
<p>想象一下，你正在做一项任务，但是总是被别人的打扰所中断，每次都要停下手头的工作去处理别人的事情。这样频繁的中断会让你的工作效率变低，因为你需要反复切换任务，无法专心做好自己的工作。</p>
<p>在多线程程序中，也存在类似的问题。有时硬件或其他事件会发出中断信号，打断正在执行的线程，需要切换到中断处理程序去处理这些事件。这种频繁的中断切换会导致额外的开销和延迟，影响程序的性能。</p>
<p>为了解决这个问题，中断线程化提出了一种优化方案。它将中断处理程序从主线程中独立出来，创建一个专门的线程来处理这些中断事件。这样，主线程就不再受到中断的干扰，可以专注于自己的工作，不再频繁地被打断。</p>
<p><strong>中断线程化的核心思想是将中断处理和主线程的工作分开，让它们可以并行执行</strong>。中断线程负责处理中断事件，而主线程负责执行主要的工作任务。这样一来，不仅可以减少切换的开销，还可以提高整个程序的响应速度和性能。</p>
<p><strong>需要注意的是，中断线程化还需要处理线程之间的同步和数据共享问题。因为中断线程和主线程可能会同时访问和修改共享的数据，所以需要合理地进行同步操作，确保数据的一致性和正确性</strong>。</p>
<p>总而言之，中断线程化是一种优化技术，通过将中断处理和主线程的工作分开，提高多线程程序的性能。让主线程不再频繁被中断，可以专注于自己的工作，从而提高程序的效率和响应速度。</p>
<p>中断线程化的处理仍然可以看作是将原来的中断上半部分和中断下半部分。上半部分还是用来处理紧急的事情，下半部分也是出路比较耗时的操作，但是下半部分会交给一个专门的内核线程来处理。这个内核线程只用于这个中断。当发生中断的时候，会唤醒这个内核线程，然后由这个内核线程来执行中断下半部分的函数。</p>
<h3 id="49-2-中断线程化接口函数"><a href="#49-2-中断线程化接口函数" class="headerlink" title="49.2 中断线程化接口函数"></a>49.2 中断线程化接口函数</h3><p><code>request_threaded_irq</code> 是Linux 内核中用于请求并注册一个线程化的中断处理函数的函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">request_threaded_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token class-name">irq_handler_t</span> handler<span class="token punctuation">,</span>
                        <span class="token class-name">irq_handler_t</span> thread_fn<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> irqflags<span class="token punctuation">,</span>
                        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>devname<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span>

参数说明
    irq：中断号，表示要请求的中断线路。
    handler：是在发生中断时首先要执行的处理程序，非常类似于顶半部，该函数最后会返回IRQ_WAKE_THREAD 来唤醒中断，一般handler 设为<span class="token constant">NULL</span>，用系统提供的默认处理。
    thread_fn：线程化的中断处理函数，非常类似于底半部。如果此处设置为<span class="token constant">NULL</span> 则表示没有使用中断线程化。
    irqflags：中断标志，用于指定中断的属性和行为。
    devname：中断的名称，用于标识中断请求的设备。
    dev_id：设备标识符，用于传递给中断处理函数的参数。
函数返回值
    函数返回一个整数值，表示中断请求的结果。如果中断请求成功，返回值为<span class="token number">0</span>，否则返回一个负数错误代码。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在下一小节中将使用上述API 进行相应的实验，利用中断线程化相关知识来对共享工作队列实验进行优化。</p>
<h3 id="49-3-实验程序的编写"><a href="#49-3-实验程序的编写" class="headerlink" title="49.3 实验程序的编写"></a>49.3 实验程序的编写</h3><h4 id="49-3-1-驱动程序编写"><a href="#49-3-1-驱动程序编写" class="headerlink" title="49.3.1 驱动程序编写"></a>49.3.1 驱动程序编写</h4><p>本实验对应的网盘路径为：<code>iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\39_request_threaded_irq\module</code>。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD 显示屏就会触发中断服务函数，在中断服务函数中提交工作项到工作队列中，打印“This id test_interrupt”，并打印“Thisis test_work”。</p>
<p>我们要实现一个简单的中断处理的例子，用于展示中断的顶半部和底半部处理的概念，并通过线程化的工作队列实现了底半部的延时处理。编写完成的interrupt.c 代码如下所示，添加的代码已加粗表示。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/interrupt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/gpio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/delay.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/workqueue.h&gt;</span></span>

<span class="token keyword">int</span> irq<span class="token punctuation">;</span>

<span class="token comment">// 中断处理函数的底半部（线程化中断处理函数）</span>
<span class="token class-name">irqreturn_t</span> <span class="token function">test_work</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// 执行底半部的中断处理任务</span>
  <span class="token function">msleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_work\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">IRQ_RETVAL</span><span class="token punctuation">(</span>IRQ_HANDLED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中断处理函数的顶半部</span>
<span class="token class-name">irqreturn_t</span> <span class="token function">test_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"This is test_interrupt\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 将中断处理工作推迟到底半部</span>
  <span class="token keyword">return</span> IRQ_WAKE_THREAD<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">interrupt_irq_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
  irq <span class="token operator">=</span> <span class="token function">gpio_to_irq</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将GPIO映射为中断号</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"irq is %d\n"</span><span class="token punctuation">,</span> irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 用于请求并注册一个线程化的中断处理函数</span>
  ret <span class="token operator">=</span> <span class="token function">request_threaded_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> test_interrupt<span class="token punctuation">,</span> test_work<span class="token punctuation">,</span> IRQF_TRIGGER_RISING<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"request_irq is error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">interrupt_irq_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">free_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放中断</span>
  <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"bye bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>interrupt_irq_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>interrupt_irq_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"topeet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="49-4-运行测试"><a href="#49-4-运行测试" class="headerlink" title="49.4 运行测试"></a>49.4 运行测试</h3><h4 id="49-4-1-编译驱动程序"><a href="#49-4-1-编译驱动程序" class="headerlink" title="49.4.1 编译驱动程序"></a>49.4.1 编译驱动程序</h4><p>在上一小节中的interrupt.c 代码同一目录下创建Makefile 文件，Makefile 文件内容：然后使用命令“make”进行驱动的编译，编译完生成interrupt.ko 目标文件，至此驱动模块就编译成功了，接下来进行测试。</p>
<h4 id="49-4-2-运行测试"><a href="#49-4-2-运行测试" class="headerlink" title="49.4.2 运行测试"></a>49.4.2 运行测试</h4><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图49-4）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod interrupt.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201555342.png" alt="image-20240820155511176"></p>
<p>可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7 寸屏幕，打印如下图（49-5）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201555234.png" alt="image-20240820155525065"></p>
<p>我们按一下屏幕，立即输入“<code>ps -aux | grep test_workqueue</code>”,可以看到工作线程，如下图（49-6）所示，u 代表无绑定的工作队列。</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201555055.png" alt="image-20240820155542890"></p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图49-7）所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rmmod interrupt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408201556792.png" alt="image-20240820155612628"></p>
<p>至此，中断线程化实验就完成了。</p>
<h1 id="第六篇平台总线"><a href="#第六篇平台总线" class="headerlink" title="第六篇平台总线"></a>第六篇平台总线</h1><h2 id="第50-章平台总线模型介绍"><a href="#第50-章平台总线模型介绍" class="headerlink" title="第50 章平台总线模型介绍"></a>第50 章平台总线模型介绍</h2><p>在前面所有章节中，无论要完成何种需求，我们都编写了一个独立的驱动程序，但这样编写出来的驱动程序在重用性和可移植性上是很低的，无论之后要编写一个同类型的驱动还是将该驱动更换一个平台，都要花费时间重新修改驱动代码，而驱动的分离和分层这一软件思路的提出（即本章节要讲解的平台总线模型），就是为了解决这个问题，下面让我们一起进入平台总线模型的学习吧。</p>
<h3 id="50-1-什么是平台总线？"><a href="#50-1-什么是平台总线？" class="headerlink" title="50.1 什么是平台总线？"></a>50.1 什么是平台总线？</h3><p>平台总线（Platform bus）是Linux 内核中提供的一种虚拟总线，用于管理和组织与特定硬件平台相关的设备和驱动。它充当了平台设备（platform device）和平台驱动（platform driver）之间的桥梁，负责将它们进行匹配和绑定。</p>
<p><strong>当系统注册一个平台设备时，平台总线会寻找与之匹配的平台驱动</strong>。它会遍历已注册的平台驱动列表，尝试与每个平台驱动进行匹配，直到找到与平台设备匹配的驱动为止。一旦找到匹配的驱动，平台总线会将平台设备与平台驱动进行绑定，使得设备可以被正确地初始化和操作。</p>
<p>同样地，<strong>当系统注册一个平台驱动时，平台总线会寻找与之匹配的平台设备</strong>。它会遍历已注册的平台设备列表，尝试与每个平台设备进行匹配，直到找到与平台驱动匹配的设备为止。一旦找到匹配的设备，平台总线会将平台设备与平台驱动进行绑定，使得驱动可以管理和控制与该设备相关的操作。</p>
<p>设备、平台总线、驱动的关系如下图（图50-1）所示：</p>
<p><img src="./images/loading.gif" data-original="https://geyangwen-images.oss-cn-hangzhou.aliyuncs.com/2024/Android/202408211157805.png" alt="image-20240821115707652"></p>
<p>通过引入平台总线，Linux 内核提供了一种通用的机制来管理和组织与特定硬件平台相关的设备和驱动。它使得设备和驱动之间的匹配过程更加自动化和灵活，同时也提高了嵌入式系统的可移植性和可扩展性。</p>
<h3 id="50-2-平台总线的优势"><a href="#50-2-平台总线的优势" class="headerlink" title="50.2 平台总线的优势"></a>50.2 平台总线的优势</h3><p>在前面的章节中，我们编写的驱动程序将驱动和设备相关的内容放在一起，但是当涉及到多个相同类型的设备时，这种方法会引发一系列问题。举个例子，假设我们有一个硬件平台，该硬件平台上存在了500 个模块，这些模块都使用了LED 灯。如果我们使用杂项设备来编写驱动，虽然相比字符设备，杂项设备的代码量较少，但我们仍旧需要编写500 份类似的代码，从而生成相应的设备节点，以供上层应用在不同模块上控制LED 灯。</p>
<p>编写500 份重复的代码会带来两个问题。首先，会造成大量重复劳动。其次，代码的重用性较差。如果我们需要将这些驱动从一个平台移植到另一个平台，就需要逐个修改驱动代码，尽管只需修改与硬件相关的部分，但仍旧是一个很大的工作量。</p>
<p>而在引入了平台总线模型后，这些问题就得到了很好地解决。通过使用平台总线模型，将设备驱动和平台设备进行了分离。这样一来，我们只需编写一份通用的驱动代码即可，然后针对不同的平台设备进行配置，这就大大减少了重复编写代码的工作量，并提高了驱动代码的重用性。当我们需要将驱动移植到不同的平台时，只需对硬件相关的部分进行适配即可，其他部分可以保持不变。</p>
<p>整理出来的平台总线优势如下所示：</p>
<ul>
<li>（1）<strong>设备与驱动的分离</strong>：传统的设备驱动模型将设备和驱动代码合并在同一个文件中，导致代码冗余和可维护性差。而平台总线模型将设备代码和驱动代码分离，设备代码放在device.c 文件中，驱动代码放在driver.c 文件中。这种分离使得设备和驱动的职责更加清晰，提高了代码的可读性和可维护性。</li>
<li>（2）<strong>提高代码的重用性</strong>：平台总线模型使得相同类型的设备可以共享相同的驱动代码。例如，在一个硬件平台上存在多个相同类型的设备，传统的驱动模型需要为每个设备编写独立的驱动代码。而使用平台总线模型，只需编写一个通用的驱动代码，然后为每个设备创建相应的device.c 文件，将设备特定的代码放在其中。这样可以减少代码的重复性，提高了代码的重用性和可维护性。</li>
<li>（3）<strong>减少重复性代码</strong>：在传统的设备驱动模型中，如果有多个相同类型的设备存在，就需要为每个设备编写独立的驱动代码。而使用平台总线模型，只需编写一个通用的驱动代码，然后为每个设备创建相应的device.c 文件，将设备特定的代码放在其中。这样可以避免大量的重复性代码，简化了驱动开发过程。</li>
<li>（4）<strong>提高可移植性</strong>：平台总线模型可以提高驱动的可移植性。开发者可以编写适应平台总线的平台驱动程序，从而支持特定的外设，而无需依赖于特定的标准总线。这使得驱动可以更容易地在不同的硬件平台之间进行移植和重用。</li>
</ul>
<h2 id="第51-章注册platform-设备实验"><a href="#第51-章注册platform-设备实验" class="headerlink" title="第51 章注册platform 设备实验"></a>第51 章注册platform 设备实验</h2><h3 id="51-1-注册platform-设备"><a href="#51-1-注册platform-设备" class="headerlink" title="51.1 注册platform 设备"></a>51.1 注册platform 设备</h3><h4 id="51-1-1-platform-device-register-函数"><a href="#51-1-1-platform-device-register-函数" class="headerlink" title="51.1.1 platform_device_register 函数"></a>51.1.1 <code>platform_device_register</code> 函数</h4><p><code>platform_device_register</code> 函数用于将<code>platform_device</code> 结构体描述的平台设备注册到内核中。下面是对<code>platform_device_register</code> 函数的详细介绍：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">int</span> <span class="token function">platform_device_register</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
头文件：
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/platform_device.h&gt;</span></span>
函数作用：
    platform_device_register 函数用于将platform_device 结构体描述的平台设备注册到内核中，使其能够参与设备的资源分配和驱动的匹配。
参数含义：
    pdev：指向platform_device 结构体的指针，描述要注册的平台设备的信息。
返回值：
    成功：返回<span class="token number">0</span>，表示设备注册成功。
    失败：返回负数，表示设备注册失败，返回的负数值表示错误代码。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>pdev 参数是一个指向platform_device 结构体的指针，其中包含了描述平台设备的各种属性和信息。platform_device 结构体包含了设备名称、设备资源、设备ID 等信息，用于描述和标识平台设备，会在接下来的小节对该结构体进行详细的介绍。<br>该函数在内核源码目录下的“<code>/include/linux/platform_device.h</code>”文件中，具体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">platform_device_register</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>函数声明中的extern 关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而<code>platform_device_register</code> 实际定义在“/drivers/base/platform.c”文件中，相关定义如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">platform_device_register</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>pdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">device_initialize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">arch_setup_pdev_archdata</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">platform_device_add</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数内部有三个主要的操作。</p>
<ul>
<li>第3 行：调用了device_initialize 函数，用于对pdev-&gt;dev 进行初始化。<code>pdev-&gt;dev</code> 是<code>struct platform_device</code> 结构体中的一个成员，它表示平台设备对应的<code>struct device</code> 结构体。通过调用<code>device_initialize</code> 函数，对<code>pdev-&gt;dev</code> 进行一些基本的初始化工作，例如设置设备的引用计数、设备的类型等。</li>
<li>第4 行：调用了arch_setup_pdev_archdata 函数，用于根据平台设备的架构数据来设置pdev的架构相关数据。这个函数的具体实现可能与具体的架构相关，它主要用于在不同的架构下对平台设备进行特定的设置。</li>
<li>第5 行： 调用了platform_device_add 函数， 将平台设备pdev 添加到内核中。platform_device_add 函数会完成平台设备的添加操作，包括将设备添加到设备层级结构中、添加设备的资源等。它会返回一个int 类型的结果，表示设备添加的结果。</li>
</ul>
<p>platform_device_register 函数的主要作用是将platform_device 结构体描述的平台设备注册到内核中，包括设备的初始化、添加到platform 总线和设备层级结构、添加设备资源等操作。通过该函数，平台设备被注册后，就能够参与设备的资源分配和驱动的匹配过程。函数的返回值可以用于判断设备注册是否成功。</p>
<h4 id="51-1-2-platform-device-unregister-函数"><a href="#51-1-2-platform-device-unregister-函数" class="headerlink" title="51.1.2 platform_device_unregister 函数"></a>51.1.2 <code>platform_device_unregister</code> 函数</h4><p>platform_device_unregister 函数用于取消注册已经注册的平台设备，即从内核中移除设备。在设备不再需要时，调用该函数可以进行设备的清理和释放操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">函数原型：
    <span class="token keyword">void</span> <span class="token function">platform_device_unregister</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
头文件：
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/platform_device.h&gt;</span></span>
函数作用：
    platform_device_unregister 函数用于取消注册已经注册的平台设备，从内核中移除设备。
参数含义：
    pdev：指向要取消注册的平台设备的platform_device 结构体指针。
返回值：
    无返回值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该函数在内核源码目录下的“/include/linux/platform_device.h”文件中，具体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">platform_device_unregister</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>函数声明中的extern 关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而<code>platform_device_unregister</code> 实际定义在“<code>/drivers/base/platform.c</code>”文件中，相关定义如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">platform_device_unregister</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>pdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">platform_device_del</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">platform_device_put</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数内部有两个主要的操作：</p>
<ul>
<li>第3 行：调用了platform_device_del 函数，用于将设备从platform 总线的设备列表中移除。它会将设备从设备层级结构中移除，停止设备的资源分配和驱动的匹配。</li>
<li>第4 行：这一步调用了platform_device_put 函数，用于减少对设备的引用计数。这个函数会检查设备的引用计数，如果引用计数减为零，则会释放设备结构体和相关资源。通过减少引用计数，可以确保设备在不再被使用时能够被释放。</li>
</ul>
<p><code>platform_device_unregister</code> 函数的作用是取消注册已经注册的平台设备，从内核中移除设备。它先调用<code>platform_device_del</code> 函数将设备从设备层级结构中移除， 然后调用<code>platform_device_put</code> 函数减少设备的引用计数，确保设备在不再被使用时能够被释放。</p>
<h3 id="51-1-3-platform-device-结构体"><a href="#51-1-3-platform-device-结构体" class="headerlink" title="51.1.3 platform_device 结构体"></a>51.1.3 platform_device 结构体</h3><p>platform_device 结构体是用于描述平台设备的数据结构。它包含了平台设备的各种属性和信息，用于在内核中表示和管理平台设备。该结构体定义在内核的“/include/linux/platform_device.h”文件中，具体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">// 设备的名称，用于唯一标识设备</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span> <span class="token comment">// 设备的ID，可以用于区分同一种设备的不同实例</span>
    bool id_auto<span class="token punctuation">;</span> <span class="token comment">// 表示设备的ID 是否自动生成</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> dev<span class="token punctuation">;</span> <span class="token comment">// 表示平台设备对应的struct device 结构体，用于设备的基本管理和操作</span>
    u32 num_resources<span class="token punctuation">;</span> <span class="token comment">// 设备资源的数量</span>
    <span class="token keyword">struct</span> <span class="token class-name">resource</span> <span class="token operator">*</span>resource<span class="token punctuation">;</span> <span class="token comment">// 指向设备资源的指针</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">platform_device_id</span> <span class="token operator">*</span>id_entry<span class="token punctuation">;</span> <span class="token comment">// 指向设备的ID 表项的指针，用于匹配设备和驱动</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>driver_override<span class="token punctuation">;</span> <span class="token comment">// 强制设备与指定驱动匹配的驱动名称</span>
    <span class="token comment">/* MFD cell pointer */</span>
    <span class="token keyword">struct</span> <span class="token class-name">mfd_cell</span> <span class="token operator">*</span>mfd_cell<span class="token punctuation">;</span> <span class="token comment">// 指向多功能设备（MFD）单元的指针，用于多功能设备的描述</span>
    <span class="token comment">/* arch specific additions */</span>
    <span class="token keyword">struct</span> <span class="token class-name">pdev_archdata</span> archdata<span class="token punctuation">;</span> <span class="token comment">// 用于存储特定于架构的设备数据</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面对于几个重要的参数和结构体进行讲解</p>
<ul>
<li><code>const char *name</code>：设备的名称，用于唯一标识设备。必须提供一个唯一的名称，以便内核能够正确识别和管理该设备。</li>
<li><code>int id</code>：设备的ID，可以用于区分同一种设备的不同实例。这个参数是可选的，如果不需要使用ID 进行区分，可以将其设置为-1，</li>
<li><code>struct device dev</code>：表示平台设备对应的struct device 结构体，用于设备的基本管理和操作。必须为该参数提供一个有效的struct device 对象，该结构体的release 方法必须要实现，否则在编译的时候会报错。</li>
<li><code>u32 num_resources</code>：设备资源的数量。如果设备具有资源（如内存区域、中断等），则需要提供资源的数量。</li>
<li><code>struct resource *resource</code>：指向设备资源的指针。如果设备具有资源，需要提供一个指向资源数组的指针，会在下个小节对该结构体进行详细的讲解。</li>
</ul>
<h4 id="51-1-4-resource-结构体"><a href="#51-1-4-resource-结构体" class="headerlink" title="51.1.4 resource 结构体"></a>51.1.4 resource 结构体</h4><p>struct resource 结构体用于描述系统中的设备资源，包括内存区域、I/O 端口、中断等，该结构体定义在内核的“<code>/include/linux/ioport.h</code>”文件中，具体内容如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">resource</span> <span class="token punctuation">{</span>
    <span class="token class-name">resource_size_t</span> start<span class="token punctuation">;</span> <span class="token comment">/* 资源的起始地址*/</span>
    <span class="token class-name">resource_size_t</span> end<span class="token punctuation">;</span> <span class="token comment">/* 资源的结束地址*/</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">/* 资源的名称*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 资源的标志位*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> desc<span class="token punctuation">;</span> <span class="token comment">/* 资源的描述信息*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">resource</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">/* 指向父资源的指针*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">resource</span> <span class="token operator">*</span>sibling<span class="token punctuation">;</span> <span class="token comment">/* 指向同级兄弟资源的指针*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">resource</span> <span class="token operator">*</span>child<span class="token punctuation">;</span> <span class="token comment">/* 指向子资源的指针*/</span>
    
    <span class="token comment">/* 以下宏定义用于保留未使用的字段*/</span>
    <span class="token function">ANDROID_KABI_RESERVE</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ANDROID_KABI_RESERVE</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ANDROID_KABI_RESERVE</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ANDROID_KABI_RESERVE</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中最重要的是前四个参数，每个参数的具体介绍如下所示：</p>
<ul>
<li>（1）resource_size_t start：资源的起始地址。它表示资源的起始位置或者起始寄存器的地址。</li>
<li>（2）resource_size_t end：资源的结束地址。它表示资源的结束位置或者结束寄存器的地址。</li>
<li>（3）const char *name：资源的名称。它是一个字符串，用于标识和描述资源。</li>
<li>（4）unsigned long flags：资源的标志位。它包含了一些特定的标志，用于表示资源的属性或者特征。例如，可以用标志位来指示资源的可用性、共享性、缓存属性等。flags 参数的具体取值和含义可以根据系统和驱动的需求进行定义和解释，但通常情况下，它用于表示资源的属性、特征或配置选项。下面是一些常见的标志位及其可能的含义：</li>
</ul>
<ol>
<li><strong>资源类型相关标志位</strong>：</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">IORESOURCE_IO：表示资源是I<span class="token operator">/</span>O 端口资源。
IORESOURCE_MEM：表示资源是内存资源。
IORESOURCE_REG：表示资源是寄存器偏移量。
IORESOURCE_IRQ：表示资源是中断资源。
IORESOURCE_DMA：表示资源是DMA（直接内存访问）资源。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li><strong>资源属性和特征相关标志位：</strong></li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">IORESOURCE_PREFETCH：表示资源是无副作用的预取资源。
IORESOURCE_READONLY：表示资源是只读的。
IORESOURCE_CACHEABLE：表示资源支持缓存。
IORESOURCE_RANGELENGTH：表示资源的范围长度。
IORESOURCE_SHADOWABLE：表示资源可以被影子资源替代。
IORESOURCE_SIZEALIGN：表示资源的大小表示对齐。
IORESOURCE_STARTALIGN：表示起始字段是对齐的。
IORESOURCE_MEM_64：表示资源是<span class="token number">64</span> 位内存资源。
IORESOURCE_WINDOW：表示资源由桥接器转发。
IORESOURCE_MUXED：表示资源是软件复用的。
IORESOURCE_SYSRAM：表示资源是系统RAM（修饰符）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="3">
<li><strong>其他状态和控制标志位：</strong></li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">IORESOURCE_EXCLUSIVE：表示用户空间无法映射此资源。
IORESOURCE_DISABLED：表示资源当前被禁用。
IORESOURCE_UNSET：表示尚未分配地址给资源。
IORESOURCE_AUTO：表示地址由系统自动分配。
IORESOURCE_BUSY：表示驱动程序将此资源标记为繁忙。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="51-2-实验程序的编写"><a href="#51-2-实验程序的编写" class="headerlink" title="51.2 实验程序的编写"></a>51.2 实验程序的编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568 开发板【底板V1.7 版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux 驱动配套资料\04_Linux 驱动例程\40_platform_device\。</p>
<p>本实验将注册一个名为”my_platform_device” 的平台设备，当注册平台设备时，该驱动程序提供了两个资源：一个内存资源和一个中断资源。这些资源被定义在名为my_resources 的结构体数组中,具体内容如下：</p>
<p>内存资源：<br>    起始地址：MEM_START_ADDR（0xFDD60000）<br>    结束地址：MEM_END_ADDR（0xFDD60004）<br>    标记：IORESOURCE_MEM<br>中断资源：<br>    中断资源号：IRQ_NUMBER（101）<br>    标记：IORESOURCE_IRQ<br>编写完成的platform_device.c 代码如下所示：</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">葛杨文</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://gitee.com/ge-yangwen/geyangwen.gitee.io/2024/080957409.html">https://gitee.com/ge-yangwen/geyangwen.gitee.io/2024/080957409.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">葛杨文</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Android%E9%A9%B1%E5%8A%A8/">
                                    <span class="chip bg-color">Android驱动</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="./images/loading.gif" data-original="https://blog-accelerated.oss-cn-hangzhou.aliyuncs.com/source/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="./images/loading.gif" data-original="https://blog-accelerated.oss-cn-hangzhou.aliyuncs.com/source/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: '2GHAwHTGn8XLUAd7QB3o7e4c-gzGzoHsz',
        appKey: '4EmLXaoemlw5MQWjAC60IbU8',
        notify: '' === 'true',
        verify: '' === 'true',
        visitor: '' === 'true',
        avatar: 'monsterid',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '昵称填写qq可以显示qq头像和昵称哦~'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2024/080957409.html">
                    <div class="card-image">
                        
                        
                        <img src="./images/loading.gif" data-original="https://blog-accelerated.oss-cn-hangzhou.aliyuncs.com/source/medias/featureimages/11.jpg" class="responsive-img" alt="Android驱动的系统笔记1">
                        
                        <span class="card-title">Android驱动的系统笔记1</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-08-09
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android/" class="post-category">
                                    Android
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android%E9%A9%B1%E5%8A%A8/">
                        <span class="chip bg-color">Android驱动</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/071558324.html">
                    <div class="card-image">
                        
                        
                        <img src="./images/loading.gif" data-original="https://blog-accelerated.oss-cn-hangzhou.aliyuncs.com/source/medias/featureimages/19.jpg" class="responsive-img" alt="Android驱动基础知识">
                        
                        <span class="card-title">Android驱动基础知识</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-07-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android/" class="post-category">
                                    Android
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android%E9%A9%B1%E5%8A%A8/">
                        <span class="chip bg-color">Android驱动</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1,h2, h3, h4,h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1,h2, h3, h4,h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2024</span>
            
            <span id="year">2022</span>
            <a href="/about" target="_blank">葛杨文</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">496.5k</span>&nbsp;字
            
            
            
            
            
            <!-- 修改不蒜子初始化计数 -->
                  
                <span id="busuanzi_container_site_pv" style='display:none'></span>
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            
            
            
            
                <span id="busuanzi_container_site_uv" style='display:none'></span>
                    人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                
                                    
            <br>
            <!-- 增加建站时间（下面这句话） -->
            <span id="sitetime"></span>

            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Geyangwen" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:3057318483@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=3057318483" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 3057318483" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 增加建站时间 -->
<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2022, 10, 25, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "小破站已运行 " +diffYears+" 年 "+diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

<!-- 修改不蒜子初始化计数 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);  // 50ms周期检测函数
        var pvcountOffset = 80000;  // 初始化首次数据
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    });
</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    
        <!-- 添加死鬼你来了的小顽皮 -->
    <script type="text/javascript">
        var OriginTitile = document.title,
            st;
        document.addEventListener("visibilitychange", function () {
            document.hidden ? (document.title = "客官别走呀！", clearTimeout(st)) : (document.title =
                "(๑•̀ㅂ•́)死鬼你来了", st = setTimeout(function () {
                    document.title = OriginTitile
                }, 3e3))
        })
    </script>
    <!-- 樱花特效 -->
    <!-- <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
        }
    </script> -->
    

    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    


        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,c=(r.imageLazyLoadSetting.preloadRatio,n());function n(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=n());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),r.addEventListener("resize",a),r.addEventListener("orientationchange",a)}(this);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
